{"Asset":[{"_id":"themes/bitcore/source/css/style.styl","path":"css/style.styl","modified":false},{"_id":"themes/bitcore/source/js/retina.min.js","path":"js/retina.min.js","modified":false},{"_id":"themes/bitcore/source/js/script.js","path":"js/script.js","modified":false},{"_id":"themes/bitcore/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":false},{"_id":"themes/bitcore/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":false},{"_id":"themes/bitcore/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":false},{"_id":"themes/bitcore/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":false},{"_id":"themes/bitcore/source/css/images/bitbox-link.svg","path":"css/images/bitbox-link.svg","modified":false},{"_id":"themes/bitcore/source/css/images/bitpay-link.svg","path":"css/images/bitpay-link.svg","modified":false},{"_id":"themes/bitcore/source/css/images/cp-link.svg","path":"css/images/cp-link.svg","modified":false},{"_id":"themes/bitcore/source/css/images/copay-link.svg","path":"css/images/copay-link.svg","modified":false},{"_id":"themes/bitcore/source/css/images/cross-platform-illustration.png","path":"css/images/cross-platform-illustration.png","modified":false},{"_id":"themes/bitcore/source/css/images/enbitcoins-link.svg","path":"css/images/enbitcoins-link.svg","modified":false},{"_id":"themes/bitcore/source/css/images/functionality-illustration.png","path":"css/images/functionality-illustration.png","modified":false},{"_id":"themes/bitcore/source/css/images/insight-link.svg","path":"css/images/insight-link.svg","modified":false},{"_id":"themes/bitcore/source/css/images/keys-illustration.png","path":"css/images/keys-illustration.png","modified":false},{"_id":"themes/bitcore/source/css/images/logo-invert.png","path":"css/images/logo-invert.png","modified":false},{"_id":"themes/bitcore/source/css/images/logo-invert@2x.png","path":"css/images/logo-invert@2x.png","modified":false},{"_id":"themes/bitcore/source/css/images/logo.png","path":"css/images/logo.png","modified":false},{"_id":"themes/bitcore/source/css/images/logo@2x-invert.png","path":"css/images/logo@2x-invert.png","modified":false},{"_id":"themes/bitcore/source/css/images/logo@2x.png","path":"css/images/logo@2x.png","modified":false},{"_id":"themes/bitcore/source/css/images/mount-bg-hd.svg","path":"css/images/mount-bg-hd.svg","modified":false},{"_id":"themes/bitcore/source/css/images/o-source-illustration.png","path":"css/images/o-source-illustration.png","modified":false},{"_id":"themes/bitcore/source/css/images/p-protocol-illustration.png","path":"css/images/p-protocol-illustration.png","modified":false},{"_id":"themes/bitcore/source/css/images/paper-wallet-link.svg","path":"css/images/paper-wallet-link.svg","modified":false},{"_id":"themes/bitcore/source/css/images/streamium-link.svg","path":"css/images/streamium-link.svg","modified":false},{"_id":"themes/bitcore/source/css/images/volcano-ft.svg","path":"css/images/volcano-ft.svg","modified":false},{"_id":"themes/bitcore/source/css/images/volcano-hd-texture.png","path":"css/images/volcano-hd-texture.png","modified":false},{"_id":"themes/bitcore/source/css/images/lava-ball.png","path":"css/images/lava-ball.png","modified":false},{"_id":"themes/bitcore/source/css/animations.css","path":"css/animations.css","modified":false},{"_id":"themes/bitcore/source/css/images/bitcoin.svg","path":"css/images/bitcoin.svg","modified":false},{"_id":"themes/bitcore/source/css/images/shadow-lava-ball.svg","path":"css/images/shadow-lava-ball.svg","modified":false},{"_id":"themes/bitcore/source/fonts/ubuntu-bold-italic.woff","path":"fonts/ubuntu-bold-italic.woff","modified":false},{"_id":"themes/bitcore/source/fonts/ubuntu-bold.woff","path":"fonts/ubuntu-bold.woff","modified":false},{"_id":"themes/bitcore/source/fonts/ubuntu-light.woff","path":"fonts/ubuntu-light.woff","modified":false},{"_id":"themes/bitcore/source/fonts/ubuntu.woff","path":"fonts/ubuntu.woff","modified":false},{"_id":"source/CNAME","path":"CNAME","modified":false},{"_id":"source/apple-touch-icon-precomposed.png","path":"apple-touch-icon-precomposed.png","modified":false},{"_id":"source/robots.txt","path":"robots.txt","modified":false},{"_id":"themes/bitcore/source/css/images/terminal-bg.svg","path":"css/images/terminal-bg.svg","modified":false},{"_id":"themes/bitcore/source/css/images/nodejs-icon.svg","path":"css/images/nodejs-icon.svg","modified":false},{"_id":"themes/bitcore/source/css/images/browser-icon.svg","path":"css/images/browser-icon.svg","modified":false},{"_id":"themes/bitcore/source/css/images/doc-illustration.png","path":"css/images/doc-illustration.png","modified":false},{"_id":"themes/bitcore/source/css/images/api-illustration.png","path":"css/images/api-illustration.png","modified":false},{"_id":"themes/bitcore/source/css/images/doc-icon.svg","path":"css/images/doc-icon.svg","modified":false},{"_id":"themes/bitcore/source/css/images/api-icon.svg","path":"css/images/api-icon.svg","modified":false},{"_id":"source/favicon-32x32.png","path":"favicon-32x32.png","modified":false},{"_id":"source/favicon.ico","path":"favicon.ico","modified":false},{"_id":"source/apple-touch-icon-114x114.png","path":"apple-touch-icon-114x114.png","modified":false},{"_id":"source/apple-touch-icon-152x152.png","path":"apple-touch-icon-152x152.png","modified":false},{"_id":"source/apple-touch-icon-120x120.png","path":"apple-touch-icon-120x120.png","modified":false},{"_id":"source/apple-touch-icon-144x144.png","path":"apple-touch-icon-144x144.png","modified":false},{"_id":"source/apple-touch-icon-60x60.png","path":"apple-touch-icon-60x60.png","modified":false},{"_id":"source/apple-touch-icon-57x57.png","path":"apple-touch-icon-57x57.png","modified":false},{"_id":"source/apple-touch-icon-72x72.png","path":"apple-touch-icon-72x72.png","modified":false},{"_id":"source/apple-touch-icon-76x76.png","path":"apple-touch-icon-76x76.png","modified":false},{"_id":"source/favicon-160x160.png","path":"favicon-160x160.png","modified":false},{"_id":"source/favicon-196x196.png","path":"favicon-196x196.png","modified":false},{"_id":"source/favicon-96x96.png","path":"favicon-96x96.png","modified":false}],"Cache":[{"_id":"scaffolds/draft.md","mtime":1419181889000},{"_id":"scaffolds/photo.md","mtime":1419181889000},{"_id":"scaffolds/page.md","mtime":1419181889000},{"_id":"scaffolds/post.md","mtime":1419181889000},{"_id":"themes/hexo3/_config.yml","mtime":1418924350000},{"_id":"themes/hexo3/layout/archive.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/index.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/layout.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/page.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/post.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/_partial/after-footer.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/_partial/article.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/_partial/comment.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/_partial/footer.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/_partial/google-analytics.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/_partial/head.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/_partial/header.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/_partial/news-banner.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/_partial/share.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/_partial/sidebar.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/_partial/post/date.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/_partial/post/share.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/_partial/post/title.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/api/class.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/api/layout.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/api/module.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/api/_partial/classitem.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/api/_partial/deprecated.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/api/_partial/options.ejs","mtime":1418924350000},{"_id":"themes/hexo3/layout/api/_partial/sidebar.ejs","mtime":1418924350000},{"_id":"themes/hexo3/source/js/retina.min.js","mtime":1418924350000},{"_id":"themes/hexo3/source/js/script.js","mtime":1418924350000},{"_id":"themes/hexo3/source/css/_variables.styl","mtime":1418924350000},{"_id":"themes/hexo3/source/css/style.styl","mtime":1418924350000},{"_id":"themes/hexo3/source/css/_partial/api.styl","mtime":1418924350000},{"_id":"themes/hexo3/source/css/_partial/footer.styl","mtime":1418924350000},{"_id":"themes/hexo3/source/css/_partial/header.styl","mtime":1418924350000},{"_id":"themes/hexo3/source/css/_partial/highlight.styl","mtime":1418924350000},{"_id":"themes/hexo3/source/css/_partial/index.styl","mtime":1418924350000},{"_id":"themes/hexo3/source/css/_partial/news.styl","mtime":1418924350000},{"_id":"themes/hexo3/source/css/_partial/page.styl","mtime":1418924350000},{"_id":"themes/hexo3/source/css/_partial/sidebar.styl","mtime":1418924350000},{"_id":"themes/hexo3/source/css/_util/grid.styl","mtime":1418924350000},{"_id":"themes/hexo3/source/css/_util/mixin.styl","mtime":1418924350000},{"_id":"themes/hexo3/source/css/fonts/icomoon.eot","mtime":1418924350000},{"_id":"themes/hexo3/source/css/fonts/icomoon.svg","mtime":1418924350000},{"_id":"themes/hexo3/source/css/fonts/icomoon.ttf","mtime":1418924350000},{"_id":"themes/hexo3/source/css/fonts/icomoon.woff","mtime":1418924350000},{"_id":"themes/hexo3/source/css/images/logo.png","mtime":1418924350000},{"_id":"themes/hexo3/source/css/images/logo@2x.png","mtime":1418924350000},{"_id":"themes/hexo3/source/css/images/shattered.png","mtime":1418924350000},{"_id":"themes/hexo3/source/css/images/shattered@2x.png","mtime":1418924350000},{"_id":"themes/bitcore/_config.yml","mtime":1419181889000},{"_id":"themes/bitcore/layout/archive.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/index.ejs","mtime":1419284934000},{"_id":"themes/bitcore/layout/page.ejs","mtime":1419284934000},{"_id":"themes/bitcore/layout/layout.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/post.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/_partial/after-footer.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/_partial/article.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/_partial/comment.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/_partial/footer.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/_partial/google-analytics.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/_partial/head.ejs","mtime":1419284934000},{"_id":"themes/bitcore/layout/_partial/header.ejs","mtime":1419284934000},{"_id":"themes/bitcore/layout/_partial/news-banner.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/_partial/share.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/_partial/sidebar.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/_partial/post/date.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/_partial/post/share.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/_partial/post/title.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/api/class.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/api/layout.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/api/module.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/api/_partial/classitem.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/api/_partial/deprecated.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/api/_partial/options.ejs","mtime":1419181889000},{"_id":"themes/bitcore/layout/api/_partial/sidebar.ejs","mtime":1419181889000},{"_id":"themes/bitcore/source/js/retina.min.js","mtime":1419181889000},{"_id":"themes/bitcore/source/js/script.js","mtime":1419181889000},{"_id":"themes/bitcore/source/css/_variables.styl","mtime":1419284934000},{"_id":"themes/bitcore/source/css/style.styl","mtime":1419284934000},{"_id":"themes/bitcore/source/css/_partial/api.styl","mtime":1419181889000},{"_id":"themes/bitcore/source/css/_partial/footer.styl","mtime":1419181889000},{"_id":"themes/bitcore/source/css/_partial/header.styl","mtime":1419284934000},{"_id":"themes/bitcore/source/css/_partial/highlight.styl","mtime":1419181889000},{"_id":"themes/bitcore/source/css/_partial/index.styl","mtime":1419284934000},{"_id":"themes/bitcore/source/css/_partial/news.styl","mtime":1419181889000},{"_id":"themes/bitcore/source/css/_partial/page.styl","mtime":1419284934000},{"_id":"themes/bitcore/source/css/_partial/sidebar.styl","mtime":1419181889000},{"_id":"themes/bitcore/source/css/_util/grid.styl","mtime":1419181889000},{"_id":"themes/bitcore/source/css/_util/mixin.styl","mtime":1419181889000},{"_id":"themes/bitcore/source/css/fonts/icomoon.eot","mtime":1419181889000},{"_id":"themes/bitcore/source/css/fonts/icomoon.svg","mtime":1419181889000},{"_id":"themes/bitcore/source/css/fonts/icomoon.ttf","mtime":1419181889000},{"_id":"themes/bitcore/source/css/fonts/icomoon.woff","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/logo.png","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/logo@2x.png","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/volcano-ft.svg","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/cross-platform-illustration.png","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/bitpay-link.svg","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/functionality-illustration.png","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/keys-illustration.png","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/mount-bg-hd.svg","mtime":1419284934000},{"_id":"themes/bitcore/source/css/images/o-source-illustration.png","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/p-protocol-illustration.png","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/volcano-hd-texture.png","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/bitbox-link.svg","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/copay-link.svg","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/cp-link.svg","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/enbitcoins-link.svg","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/insight-link.svg","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/logo-invert.png","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/logo@2x-invert.png","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/paper-wallet-link.svg","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/streamium-link.svg","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/lava-ball.png","mtime":1419284934000},{"_id":"themes/bitcore/source/css/images/logo-invert@2x.png","mtime":1419181889000},{"_id":"themes/bitcore/source/css/animations.css","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/bitcoin.svg","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/shadow-lava-ball.svg","mtime":1419181889000},{"_id":"themes/bitcore/source/fonts/ubuntu-bold-italic.woff","mtime":1419181889000},{"_id":"themes/bitcore/source/fonts/ubuntu-bold.woff","mtime":1419181889000},{"_id":"themes/bitcore/source/fonts/ubuntu-light.woff","mtime":1419181889000},{"_id":"themes/bitcore/source/fonts/ubuntu.woff","mtime":1419181889000},{"_id":"source/CNAME","mtime":1419181889000},{"_id":"source/apple-touch-icon-precomposed.png","mtime":1419181889000},{"_id":"source/robots.txt","mtime":1419181889000},{"_id":"themes/bitcore/source/css/images/api-illustration.png","mtime":1419284934000},{"_id":"themes/bitcore/source/css/images/browser-icon.svg","mtime":1419284934000},{"_id":"themes/bitcore/source/css/images/doc-illustration.png","mtime":1419284934000},{"_id":"themes/bitcore/source/css/images/nodejs-icon.svg","mtime":1419284934000},{"_id":"themes/bitcore/source/css/images/terminal-bg.svg","mtime":1419284934000},{"_id":"themes/bitcore/source/css/images/doc-icon.svg","mtime":1419284934000},{"_id":"themes/bitcore/source/css/images/api-icon.svg","mtime":1419284934000},{"_id":"source/favicon-32x32.png","mtime":1419284934000},{"_id":"source/favicon.ico","mtime":1419284934000},{"_id":"source/apple-touch-icon-114x114.png","mtime":1419284934000},{"_id":"source/apple-touch-icon-120x120.png","mtime":1419284934000},{"_id":"source/apple-touch-icon-144x144.png","mtime":1419284934000},{"_id":"source/apple-touch-icon-152x152.png","mtime":1419284934000},{"_id":"source/apple-touch-icon-57x57.png","mtime":1419284934000},{"_id":"source/apple-touch-icon-60x60.png","mtime":1419284934000},{"_id":"source/apple-touch-icon-76x76.png","mtime":1419284934000},{"_id":"source/apple-touch-icon-72x72.png","mtime":1419284934000},{"_id":"source/favicon-160x160.png","mtime":1419284934000},{"_id":"source/favicon-196x196.png","mtime":1419284934000},{"_id":"source/favicon-96x96.png","mtime":1419284934000},{"_id":"source/guide/address.md","mtime":1419285018000},{"_id":"source/guide/block.md","mtime":1419285018000},{"_id":"source/guide/contributing.md","mtime":1419285023000},{"_id":"source/guide/crypto.md","mtime":1419285018000},{"_id":"source/guide/ecies.md","mtime":1419285018000},{"_id":"source/guide/encoding.md","mtime":1419285018000},{"_id":"source/guide/hierarchical.md","mtime":1419285018000},{"_id":"source/guide/index.md","mtime":1419285023000},{"_id":"source/guide/jsonrpc.md","mtime":1419285018000},{"_id":"source/guide/networks.md","mtime":1419285019000},{"_id":"source/guide/paymentprotocol.md","mtime":1419285019000},{"_id":"source/guide/peer.md","mtime":1419285019000},{"_id":"source/guide/pool.md","mtime":1419285019000},{"_id":"source/guide/privatekey.md","mtime":1419285020000},{"_id":"source/guide/publickey.md","mtime":1419285020000},{"_id":"source/guide/script.md","mtime":1419285020000},{"_id":"source/guide/transaction.md","mtime":1419285021000},{"_id":"source/guide/unit.md","mtime":1419285021000},{"_id":"source/guide/uri.md","mtime":1419285021000},{"_id":"source/api/address.md","mtime":1419285021000},{"_id":"source/api/block.md","mtime":1419285021000},{"_id":"source/api/blockheader.md","mtime":1419285022000},{"_id":"source/api/hdkeycache.md","mtime":1419285018000},{"_id":"source/api/hdprivatekey.md","mtime":1419285022000},{"_id":"source/api/hdpublickey.md","mtime":1419285022000},{"_id":"source/api/index.md","mtime":1419285024000},{"_id":"source/api/networks.md","mtime":1419285021000},{"_id":"source/api/opcode.md","mtime":1419285018000},{"_id":"source/api/privatekey.md","mtime":1419285022000},{"_id":"source/api/publickey.md","mtime":1419285022000},{"_id":"source/api/unit.md","mtime":1419285022000},{"_id":"source/api/uri.md","mtime":1419285022000},{"_id":"source/api/crypto/bn.md","mtime":1419285018000},{"_id":"source/api/crypto/ecdsa.md","mtime":1419285018000},{"_id":"source/api/crypto/hash.md","mtime":1419285019000},{"_id":"source/api/crypto/point.md","mtime":1419285022000},{"_id":"source/api/crypto/random.md","mtime":1419285019000},{"_id":"source/api/crypto/signature.md","mtime":1419285019000},{"_id":"source/api/encoding/base58.md","mtime":1419285019000},{"_id":"source/api/encoding/base58check.md","mtime":1419285020000},{"_id":"source/api/encoding/bufferreader.md","mtime":1419285020000},{"_id":"source/api/encoding/bufferwriter.md","mtime":1419285020000},{"_id":"source/api/encoding/varint.md","mtime":1419285020000},{"_id":"source/api/errors/build.md","mtime":1419285019000},{"_id":"source/api/errors/index.md","mtime":1419285019000},{"_id":"source/api/errors/spec.md","mtime":1419285019000},{"_id":"source/api/paymentprotocol/browser.md","mtime":1419285020000},{"_id":"source/api/paymentprotocol/common.md","mtime":1419285021000},{"_id":"source/api/paymentprotocol/index.md","mtime":1419285021000},{"_id":"source/api/paymentprotocol/node.md","mtime":1419285021000},{"_id":"source/api/paymentprotocol/rootcerts.md","mtime":1419285021000},{"_id":"source/api/script/index.md","mtime":1419285022000},{"_id":"source/api/script/interpreter.md","mtime":1419285026000},{"_id":"source/api/script/script.md","mtime":1419285026000},{"_id":"source/api/transport/index.md","mtime":1419285026000},{"_id":"source/api/transport/messages.md","mtime":1419285022000},{"_id":"source/api/transport/peer.md","mtime":1419285026000},{"_id":"source/api/transport/pool.md","mtime":1419285026000},{"_id":"source/api/transport/rpc.md","mtime":1419285026000},{"_id":"source/api/util/js.md","mtime":1419285026000},{"_id":"source/api/util/preconditions.md","mtime":1419285023000},{"_id":"source/api/util/buffer.md","mtime":1419285023000},{"_id":"source/api/transaction/index.md","mtime":1419285022000},{"_id":"source/api/transaction/output.md","mtime":1419285022000},{"_id":"source/api/transaction/sighash.md","mtime":1419285026000},{"_id":"source/api/transaction/transaction.md","mtime":1419285026000},{"_id":"source/api/transaction/input/index.md","mtime":1419285023000},{"_id":"source/api/transaction/input/input.md","mtime":1419285023000},{"_id":"source/api/transaction/input/multisigscripthash.md","mtime":1419285026000},{"_id":"source/api/transaction/input/publickeyhash.md","mtime":1419285026000}],"Category":[],"Page":[{"content":"<h1 id=\"Address\">Address</h1>\n<h2 id=\"Description\">Description</h2>\n<p>Represents a bitcoin Address. Addresses are the most popular way to make bitcoin transactions. See <a href=\"https://en.bitcoin.it/wiki/Address\" target=\"_blank\" rel=\"external\">the official Bitcoin Wiki</a> for technical background information.</p>\n<h2 id=\"Instantiate_an_Address\">Instantiate an Address</h2>\n<p>To be able to receive bitcoins an address is needed, but in order to spend them a private key is necessary. Please take a look at the <a href=\"privatekey.md\"><code>PrivateKey</code></a> docs for more information about exporting and saving a key.  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> privateKey = <span class=\"keyword\">new</span> PrivateKey();</div><div class=\"line\"><span class=\"keyword\">var</span> address = privateKey.toAddress();</div></pre></td></tr></table></figure>\n\n<p>You can also instantiate an Address from a String, <a href=\"publickey.md\">PublicKey</a>, or <a href=\"hierarchical.md\">HDPublicKey</a>, in case you are not the owner of the private key.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// from a string</span></div><div class=\"line\"><span class=\"keyword\">var</span> address = Address.fromString(<span class=\"string\">'mwkXG8NnB2snbqWTcpNiK6qqGHm1LebHDc'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// a default network address from a public key</span></div><div class=\"line\"><span class=\"keyword\">var</span> publicKey = PublicKey(privateKey);</div><div class=\"line\"><span class=\"keyword\">var</span> address = <span class=\"keyword\">new</span> Address(publicKey);</div><div class=\"line\"><span class=\"comment\">// alternative interface</span></div><div class=\"line\"><span class=\"keyword\">var</span> address = Address.fromPublicKey(publicKey);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// a testnet address from a public key</span></div><div class=\"line\"><span class=\"keyword\">var</span> publicKey = <span class=\"keyword\">new</span> PublicKey(privateKey);</div><div class=\"line\"><span class=\"keyword\">var</span> address = <span class=\"keyword\">new</span> Address(publicKey, Networks.testnet);</div></pre></td></tr></table></figure>\n\n<h2 id=\"Validating_an_Address\">Validating an Address</h2>\n<p>The main use that we expect you’ll have for the <code>Address</code> class in Bitcore is validating that an address is a valid one, what type of address it is (you may be interested on knowing if the address is a simple “pay to public key hash” address or a “pay to script hash” address) and what network does the address belong to.</p>\n<p>The code to do these validations looks like this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// validate an address</span></div><div class=\"line\"><span class=\"keyword\">if</span> (Address.isValid(input){</div><div class=\"line\">  ...</div><div class=\"line\">}</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// validate that an input field is a valid testnet address</span></div><div class=\"line\"><span class=\"keyword\">if</span> (Address.isValid(input, Networks.testnet){</div><div class=\"line\">  ...</div><div class=\"line\">}</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// validate that an input field is a valid livenet pubkeyhash</span></div><div class=\"line\"><span class=\"keyword\">if</span> (Address.isValid(input, Networks.livenet, Address.Pay2PubKeyHash){</div><div class=\"line\">  ...</div><div class=\"line\">}</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// get the specific validation error that can occurred</span></div><div class=\"line\"><span class=\"keyword\">var</span> error = Address.getValidationError(input, Networks.testnet);</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) {</div><div class=\"line\">    <span class=\"comment\">// handle the error</span></div><div class=\"line\">  }</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>The errors are listed in the generated file in the <a href=\"https://github.com/bitpay/bitcore/tree/master/lib/errors\" target=\"_blank\" rel=\"external\">errors folder</a>. There’s a structure to errors defined in the <a href=\"https://github.com/bitpay/bitcore/tree/master/lib/errors/spec.js\" target=\"_blank\" rel=\"external\">spec.js file</a>.</p>\n","source":"guide/address.md","raw":"# Address\n\n## Description\n\nRepresents a bitcoin Address. Addresses are the most popular way to make bitcoin transactions. See [the official Bitcoin Wiki](https://en.bitcoin.it/wiki/Address) for technical background information.\n\n## Instantiate an Address\n\nTo be able to receive bitcoins an address is needed, but in order to spend them a private key is necessary. Please take a look at the [`PrivateKey`](privatekey.md) docs for more information about exporting and saving a key.  \n\n```javascript\nvar privateKey = new PrivateKey();\nvar address = privateKey.toAddress();\n```\n\nYou can also instantiate an Address from a String, [PublicKey](publickey.md), or [HDPublicKey](hierarchical.md), in case you are not the owner of the private key.\n\n```javascript\n// from a string\nvar address = Address.fromString('mwkXG8NnB2snbqWTcpNiK6qqGHm1LebHDc');\n\n// a default network address from a public key\nvar publicKey = PublicKey(privateKey);\nvar address = new Address(publicKey);\n// alternative interface\nvar address = Address.fromPublicKey(publicKey);\n\n// a testnet address from a public key\nvar publicKey = new PublicKey(privateKey);\nvar address = new Address(publicKey, Networks.testnet);\n```\n\n## Validating an Address\n\nThe main use that we expect you'll have for the `Address` class in Bitcore is validating that an address is a valid one, what type of address it is (you may be interested on knowing if the address is a simple \"pay to public key hash\" address or a \"pay to script hash\" address) and what network does the address belong to.\n\nThe code to do these validations looks like this:\n\n```javascript\n// validate an address\nif (Address.isValid(input){\n  ...\n}\n\n// validate that an input field is a valid testnet address\nif (Address.isValid(input, Networks.testnet){\n  ...\n}\n\n// validate that an input field is a valid livenet pubkeyhash\nif (Address.isValid(input, Networks.livenet, Address.Pay2PubKeyHash){\n  ...\n}\n\n// get the specific validation error that can occurred\nvar error = Address.getValidationError(input, Networks.testnet);\n  if (error) {\n    // handle the error\n  }\n}\n```\n\nThe errors are listed in the generated file in the [errors folder](https://github.com/bitpay/bitcore/tree/master/lib/errors). There's a structure to errors defined in the [spec.js file](https://github.com/bitpay/bitcore/tree/master/lib/errors/spec.js).\n","date":1419285018000,"updated":1419285018000,"path":"guide/address.html","excerpt":"","_id":"wqf6tjhb5krtr134","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"Block\">Block</h1>\n<h2 id=\"Description\">Description</h2>\n<p>A Block instance represents the information of a block in the bitcoin network. Given a hexa or base64 string representation of the serialization of a block with its transactions, you can instantiate a Block instance. Methods are provided to calculate and check the merkle root hash (if enough data is provided), but transactions won’t necessarily be valid spends, and this class won’t validate them. A binary representation as a <code>Buffer</code> instance is also valid input for a Block’s constructor. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// instantiate a new block instance</span></div><div class=\"line\"><span class=\"keyword\">var</span> block = <span class=\"keyword\">new</span> Block(hexaEncodedBlock);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// will verify that the correspending block transactions match the header</span></div><div class=\"line\">assert(block.validMerkleRoot());</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// blocks have several properties</span></div><div class=\"line\">assert(block.magicnum);</div><div class=\"line\">assert(block.size);</div><div class=\"line\">assert(block.header); <span class=\"comment\">// an instance of block header, more info below</span></div><div class=\"line\">assert(block.txs); <span class=\"comment\">// an array of transactions, more info below</span></div></pre></td></tr></table></figure>\n\n<p>For detailed technical information about a block please visit <a href=\"https://en.bitcoin.it/wiki/Blocks#Block_structure\" target=\"_blank\" rel=\"external\">Blocks</a> on the Bitcoin Wiki.</p>\n<h2 id=\"Block_Header\">Block Header</h2>\n<p>Each instance of Block has a BlockHeader <em>(which can be instantiated seperately)</em>. The header has validation methods, to verify that the block.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// will verify that the nonce demonstrates enough proof of work</span></div><div class=\"line\">assert(block.header.validProofOfWork());</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// will verify that timestamp is not too far in the future</span></div><div class=\"line\">assert(block.header.validTimestamp());</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// each header has the following properties</span></div><div class=\"line\">assert(block.header.version);</div><div class=\"line\">assert(block.header.prevHash);</div><div class=\"line\">assert(block.header.merkleRoot);</div><div class=\"line\">assert(block.header.time);</div><div class=\"line\">assert(block.header.bits);</div><div class=\"line\">assert(block.header.nonce);</div></pre></td></tr></table></figure>\n\n<p>For more information about the specific properties of a block header please visit the <a href=\"https://en.bitcoin.it/wiki/Block_hashing_algorithm\" target=\"_blank\" rel=\"external\">Block hashing algorithm</a> page on the Bitcoin Wiki.</p>\n<h2 id=\"Transactions\">Transactions</h2>\n<p>The set of transactions in a block is an array of instances of <a href=\"transaction.md\">Transaction</a> and can be explored by iterating on the block’s <code>transactions</code> member.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> block.txs) {</div><div class=\"line\">  <span class=\"keyword\">var</span> transaction = block.txs[i];</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n","source":"guide/block.md","raw":"# Block\n\n## Description\n\nA Block instance represents the information of a block in the bitcoin network. Given a hexa or base64 string representation of the serialization of a block with its transactions, you can instantiate a Block instance. Methods are provided to calculate and check the merkle root hash (if enough data is provided), but transactions won't necessarily be valid spends, and this class won't validate them. A binary representation as a `Buffer` instance is also valid input for a Block's constructor. \n\n```javascript\n\n// instantiate a new block instance\nvar block = new Block(hexaEncodedBlock);\n\n// will verify that the correspending block transactions match the header\nassert(block.validMerkleRoot());\n\n// blocks have several properties\nassert(block.magicnum);\nassert(block.size);\nassert(block.header); // an instance of block header, more info below\nassert(block.txs); // an array of transactions, more info below\n\n```\n\nFor detailed technical information about a block please visit [Blocks](https://en.bitcoin.it/wiki/Blocks#Block_structure) on the Bitcoin Wiki.\n\n## Block Header\n\nEach instance of Block has a BlockHeader *(which can be instantiated seperately)*. The header has validation methods, to verify that the block.\n\n```javascript\n\n// will verify that the nonce demonstrates enough proof of work\nassert(block.header.validProofOfWork());\n\n// will verify that timestamp is not too far in the future\nassert(block.header.validTimestamp());\n\n// each header has the following properties\nassert(block.header.version);\nassert(block.header.prevHash);\nassert(block.header.merkleRoot);\nassert(block.header.time);\nassert(block.header.bits);\nassert(block.header.nonce);\n\n```\nFor more information about the specific properties of a block header please visit the [Block hashing algorithm](https://en.bitcoin.it/wiki/Block_hashing_algorithm) page on the Bitcoin Wiki.\n\n## Transactions\n\nThe set of transactions in a block is an array of instances of [Transaction](transaction.md) and can be explored by iterating on the block's `transactions` member.\n\n```javascript\nfor (var i in block.txs) {\n  var transaction = block.txs[i];\n}\n```\n\n","date":1419285018000,"updated":1419285018000,"path":"guide/block.html","excerpt":"","_id":"v2pz1i9wkvdpudnv","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"Contributing_to_Bitcore\">Contributing to Bitcore</h1>\n<p>We’re working hard to make <em>bitcore</em> the most powerful JavaScript library for working with bitcoin. Our goal is to have <em>bitcore</em> be a library that can be used by anyone interested in bitcoin, and to level expertise differences with great design and documentation.</p>\n<h2 id=\"Quick_Checklist\">Quick Checklist</h2>\n<p>Make sure:</p>\n<ul>\n<li><code>gulp lint</code> doesn’t complain about your changes</li>\n<li><code>gulp test</code> passes all the tests</li>\n<li><code>gulp coverage</code> covers 100% of the branches of your code</li>\n</ul>\n<h2 id=\"Design_Guidelines\">Design Guidelines</h2>\n<p>These are some global design goals in bitcore that any change must adhere.</p>\n<h3 id=\"D1_-_Naming_Matters\">D1 - Naming Matters</h3>\n<p>We take our time with picking names. Code is going to be written once, and read hundreds of times.</p>\n<p>We were inspired to name this rule first due to Uncle Bob’s great work <em>Clean Code</em>, which has a whole chapter on this subject.</p>\n<p>In particular, you may notice that some names in this library are quite long for the average JavaScript user. That’s because we prefer a long but comprehensible name than an abbreviation that might confuse new users.</p>\n<h3 id=\"D2_-_Tests\">D2 - Tests</h3>\n<p>Write a test for all your code. We encourage Test Driven Development so we know when our code is right. We have increased test coverage from 80% to around 95% and are targeting 100% as we move towards our 1.0 release.</p>\n<h3 id=\"D3_-_Robustness_Principle\">D3 - Robustness Principle</h3>\n<p><em>Be conservative in what you send, be liberal in what you accept.</em></p>\n<p>Interfaces should accept as many types of arguments as possible, so there’s no mental tax on using them: we want to avoid questions such as “should I use a string here or a buffer?”, “what happens if I’m not sure if the type of this variable is an Address instance or a string with it encoded in base-58?” or “what kind of object will I receive after calling this function?”.</p>\n<p>Accept a wide variety of use cases and arguments, always return an internal form of an object. For example, the class <code>PublicKey</code> can accept strings or buffers with a DER encoded public key (either compressed or uncompressed), another PublicKey, a PrivateKey, or a Point, an instance of the <code>elliptic.js</code> library with the point in bitcoin’s elliptic curve that represents the public key.</p>\n<h3 id=\"D4_-_Consistency_Everywhere\">D4 - Consistency Everywhere</h3>\n<p>Consistency on the way classes are used is paramount to allow an easier understanding of the library.</p>\n<h2 id=\"Style_Guidelines\">Style Guidelines</h2>\n<p>The design guidelines have quite a high abstraction level. These style guidelines are more concrete and easier to apply, and also more opinionated. The design guidelines mentioned above are the way we think about general software development and we believe they should be present in any software project.</p>\n<h3 id=\"G0_-_General:_Default_to_Felixge’s_Style_Guide\">G0 - General: Default to Felixge’s Style Guide</h3>\n<p>Follow this Node.js Style Guide: <a href=\"https://github.com/felixge/node-style-guide#nodejs-style-guide\" target=\"_blank\" rel=\"external\">https://github.com/felixge/node-style-guide#nodejs-style-guide</a></p>\n<h3 id=\"G1_-_General:_No_Magic_Numbers\">G1 - General: No Magic Numbers</h3>\n<p>Avoid constants in the code as much as possible. Magic strings are also magic numbers.</p>\n<h3 id=\"G2_-_General:_Internal_Objects_should_be_Instances\">G2 - General: Internal Objects should be Instances</h3>\n<p>If a class has a <code>publicKey</code> member, for instance, that should be a <code>PublicKey</code> instance.</p>\n<h3 id=\"G3_-_General:_Internal_amounts_must_be_integers_representing_Satoshis\">G3 - General: Internal amounts must be integers representing Satoshis</h3>\n<p>Avoid representation errors by always dealing with satoshis. For conversion for frontends, use the <code>Unit</code> class.</p>\n<h3 id=\"G4_-_General:_Internal_network_references_must_be_Network_instances\">G4 - General: Internal network references must be Network instances</h3>\n<p>A special case for <a href=\"#g2---general-internal-objects-should-be-instances\">G2</a> all network references must be <code>Network</code> instances (see <code>lib/network.js</code>), but when returned to the user, its <code>.name</code> property should be used.</p>\n<h3 id=\"G5_-_General:_Objects_should_display_nicely_in_the_console\">G5 - General: Objects should display nicely in the console</h3>\n<p>Write a <code>.inspect()</code> method so an instance can be easily debugged in the console.</p>\n<h3 id=\"G6_-_General:_Naming_Utility_Namespaces\">G6 - General: Naming Utility Namespaces</h3>\n<p>Name them in CamelCase, as they are namespaces.</p>\n<p>DO:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> BufferUtil = <span class=\"built_in\">require</span>(<span class=\"string\">'./util/buffer'</span>);</div></pre></td></tr></table></figure>\n\n<p>DON’T:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> bufferUtil = <span class=\"built_in\">require</span>(<span class=\"string\">'./util/buffer'</span>);</div></pre></td></tr></table></figure>\n\n<h3 id=\"G7_-_General:_Standard_Methods\">G7 - General: Standard Methods</h3>\n<p>When possible, bitcore objects should have standard methods on an instance prototype:</p>\n<ul>\n<li><code>toObject</code> - A plain JavaScript object that can be JSON stringified</li>\n<li><code>toJSON</code> - A JSON stringified object of the instance</li>\n<li><code>toString</code> - A string representation of the instance</li>\n<li><code>toBuffer</code> - A hex Buffer</li>\n</ul>\n<p>These should have a matching static method that can be used for instantiation:</p>\n<ul>\n<li><code>fromJSON</code> - Should handle both JSON from <code>toJSON</code> and plain JavaScript object from <code>toObject</code></li>\n<li><code>fromString</code> - Should be able to instantiate with output from <code>toString</code></li>\n<li><code>fromBuffer</code> - Should likewise be able to instantiate from output from <code>toBuffer</code></li>\n</ul>\n<h3 id=\"E1_-_Errors:_Use_bitcore-Errors\">E1 - Errors: Use bitcore.Errors</h3>\n<p>We’ve designed a structure for Errors to follow and are slowly migrating to it.</p>\n<p>Usage:</p>\n<ul>\n<li>Errors are generated in the file <code>lib/errors/index.js</code> by invoking <code>gulp errors</code>.</li>\n<li>The specification for errors is written in the <code>lib/errors/spec.js</code> file.</li>\n<li>Whenever a new class is created, add a generic error for that class in <code>lib/errors/spec.js</code>.</li>\n<li>Specific errors for that class should subclass that error. Take a look at the structure in <code>lib/errors/spec.js</code>, it should be clear how subclasses are generated from that file.</li>\n</ul>\n<h3 id=\"E2_-_Errors:_Provide_a_getValidationError_static_method_for_classes\">E2 - Errors: Provide a <code>getValidationError</code> static method for classes</h3>\n<h3 id=\"I1_-_Interface:_Make_Code_that_Fails_Early\">I1 - Interface: Make Code that Fails Early</h3>\n<p>In order to deal with JavaScript’s weak typing and confusing errors, we ask our code to fail as soon as possible when an unexpected input was provided.</p>\n<p>There’s a module called <code>util/preconditions</code>, loosely based on <code>preconditions.js</code>, based on <code>guava</code>, that we use for state and argument checking. It should be trivial to use. We recommend using it on all methods, in order to improve robustness and consistency.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.checkState(something === anotherthing, <span class=\"string\">'Expected something to be anotherthing'</span>);</div><div class=\"line\">$.checkArgument(something &lt; <span class=\"number\">100</span>, <span class=\"string\">'something'</span>, <span class=\"string\">'must be less than 100'</span>);</div><div class=\"line\">$.checkArgumentType(something, PrivateKey, <span class=\"string\">'something'</span>); <span class=\"comment\">// The third argument is a helper to mention the name of the argument</span></div><div class=\"line\">$.checkArgumentType(something, PrivateKey); <span class=\"comment\">// but it's optional (will show up as \"(unknown argument)\")</span></div></pre></td></tr></table></figure>\n\n<h3 id=\"I2_-_Interface:_Permissive_Constructors\">I2 - Interface: Permissive Constructors</h3>\n<p>Most classes have static methods named <code>fromBuffer</code>, <code>fromString</code>, <code>fromJSON</code>. Whenever one of those methods is provided, the constructor for that class should also be able to detect the type of the arguments and call the appropriate method.</p>\n<h3 id=\"I3_-_Interface:_Method_Chaining\">I3 - Interface: Method Chaining</h3>\n<p>For classes that have a mutable state, most of the methods that can be chained <em>SHOULD</em> be chained, allowing for interfaces that read well, like:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> transaction = <span class=\"keyword\">new</span> Transaction()</div><div class=\"line\">    .from(utxo)</div><div class=\"line\">    .to(address, amount)</div><div class=\"line\">    .change(address)</div><div class=\"line\">    .sign(privkey);</div></pre></td></tr></table></figure>\n\n<h3 id=\"I4_-_Interface:_Copy_Constructors\">I4 - Interface: Copy Constructors</h3>\n<p>Constructors, when provided an instance of the same class, should:</p>\n<ul>\n<li>Return the same object, if the instances of this class are immutable</li>\n<li>Return a deep copy of the object, if the instances are mutable</li>\n</ul>\n<p>Examples:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyMutableClass</span><span class=\"params\">(arg)</span> </span>{</div><div class=\"line\">  <span class=\"keyword\">if</span> (arg <span class=\"keyword\">instanceof</span> MyMutableClass) {</div><div class=\"line\">    <span class=\"keyword\">return</span> MyMutableClass._deepCopy(arg);</div><div class=\"line\">  }</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">}</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ImmutableClass</span><span class=\"params\">(arg)</span> </span>{</div><div class=\"line\">  <span class=\"keyword\">if</span> (arg <span class=\"keyword\">instanceof</span> ImmutableClass) {</div><div class=\"line\">    <span class=\"keyword\">return</span> arg;</div><div class=\"line\">  }</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<h3 id=\"I5_-_Interface:_No_new_keyword_for_Constructors\">I5 - Interface: No new keyword for Constructors</h3>\n<p>Constructors should not require to be called with <code>new</code>. This rule is not heavily enforced, but is a “nice to have”.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">NoNewRequired</span><span class=\"params\">(args)</span> </span>{</div><div class=\"line\">  <span class=\"keyword\">if</span> (!(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> NoNewRequired)) {</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NoNewRequired(args);</div><div class=\"line\">  }</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<h3 id=\"T1_-_Testing:_Tests_Must_be_Written_Elegantly\">T1 - Testing: Tests Must be Written Elegantly</h3>\n<p>Style guidelines are not relaxed for tests. Tests are a good way to show how to use the library, and maintaining them is extremely necessary.</p>\n<p>Don’t write long tests, write helper functions to make them be as short and concise as possible (they should take just a few lines each), and use good variable names.</p>\n<h3 id=\"T2_-_Testing:_Tests_Must_not_be_Random\">T2 - Testing: Tests Must not be Random</h3>\n<p>Inputs for tests should not be generated randomly. Also, the type and structure of outputs should be checked.</p>\n<h3 id=\"T3_-_Testing:_Require_‘bitcore’_and_look_up_classes_from_there\">T3 - Testing: Require ‘bitcore’ and look up classes from there</h3>\n<p>This helps to make tests more useful as examples, and more independent of where they are placed. This also helps prevent forgetting to include all submodules in the bitcore object.</p>\n<p>DO:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> bitcore = <span class=\"built_in\">require</span>(<span class=\"string\">'../'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> PublicKey = bitcore.PublicKey;</div></pre></td></tr></table></figure>\n\n<p>DON’T:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> PublicKey = <span class=\"built_in\">require</span>(<span class=\"string\">'../lib/publickey'</span>);</div></pre></td></tr></table></figure>\n\n<h2 id=\"Pull_Request_Workflow\">Pull Request Workflow</h2>\n<p>Our workflow is based on GitHub’s pull requests. We use feature branches, prepended with: <code>test</code>, <code>feature</code>, <code>fix</code>, <code>refactor</code>, or <code>remove</code> according to the change the branch introduces. Some examples for such branches are:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout -b test/some-module</div><div class=\"line\">git checkout -b feature/some-new-stuff</div><div class=\"line\">git checkout -b fix/some-bug</div><div class=\"line\">git checkout -b remove/some-file</div></pre></td></tr></table></figure>\n\n<p>We expect pull requests to be rebased to the master branch before merging:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git remote add bitpay git@github.com:bitpay/bitcore.git</div><div class=\"line\">git pull --rebase bitpay master</div></pre></td></tr></table></figure>\n\n<p>Note that we require rebasing your branch instead of merging it, for commit readability reasons.</p>\n<p>After that, you can push the changes to your fork, by doing:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git push origin your_branch_name</div><div class=\"line\">git push origin feature/some-new-stuff</div><div class=\"line\">git push origin fix/some-bug</div></pre></td></tr></table></figure>\n\n<p>Finally go to <a href=\"https://github.com/bitpay/bitcore\" target=\"_blank\" rel=\"external\">github.com/bitpay/bitcore</a> in your web browser and issue a new pull request.</p>\n<p>Main contributors will review your code and possibly ask for changes before your code is pulled in to the main repository.  We’ll check that all tests pass, review the coding style, and check for general code correctness. If everything is OK, we’ll merge your pull request and your code will be part of bitcore.</p>\n<p>If you have any questions feel free to post them to<br><a href=\"https://github.com/bitpay/bitcore/issues\" target=\"_blank\" rel=\"external\">github.com/bitpay/bitcore/issues</a>.</p>\n<p>Thanks for your time and code!</p>\n","source":"guide/contributing.md","raw":"Contributing to Bitcore\n=======\n\nWe're working hard to make *bitcore* the most powerful JavaScript library for working with bitcoin. Our goal is to have *bitcore* be a library that can be used by anyone interested in bitcoin, and to level expertise differences with great design and documentation.\n\n## Quick Checklist\n\nMake sure:\n\n* `gulp lint` doesn't complain about your changes\n* `gulp test` passes all the tests\n* `gulp coverage` covers 100% of the branches of your code\n\n## Design Guidelines\n\nThese are some global design goals in bitcore that any change must adhere.\n\n### D1 - Naming Matters\n\nWe take our time with picking names. Code is going to be written once, and read hundreds of times.\n\nWe were inspired to name this rule first due to Uncle Bob's great work *Clean Code*, which has a whole chapter on this subject.\n\nIn particular, you may notice that some names in this library are quite long for the average JavaScript user. That's because we prefer a long but comprehensible name than an abbreviation that might confuse new users.\n\n### D2 - Tests\n\nWrite a test for all your code. We encourage Test Driven Development so we know when our code is right. We have increased test coverage from 80% to around 95% and are targeting 100% as we move towards our 1.0 release.\n\n### D3 - Robustness Principle\n\n*Be conservative in what you send, be liberal in what you accept.*\n\nInterfaces should accept as many types of arguments as possible, so there's no mental tax on using them: we want to avoid questions such as \"should I use a string here or a buffer?\", \"what happens if I'm not sure if the type of this variable is an Address instance or a string with it encoded in base-58?\" or \"what kind of object will I receive after calling this function?\".\n\nAccept a wide variety of use cases and arguments, always return an internal form of an object. For example, the class `PublicKey` can accept strings or buffers with a DER encoded public key (either compressed or uncompressed), another PublicKey, a PrivateKey, or a Point, an instance of the `elliptic.js` library with the point in bitcoin's elliptic curve that represents the public key.\n\n### D4 - Consistency Everywhere\n\nConsistency on the way classes are used is paramount to allow an easier understanding of the library.\n\n## Style Guidelines\n\nThe design guidelines have quite a high abstraction level. These style guidelines are more concrete and easier to apply, and also more opinionated. The design guidelines mentioned above are the way we think about general software development and we believe they should be present in any software project.\n\n### G0 - General: Default to Felixge's Style Guide\n\nFollow this Node.js Style Guide: https://github.com/felixge/node-style-guide#nodejs-style-guide\n\n### G1 - General: No Magic Numbers\n\nAvoid constants in the code as much as possible. Magic strings are also magic numbers.\n\n### G2 - General: Internal Objects should be Instances\n\nIf a class has a `publicKey` member, for instance, that should be a `PublicKey` instance.\n\n### G3 - General: Internal amounts must be integers representing Satoshis\n\nAvoid representation errors by always dealing with satoshis. For conversion for frontends, use the `Unit` class.\n\n### G4 - General: Internal network references must be Network instances\n\nA special case for [G2](#g2---general-internal-objects-should-be-instances) all network references must be `Network` instances (see `lib/network.js`), but when returned to the user, its `.name` property should be used.\n\n### G5 - General: Objects should display nicely in the console\n\nWrite a `.inspect()` method so an instance can be easily debugged in the console.\n\n### G6 - General: Naming Utility Namespaces\n\nName them in CamelCase, as they are namespaces.\n\nDO:\n```javascript\nvar BufferUtil = require('./util/buffer');\n```\nDON'T:\n```javascript\nvar bufferUtil = require('./util/buffer');\n```\n\n### G7 - General: Standard Methods\n\nWhen possible, bitcore objects should have standard methods on an instance prototype:\n* `toObject` - A plain JavaScript object that can be JSON stringified\n* `toJSON` - A JSON stringified object of the instance\n* `toString` - A string representation of the instance\n* `toBuffer` - A hex Buffer\n\nThese should have a matching static method that can be used for instantiation:\n* `fromJSON` - Should handle both JSON from `toJSON` and plain JavaScript object from `toObject`\n* `fromString` - Should be able to instantiate with output from `toString`\n* `fromBuffer` - Should likewise be able to instantiate from output from `toBuffer`\n\n### E1 - Errors: Use bitcore.Errors\n\nWe've designed a structure for Errors to follow and are slowly migrating to it.\n\nUsage:\n* Errors are generated in the file `lib/errors/index.js` by invoking `gulp errors`.\n* The specification for errors is written in the `lib/errors/spec.js` file.\n* Whenever a new class is created, add a generic error for that class in `lib/errors/spec.js`.\n* Specific errors for that class should subclass that error. Take a look at the structure in `lib/errors/spec.js`, it should be clear how subclasses are generated from that file.\n\n### E2 - Errors: Provide a `getValidationError` static method for classes\n\n### I1 - Interface: Make Code that Fails Early\n\nIn order to deal with JavaScript's weak typing and confusing errors, we ask our code to fail as soon as possible when an unexpected input was provided.\n\nThere's a module called `util/preconditions`, loosely based on `preconditions.js`, based on `guava`, that we use for state and argument checking. It should be trivial to use. We recommend using it on all methods, in order to improve robustness and consistency.\n\n```javascript\n$.checkState(something === anotherthing, 'Expected something to be anotherthing');\n$.checkArgument(something < 100, 'something', 'must be less than 100');\n$.checkArgumentType(something, PrivateKey, 'something'); // The third argument is a helper to mention the name of the argument\n$.checkArgumentType(something, PrivateKey); // but it's optional (will show up as \"(unknown argument)\")\n```\n\n### I2 - Interface: Permissive Constructors\n\nMost classes have static methods named `fromBuffer`, `fromString`, `fromJSON`. Whenever one of those methods is provided, the constructor for that class should also be able to detect the type of the arguments and call the appropriate method.\n\n### I3 - Interface: Method Chaining\n\nFor classes that have a mutable state, most of the methods that can be chained *SHOULD* be chained, allowing for interfaces that read well, like:\n\n```javascript\nvar transaction = new Transaction()\n    .from(utxo)\n    .to(address, amount)\n    .change(address)\n    .sign(privkey);\n```\n\n### I4 - Interface: Copy Constructors\n\nConstructors, when provided an instance of the same class, should:\n* Return the same object, if the instances of this class are immutable\n* Return a deep copy of the object, if the instances are mutable\n\nExamples:\n```javascript\nfunction MyMutableClass(arg) {\n  if (arg instanceof MyMutableClass) {\n    return MyMutableClass._deepCopy(arg);\n  }\n  // ...\n}\nfunction ImmutableClass(arg) {\n  if (arg instanceof ImmutableClass) {\n    return arg;\n  }\n  // ...\n}\n```\n\n### I5 - Interface: No new keyword for Constructors\n\nConstructors should not require to be called with `new`. This rule is not heavily enforced, but is a \"nice to have\".\n\n```javascript\nfunction NoNewRequired(args) {\n  if (!(this instanceof NoNewRequired)) {\n    return new NoNewRequired(args);\n  }\n  // ...\n}\n```\n\n### T1 - Testing: Tests Must be Written Elegantly\n\nStyle guidelines are not relaxed for tests. Tests are a good way to show how to use the library, and maintaining them is extremely necessary.\n\nDon't write long tests, write helper functions to make them be as short and concise as possible (they should take just a few lines each), and use good variable names.\n\n### T2 - Testing: Tests Must not be Random\n\nInputs for tests should not be generated randomly. Also, the type and structure of outputs should be checked.\n\n### T3 - Testing: Require 'bitcore' and look up classes from there\n\nThis helps to make tests more useful as examples, and more independent of where they are placed. This also helps prevent forgetting to include all submodules in the bitcore object.\n\nDO:\n```javascript\nvar bitcore = require('../');\nvar PublicKey = bitcore.PublicKey;\n```\nDON'T:\n```javascript\nvar PublicKey = require('../lib/publickey');\n```\n\n## Pull Request Workflow\n\nOur workflow is based on GitHub's pull requests. We use feature branches, prepended with: `test`, `feature`, `fix`, `refactor`, or `remove` according to the change the branch introduces. Some examples for such branches are:\n```sh\ngit checkout -b test/some-module\ngit checkout -b feature/some-new-stuff\ngit checkout -b fix/some-bug\ngit checkout -b remove/some-file\n```\n\nWe expect pull requests to be rebased to the master branch before merging:\n```sh\ngit remote add bitpay git@github.com:bitpay/bitcore.git\ngit pull --rebase bitpay master\n```\n\nNote that we require rebasing your branch instead of merging it, for commit readability reasons.\n\nAfter that, you can push the changes to your fork, by doing:\n```sh\ngit push origin your_branch_name\ngit push origin feature/some-new-stuff\ngit push origin fix/some-bug\n```\nFinally go to [github.com/bitpay/bitcore](https://github.com/bitpay/bitcore) in your web browser and issue a new pull request.\n\nMain contributors will review your code and possibly ask for changes before your code is pulled in to the main repository.  We'll check that all tests pass, review the coding style, and check for general code correctness. If everything is OK, we'll merge your pull request and your code will be part of bitcore.\n\nIf you have any questions feel free to post them to\n[github.com/bitpay/bitcore/issues](https://github.com/bitpay/bitcore/issues).\n\nThanks for your time and code!\n","date":1419285023000,"updated":1419285023000,"path":"guide/contributing.html","excerpt":"","_id":"o98wvz9m6as7ki49","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"Crypto\">Crypto</h1>\n<h2 id=\"Description\">Description</h2>\n<p>The cryptographic primitives (ECDSA and HMAC) implementations in this package have been reviewed by the BitPay engineering team. More audits and reviews are welcomed.</p>\n<h2 id=\"Random\">Random</h2>\n<p>The <code>bitcore.crypto.Random</code> namespace contains a single function, named <code>getRandomBuffer(size)</code> that returns a <code>Buffer</code> instance with random bytes. It may not work depending on the engine that bitcore is running on (doesn’t work with IE versions lesser than 11).</p>\n<h2 id=\"BN\">BN</h2>\n<p>The <code>bitcore.Crypto.BN</code> class contains a wrapper around <a href=\"https://github.com/indutny/bn.js\" target=\"_blank\" rel=\"external\">bn.js</a>, the bignum library used internally in bitcore.</p>\n<h2 id=\"Point\">Point</h2>\n<p>The <code>bitcore.Crypto.Point</code> class contains a wrapper around the class Point of <a href=\"https://github.com/indutny/elliptic\" target=\"_blank\" rel=\"external\">elliptic.js</a>, the elliptic curve library used internally in bitcore.</p>\n<h2 id=\"Hash\">Hash</h2>\n<p>The <code>bitcore.Crypto.Hash</code> namespace contains a set of hashes and utilities. These are either the native <code>crypto</code> hash functions from <code>node.js</code> or their respective browser shims as provided by the <code>browserify</code> library.</p>\n<h2 id=\"ECDSA\">ECDSA</h2>\n<p><code>bitcore.Crypto.ECDSA</code> contains a pure JavaScript implementation of the elliptic curve DSA signature scheme.</p>\n","source":"guide/crypto.md","raw":"# Crypto\n\n## Description\n\nThe cryptographic primitives (ECDSA and HMAC) implementations in this package have been reviewed by the BitPay engineering team. More audits and reviews are welcomed.\n\n## Random\n\nThe `bitcore.crypto.Random` namespace contains a single function, named `getRandomBuffer(size)` that returns a `Buffer` instance with random bytes. It may not work depending on the engine that bitcore is running on (doesn't work with IE versions lesser than 11).\n\n## BN\n\nThe `bitcore.Crypto.BN` class contains a wrapper around [bn.js](https://github.com/indutny/bn.js), the bignum library used internally in bitcore.\n\n## Point\n\nThe `bitcore.Crypto.Point` class contains a wrapper around the class Point of [elliptic.js](https://github.com/indutny/elliptic), the elliptic curve library used internally in bitcore.\n\n## Hash\n\nThe `bitcore.Crypto.Hash` namespace contains a set of hashes and utilities. These are either the native `crypto` hash functions from `node.js` or their respective browser shims as provided by the `browserify` library.\n\n## ECDSA\n\n`bitcore.Crypto.ECDSA` contains a pure JavaScript implementation of the elliptic curve DSA signature scheme.\n","date":1419285018000,"updated":1419285018000,"path":"guide/crypto.html","excerpt":"","_id":"wo6df878d0b7qten","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"ECIES\">ECIES</h1>\n<h2 id=\"Description\">Description</h2>\n<p>Bitcore implements <a href=\"http://en.wikipedia.org/wiki/Integrated_Encryption_Scheme\" target=\"_blank\" rel=\"external\">Elliptic Curve Integrated Encryption Scheme (ECIES)</a>, which is a public key encryption system that performs bulk encryption on data using a symmetric cipher and a random key.</p>\n<p>For more information refer to the <a href=\"https://github.com/bitpay/bitcore-ecies\" target=\"_blank\" rel=\"external\">bitcore-ecies</a> github repo.</p>\n<h2 id=\"Instalation\">Instalation</h2>\n<p>ECIES is implemented as a separate module and you must add it to your dependencies:</p>\n<p>For node projects:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm <span class=\"operator\"><span class=\"keyword\">install</span> bitcore-ecies <span class=\"comment\">--save</span></span></div></pre></td></tr></table></figure>\n\n<p>For client-side projects:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bower <span class=\"operator\"><span class=\"keyword\">install</span> bitcore-ecies <span class=\"comment\">--save</span></span></div></pre></td></tr></table></figure>\n\n<h2 id=\"Example\">Example</h2>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">var</span> bitcore <span class=\"subst\">=</span> <span class=\"keyword\">require</span>(<span class=\"string\">'bitcore'</span>);</div><div class=\"line\"><span class=\"built_in\">var</span> ECIES <span class=\"subst\">=</span> <span class=\"keyword\">require</span>(<span class=\"string\">'bitcore-ecies'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">var</span> alicePrivateKey <span class=\"subst\">=</span> <span class=\"literal\">new</span> bitcore<span class=\"built_in\">.</span>PrivateKey();</div><div class=\"line\"><span class=\"built_in\">var</span> bobPrivateKey <span class=\"subst\">=</span> <span class=\"literal\">new</span> bitcore<span class=\"built_in\">.</span>PrivateKey();</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">var</span> <span class=\"built_in\">data</span> <span class=\"subst\">=</span> <span class=\"literal\">new</span> Buffer(<span class=\"string\">'The is a raw data example'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Encrypt data</span></div><div class=\"line\"><span class=\"built_in\">var</span> cypher1 <span class=\"subst\">=</span> ECIES<span class=\"built_in\">.</span>privateKey(alicePrivateKey)<span class=\"built_in\">.</span>publicKey(bobPrivateKey<span class=\"built_in\">.</span>publicKey);</div><div class=\"line\"><span class=\"built_in\">var</span> encrypted <span class=\"subst\">=</span> cypher<span class=\"built_in\">.</span>encrypt(<span class=\"built_in\">data</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Decrypt data</span></div><div class=\"line\"><span class=\"built_in\">var</span> cypher2 <span class=\"subst\">=</span> ECIES<span class=\"built_in\">.</span>privateKey(bobPrivateKey)<span class=\"built_in\">.</span>publicKey(alicePrivateKey<span class=\"built_in\">.</span>publicKey);</div><div class=\"line\"><span class=\"built_in\">var</span> decrypted <span class=\"subst\">=</span> cypher<span class=\"built_in\">.</span>decrypt(encrypted);</div><div class=\"line\"></div><div class=\"line\">assert(<span class=\"built_in\">data</span><span class=\"built_in\">.</span>toString(), decrypted<span class=\"built_in\">.</span>toString());</div></pre></td></tr></table></figure>\n\n","source":"guide/ecies.md","raw":"# ECIES\n\n## Description\n\nBitcore implements [Elliptic Curve Integrated Encryption Scheme (ECIES)](http://en.wikipedia.org/wiki/Integrated_Encryption_Scheme), which is a public key encryption system that performs bulk encryption on data using a symmetric cipher and a random key.\n\nFor more information refer to the [bitcore-ecies](https://github.com/bitpay/bitcore-ecies) github repo.\n\n## Instalation\n\nECIES is implemented as a separate module and you must add it to your dependencies:\n\nFor node projects:\n```\nnpm install bitcore-ecies --save\n```\n\nFor client-side projects:\n```\nbower install bitcore-ecies --save\n```\n\n## Example\n\n```\nvar bitcore = require('bitcore');\nvar ECIES = require('bitcore-ecies');\n\nvar alicePrivateKey = new bitcore.PrivateKey();\nvar bobPrivateKey = new bitcore.PrivateKey();\n\nvar data = new Buffer('The is a raw data example');\n\n// Encrypt data\nvar cypher1 = ECIES.privateKey(alicePrivateKey).publicKey(bobPrivateKey.publicKey);\nvar encrypted = cypher.encrypt(data);\n\n// Decrypt data\nvar cypher2 = ECIES.privateKey(bobPrivateKey).publicKey(alicePrivateKey.publicKey);\nvar decrypted = cypher.decrypt(encrypted);\n\nassert(data.toString(), decrypted.toString());\n```\n","date":1419285018000,"updated":1419285018000,"path":"guide/ecies.html","excerpt":"","_id":"ccgk9fk5ilrzytnr","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"Encoding\">Encoding</h1>\n<h2 id=\"Description\">Description</h2>\n<p>The <code>bitcore.Encoding</code> namespace contains utilities for encoding information in common formats in the bitcoin ecosystem.</p>\n<h2 id=\"Base58_&amp;_Base58Check\">Base58 &amp; Base58Check</h2>\n<p>Two classes are provided: <code>Base58</code> and <code>Base58Check</code>. The first one merely encodes/decodes a set of bytes in base58 format. The second one will also take the double <code>sha256</code> hash of the information and append the last 4 bytes of the hash as a checksum when encoding, and check this checksum when decoding.</p>\n<h2 id=\"BufferReader_&amp;_BufferWriter\">BufferReader &amp; BufferWriter</h2>\n<p>These classes are used internally to write information in buffers.</p>\n","source":"guide/encoding.md","raw":"# Encoding\n\n## Description\n\nThe `bitcore.Encoding` namespace contains utilities for encoding information in common formats in the bitcoin ecosystem.\n\n## Base58 & Base58Check\n\nTwo classes are provided: `Base58` and `Base58Check`. The first one merely encodes/decodes a set of bytes in base58 format. The second one will also take the double `sha256` hash of the information and append the last 4 bytes of the hash as a checksum when encoding, and check this checksum when decoding.\n\n## BufferReader & BufferWriter\n\nThese classes are used internally to write information in buffers.\n","date":1419285018000,"updated":1419285018000,"path":"guide/encoding.html","excerpt":"","_id":"bef0bs9d0aye5nn7","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"HDKeys\">HDKeys</h1>\n<h2 id=\"Hierarichically_Derived_Keys\">Hierarichically Derived Keys</h2>\n<p>Bitcore provides full support for <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\" target=\"_blank\" rel=\"external\">BIP32</a>, allowing for many key management schemas that benefit from this property.  Please be sure to read and understand the basic concepts and the warnings on that BIP before using these classes.</p>\n<h2 id=\"HDPrivateKey\">HDPrivateKey</h2>\n<p>An instance of a <a href=\"privatekey.md\">PrivateKey</a> that also contains information required to derive child keys.</p>\n<p>Sample usage:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> hdPrivateKey = <span class=\"keyword\">new</span> HDPrivateKey();</div><div class=\"line\"><span class=\"keyword\">var</span> retrieved = <span class=\"keyword\">new</span> HDPrivateKey(<span class=\"string\">'xpriv...'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> derived = privateKey.derive(<span class=\"string\">\"m/0'\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> derivedByNumber = privateKey.derive(<span class=\"number\">1</span>).derive(<span class=\"number\">2</span>, <span class=\"literal\">true</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> derivedByArgument = privateKey.derive(<span class=\"string\">\"m/1/2'\"</span>);</div><div class=\"line\">assert(derivedByNumber.xprivkey === derivedByArgument.xprivkey);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> address = <span class=\"keyword\">new</span> Address(privateKey.publicKey, Networks.livenet);</div><div class=\"line\"><span class=\"keyword\">var</span> redeem = <span class=\"keyword\">new</span> Transaction().from(output).to(target, <span class=\"number\">10000</span>).sign(derived.privateKey);</div></pre></td></tr></table></figure>\n\n<h2 id=\"HDPublicKey\">HDPublicKey</h2>\n<p>An instance of a PublicKey that can be derived to build extended public keys. Note that hardened paths are not available when deriving an HDPublicKey.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> hdPrivateKey = <span class=\"keyword\">new</span> HDPrivateKey();</div><div class=\"line\"><span class=\"keyword\">var</span> hdPublicKey = privateKey.hdPublicKey;</div><div class=\"line\"><span class=\"keyword\">try</span> {</div><div class=\"line\">  <span class=\"keyword\">new</span> HDPublicKey();</div><div class=\"line\">} <span class=\"keyword\">catch</span>(e) {</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Can't generate a public key without a private key\"</span>);</div><div class=\"line\">}</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> address = <span class=\"keyword\">new</span> Address(hdPublicKey.publicKey, Networks.livenet);</div><div class=\"line\"><span class=\"keyword\">var</span> derivedAddress = <span class=\"keyword\">new</span> Address(hdPublicKey.derive(<span class=\"number\">100</span>).publicKey, Networks.testnet);</div></pre></td></tr></table></figure>\n\n","source":"guide/hierarchical.md","raw":"# HDKeys\n\n## Hierarichically Derived Keys\n\nBitcore provides full support for [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki), allowing for many key management schemas that benefit from this property.  Please be sure to read and understand the basic concepts and the warnings on that BIP before using these classes.\n\n## HDPrivateKey\n\nAn instance of a [PrivateKey](privatekey.md) that also contains information required to derive child keys.\n\nSample usage:\n\n```javascript\nvar hdPrivateKey = new HDPrivateKey();\nvar retrieved = new HDPrivateKey('xpriv...');\nvar derived = privateKey.derive(\"m/0'\");\nvar derivedByNumber = privateKey.derive(1).derive(2, true);\nvar derivedByArgument = privateKey.derive(\"m/1/2'\");\nassert(derivedByNumber.xprivkey === derivedByArgument.xprivkey);\n\nvar address = new Address(privateKey.publicKey, Networks.livenet);\nvar redeem = new Transaction().from(output).to(target, 10000).sign(derived.privateKey);\n```\n\n## HDPublicKey\n\nAn instance of a PublicKey that can be derived to build extended public keys. Note that hardened paths are not available when deriving an HDPublicKey.\n\n```javascript\nvar hdPrivateKey = new HDPrivateKey();\nvar hdPublicKey = privateKey.hdPublicKey;\ntry {\n  new HDPublicKey();\n} catch(e) {\n  console.log(\"Can't generate a public key without a private key\");\n}\n\nvar address = new Address(hdPublicKey.publicKey, Networks.livenet);\nvar derivedAddress = new Address(hdPublicKey.derive(100).publicKey, Networks.testnet);\n```\n","date":1419285018000,"updated":1419285018000,"path":"guide/hierarchical.html","excerpt":"","_id":"ylzu5iamn4aimbxu","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"Bitcore\">Bitcore</h1>\n<p><a href=\"https://www.npmjs.org/package/bitcore\" target=\"_blank\" rel=\"external\"><img src=\"https://img.shields.io/npm/v/bitcore.svg?style=flat-square\" alt=\"NPM Package\"></a><br><a href=\"https://travis-ci.org/bitpay/bitcore\" target=\"_blank\" rel=\"external\"><img src=\"https://img.shields.io/travis/bitpay/bitcore.svg?branch=master&amp;style=flat-square\" alt=\"Build Status\"></a><br><a href=\"https://coveralls.io/r/bitpay/bitcore\" target=\"_blank\" rel=\"external\"><img src=\"https://img.shields.io/coveralls/bitpay/bitcore.svg?style=flat-square\" alt=\"Coverage Status\"></a></p>\n<p>A pure and simple JavaScript bitcoin API.</p>\n<h2 id=\"Principles\">Principles</h2>\n<p>Bitcoin is a powerful new peer-to-peer platform for the next generation of financial technology. The decentralized nature of the Bitcoin network allows for highly resilient bitcoin infrastructure, and the developer community needs reliable, open-source tools to implement bitcoin apps and services.</p>\n<h2 id=\"Get_Started\">Get Started</h2>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm <span class=\"operator\"><span class=\"keyword\">install</span> bitcore</span></div></pre></td></tr></table></figure>\n\n<p>Using it in Node.js:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> bitcore = <span class=\"built_in\">require</span>(<span class=\"string\">'bitcore'</span>);</div><div class=\"line\"></div><div class=\"line\">assert(bitcore.Address.isValid(address));</div><div class=\"line\"><span class=\"keyword\">var</span> simpleTx = <span class=\"keyword\">new</span> bitcore.Transaction();</div><div class=\"line\"><span class=\"keyword\">var</span> simpleTx.from(unspent).to(address, amount);</div><div class=\"line\">simpleTx.sign(privateKey);</div></pre></td></tr></table></figure>\n\n<h2 id=\"Documentation\">Documentation</h2>\n<p>The complete docs are hosted here: <a href=\"https://bitpay.github.io/bitcore/docs/#!index.md\" target=\"_blank\" rel=\"external\">bitcore documentation</a>. There’s also a <a href=\"https://bitpay.github.io/bitcore/apiref\" target=\"_blank\" rel=\"external\">bitcore API reference</a> available generated from the JSDocs of the project, but we’re still working on the quality and design of this API reference.</p>\n<p><a href=\"https://bitpay.github.io/bitcore/docs/#!index.md\" target=\"_blank\" rel=\"external\"><img src=\"http://bitpay.github.io/bitcore/images/read-the-developer-guide-btn.png\" alt=\"Read the Developer Guide\"></a>  <a href=\"https://bitpay.github.io/bitcore/apiref\" target=\"_blank\" rel=\"external\"><img src=\"http://bitpay.github.io/bitcore/images/read-the-api-reference-btn.png\" alt=\"Read the API Reference\"></a></p>\n<h2 id=\"Security\">Security</h2>\n<p>Please use at your own risk.</p>\n<p>Bitcore is still under heavy development and not quite ready for “drop-in” production use. If you find a security issue, please email security@bitcore.io.</p>\n<h2 id=\"Contributing\">Contributing</h2>\n<p>Please send pull requests for bug fixes, code optimization, and ideas for improvement.</p>\n<h2 id=\"Building_the_Browser_Bundle\">Building the Browser Bundle</h2>\n<p>To build bitcore full bundle for the browser:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp browser</div></pre></td></tr></table></figure>\n\n<p>This will generate files named <code>browser/bitcore.js</code> and <code>browser/bitcore.min.js</code>.</p>\n<h2 id=\"Tests\">Tests</h2>\n<p>Run all the tests:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp test</div></pre></td></tr></table></figure>\n\n<p>Run the tests with mocha:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp test:node</div></pre></td></tr></table></figure>\n\n<p>Run the tests with karma (uses firefox and chrome):</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp test:browser</div></pre></td></tr></table></figure>\n\n<p>Create a coverage report (you can open <code>coverage/lcov-report/index.html</code> to visualize it):</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp coverage</div></pre></td></tr></table></figure>\n\n<h2 id=\"License\">License</h2>\n<p>Code released under <a href=\"https://github.com/bitpay/bitcore/blob/master/LICENSE\" target=\"_blank\" rel=\"external\">the MIT license</a>.</p>\n<p>Copyright 2013-2014 BitPay, Inc. Bitcore is a trademark maintained by BitPay, Inc.</p>\n","source":"guide/index.md","raw":"Bitcore\n=======\n\n[![NPM Package](https://img.shields.io/npm/v/bitcore.svg?style=flat-square)](https://www.npmjs.org/package/bitcore)\n[![Build Status](https://img.shields.io/travis/bitpay/bitcore.svg?branch=master&style=flat-square)](https://travis-ci.org/bitpay/bitcore)\n[![Coverage Status](https://img.shields.io/coveralls/bitpay/bitcore.svg?style=flat-square)](https://coveralls.io/r/bitpay/bitcore)\n\nA pure and simple JavaScript bitcoin API.\n\n## Principles\n\nBitcoin is a powerful new peer-to-peer platform for the next generation of financial technology. The decentralized nature of the Bitcoin network allows for highly resilient bitcoin infrastructure, and the developer community needs reliable, open-source tools to implement bitcoin apps and services.\n\n## Get Started\n\n```\nnpm install bitcore\n```\n\nUsing it in Node.js:\n\n```javascript\nvar bitcore = require('bitcore');\n\nassert(bitcore.Address.isValid(address));\nvar simpleTx = new bitcore.Transaction();\nvar simpleTx.from(unspent).to(address, amount);\nsimpleTx.sign(privateKey);\n```\n\n## Documentation\n\nThe complete docs are hosted here: [bitcore documentation](https://bitpay.github.io/bitcore/docs/#!index.md). There's also a [bitcore API reference](https://bitpay.github.io/bitcore/apiref) available generated from the JSDocs of the project, but we're still working on the quality and design of this API reference.\n\n[![Read the Developer Guide](http://bitpay.github.io/bitcore/images/read-the-developer-guide-btn.png)](https://bitpay.github.io/bitcore/docs/#!index.md)  [![Read the API Reference](http://bitpay.github.io/bitcore/images/read-the-api-reference-btn.png)](https://bitpay.github.io/bitcore/apiref)\n\n## Security\n\nPlease use at your own risk.\n\nBitcore is still under heavy development and not quite ready for \"drop-in\" production use. If you find a security issue, please email security@bitcore.io.\n\n## Contributing\n\nPlease send pull requests for bug fixes, code optimization, and ideas for improvement.\n\n## Building the Browser Bundle\n\nTo build bitcore full bundle for the browser:\n\n```sh\ngulp browser\n```\n\nThis will generate files named `browser/bitcore.js` and `browser/bitcore.min.js`.\n\n## Tests\n\nRun all the tests:\n\n```sh\ngulp test\n```\n\nRun the tests with mocha:\n\n```sh\ngulp test:node\n```\n\nRun the tests with karma (uses firefox and chrome):\n\n```sh\ngulp test:browser\n```\n\nCreate a coverage report (you can open `coverage/lcov-report/index.html` to visualize it):\n\n```sh\ngulp coverage\n```\n\n## License\n\nCode released under [the MIT license](https://github.com/bitpay/bitcore/blob/master/LICENSE).\n\nCopyright 2013-2014 BitPay, Inc. Bitcore is a trademark maintained by BitPay, Inc.\n","date":1419285023000,"updated":1419285023000,"path":"guide/index.html","excerpt":"","_id":"u42cxdkxvy4asrbk","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"JSON-RPC\">JSON-RPC</h1>\n<h2 id=\"Description\">Description</h2>\n<p>Bitcoind provides a direct interface to the bitcoin network and it also exposes a <code>JSON-RPC</code> API. This class will connect to a local instance of a bitcoind server and make simple or batch RPC calls to it.</p>\n<h2 id=\"Connection_to_bitcoind\">Connection to bitcoind</h2>\n<p>First you will need a running instance of bitcoind, setting up a username and password to connect with it. For more information about running bitcoind please refer to the <a href=\"https://en.bitcoin.it/wiki/Running_Bitcoin\" target=\"_blank\" rel=\"external\">official documentation</a>.</p>\n<p>The code for creating and configuring an instance of the RPC client looks like this:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> bitcore = <span class=\"built_in\">require</span>(<span class=\"string\">'bitcore'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> RPC = bitcore.transport.RPC;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> client = <span class=\"keyword\">new</span> RPC(<span class=\"string\">'username'</span>, <span class=\"string\">'password'</span>, {</div><div class=\"line\">  host: <span class=\"string\">'localhost'</span>,</div><div class=\"line\">  port: <span class=\"number\">18332</span>,</div><div class=\"line\">  secure: <span class=\"literal\">false</span>,</div><div class=\"line\">  disableAgent: <span class=\"literal\">true</span>,</div><div class=\"line\">  rejectUnauthorized: <span class=\"literal\">true</span></div><div class=\"line\">});</div></pre></td></tr></table></figure>\n\n<h2 id=\"Examples\">Examples</h2>\n<p>For more information please refer to the <a href=\"https://en.bitcoin.it/wiki/API_reference_%28JSON-RPC%29\" target=\"_blank\" rel=\"external\">API reference</a>.</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> bitcore = <span class=\"built_in\">require</span>(<span class=\"string\">'bitcore'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> blockHash = <span class=\"string\">'0000000000000000045d581af7fa3b6110266ece8131424d95bf490af828be1c'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> client = <span class=\"keyword\">new</span> bitcore.transport.RPC(<span class=\"string\">'username'</span>, <span class=\"string\">'password'</span>);</div><div class=\"line\"></div><div class=\"line\">client.getBlock(blockHash, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(err, block)</span> </span>{</div><div class=\"line\">  <span class=\"comment\">// do something with the block</span></div><div class=\"line\">});</div></pre></td></tr></table></figure>\n\n","source":"guide/jsonrpc.md","raw":"# JSON-RPC\n\n## Description\n\nBitcoind provides a direct interface to the bitcoin network and it also exposes a `JSON-RPC` API. This class will connect to a local instance of a bitcoind server and make simple or batch RPC calls to it.\n\n## Connection to bitcoind\n\nFirst you will need a running instance of bitcoind, setting up a username and password to connect with it. For more information about running bitcoind please refer to the [official documentation](https://en.bitcoin.it/wiki/Running_Bitcoin).\n\nThe code for creating and configuring an instance of the RPC client looks like this:\n\n```\nvar bitcore = require('bitcore');\nvar RPC = bitcore.transport.RPC;\n\nvar client = new RPC('username', 'password', {\n  host: 'localhost',\n  port: 18332,\n  secure: false,\n  disableAgent: true,\n  rejectUnauthorized: true\n});\n```\n\n\n## Examples\n\nFor more information please refer to the [API reference](https://en.bitcoin.it/wiki/API_reference_%28JSON-RPC%29).\n\n```\nvar bitcore = require('bitcore');\nvar blockHash = '0000000000000000045d581af7fa3b6110266ece8131424d95bf490af828be1c';\n\nvar client = new bitcore.transport.RPC('username', 'password');\n\nclient.getBlock(blockHash, function(err, block) {\n  // do something with the block\n});\n\n```\n","date":1419285018000,"updated":1419285018000,"path":"guide/jsonrpc.html","excerpt":"","_id":"o6wpuyu4bmmctzxl","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"Networks\">Networks</h1>\n<h2 id=\"Description\">Description</h2>\n<p>Bitcore provides support for the main bitcoin network as well as for <code>testnet3</code>, the current test blockchain. We encourage the use of <code>Networks.livenet</code> and <code>Networks.testnet</code> as constants. Note that the library sometimes may check for equality against this object. Avoid creating a deep copy of this object and using that.</p>\n<p>The <code>Network</code> namespace has a function, <code>get(...)</code> that returns an instance of a <code>Network</code> or <code>undefined</code>. The only argument to this function is some kind of identifier of the network: either its name, a reference to a Network object, or a number used as a magic constant to identify the network (for example, the value <code>0</code> that gives bitcoin addresses the distinctive <code>&#39;1&#39;</code> at its beginning on livenet, is a <code>0x6F</code> for testnet).</p>\n<h2 id=\"Setting_the_Default_Network\">Setting the Default Network</h2>\n<p>Most projects will only need to work with one of the networks. The value of <code>Networks.defaultNetwork</code> can be set to <code>Networks.testnet</code> if the project will need to only to work on testnet (the default is <code>Networks.livenet</code>).</p>\n<h2 id=\"Network_constants\">Network constants</h2>\n<p>The functionality of testnet and livenet is mostly similar (except for some relaxed block validation rules on testnet). They differ in the constants being used for human representation of base58 encoded strings. These are sometimes referred to as “version” constants.</p>\n<p>Take a look at this modified snippet from <a href=\"https://github.com/bitpay/bitcore/blob/master/lib/networks.js\" target=\"_blank\" rel=\"external\">networks.js</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> livenet = <span class=\"keyword\">new</span> Network();</div><div class=\"line\">_.extend(livenet, {</div><div class=\"line\">  name: <span class=\"string\">'livenet'</span>,</div><div class=\"line\">  alias: <span class=\"string\">'mainnet'</span>,</div><div class=\"line\">  pubkeyhash: <span class=\"number\">0x00</span>,</div><div class=\"line\">  privatekey: <span class=\"number\">0x80</span>,</div><div class=\"line\">  scripthash: <span class=\"number\">0x05</span>,</div><div class=\"line\">  xpubkey:  <span class=\"number\">0x0488b21e</span>,</div><div class=\"line\">  xprivkey: <span class=\"number\">0x0488ade4</span>,</div><div class=\"line\">  port: <span class=\"number\">8333</span></div><div class=\"line\">});</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> testnet = <span class=\"keyword\">new</span> Network();</div><div class=\"line\">_.extend(testnet, {</div><div class=\"line\">  name: <span class=\"string\">'testnet'</span>,</div><div class=\"line\">  alias: <span class=\"string\">'testnet'</span>,</div><div class=\"line\">  pubkeyhash: <span class=\"number\">0x6f</span>,</div><div class=\"line\">  privatekey: <span class=\"number\">0xef</span>,</div><div class=\"line\">  scripthash: <span class=\"number\">0xc4</span>,</div><div class=\"line\">  xpubkey: <span class=\"number\">0x043587cf</span>,</div><div class=\"line\">  xprivkey: <span class=\"number\">0x04358394</span>,</div><div class=\"line\">  port: <span class=\"number\">18333</span></div><div class=\"line\">});</div></pre></td></tr></table></figure>\n\n","source":"guide/networks.md","raw":"# Networks\n\n## Description\n\nBitcore provides support for the main bitcoin network as well as for `testnet3`, the current test blockchain. We encourage the use of `Networks.livenet` and `Networks.testnet` as constants. Note that the library sometimes may check for equality against this object. Avoid creating a deep copy of this object and using that.\n\nThe `Network` namespace has a function, `get(...)` that returns an instance of a `Network` or `undefined`. The only argument to this function is some kind of identifier of the network: either its name, a reference to a Network object, or a number used as a magic constant to identify the network (for example, the value `0` that gives bitcoin addresses the distinctive `'1'` at its beginning on livenet, is a `0x6F` for testnet).\n\n## Setting the Default Network\n\nMost projects will only need to work with one of the networks. The value of `Networks.defaultNetwork` can be set to `Networks.testnet` if the project will need to only to work on testnet (the default is `Networks.livenet`).\n\n## Network constants\n\nThe functionality of testnet and livenet is mostly similar (except for some relaxed block validation rules on testnet). They differ in the constants being used for human representation of base58 encoded strings. These are sometimes referred to as \"version\" constants.\n\nTake a look at this modified snippet from [networks.js](https://github.com/bitpay/bitcore/blob/master/lib/networks.js)\n```javascript\nvar livenet = new Network();\n_.extend(livenet, {\n  name: 'livenet',\n  alias: 'mainnet',\n  pubkeyhash: 0x00,\n  privatekey: 0x80,\n  scripthash: 0x05,\n  xpubkey:  0x0488b21e,\n  xprivkey: 0x0488ade4,\n  port: 8333\n});\n\nvar testnet = new Network();\n_.extend(testnet, {\n  name: 'testnet',\n  alias: 'testnet',\n  pubkeyhash: 0x6f,\n  privatekey: 0xef,\n  scripthash: 0xc4,\n  xpubkey: 0x043587cf,\n  xprivkey: 0x04358394,\n  port: 18333\n});\n```\n","date":1419285019000,"updated":1419285019000,"path":"guide/networks.html","excerpt":"","_id":"u38sbourwk5b7mks","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"Payment_Protocol\">Payment Protocol</h1>\n<h2 id=\"Description\">Description</h2>\n<p><code>PaymentProtocol</code> and associated functions and methods will serialize, deserialize, sign and verify payment protocol messages both in Node.js and web browsers. Both X.509 and <a href=\"https://en.bitcoin.it/wiki/Identity_protocol_v1\" target=\"_blank\" rel=\"external\">bitcoin identity protocol</a> are supported. For detailed technical information, please view <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki\" target=\"_blank\" rel=\"external\">BIP70</a>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> bitcore = <span class=\"built_in\">require</span>(<span class=\"string\">'bitcore'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> PaymentProtocol = bitcore.PaymentProtocol;</div></pre></td></tr></table></figure>\n\n<h2 id=\"Make_Payment_Details\">Make Payment Details</h2>\n<p>Here the merchant’s server will construct the payment details message:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> now = <span class=\"built_in\">Date</span>.now() / <span class=\"number\">1000</span> | <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// construct the payment details</span></div><div class=\"line\"><span class=\"keyword\">var</span> details = <span class=\"keyword\">new</span> PaymentProtocol().makePaymentDetails();</div><div class=\"line\">details.set(<span class=\"string\">'network'</span>, <span class=\"string\">'test'</span>);</div><div class=\"line\">details.set(<span class=\"string\">'outputs'</span>, outputs);</div><div class=\"line\">details.set(<span class=\"string\">'time'</span>, now);</div><div class=\"line\">details.set(<span class=\"string\">'expires'</span>, now + <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span>);</div><div class=\"line\">details.set(<span class=\"string\">'memo'</span>, <span class=\"string\">'A payment request from the merchant.'</span>);</div><div class=\"line\">details.set(<span class=\"string\">'payment_url'</span>, <span class=\"string\">'https://localhost/-/pay'</span>);</div><div class=\"line\">details.set(<span class=\"string\">'merchant_data'</span>, <span class=\"keyword\">new</span> Buffer({size: <span class=\"number\">7</span>})); <span class=\"comment\">// identify the request</span></div></pre></td></tr></table></figure>\n\n<p>For more information about these fields please visit <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki#paymentdetailspaymentrequest\" target=\"_blank\" rel=\"external\">BIP70</a></p>\n<h2 id=\"Sign_a_Payment_Request\">Sign a Payment Request</h2>\n<p>The merchant’s server will then construct a payment request and send it to the customer:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// load the X509 certificate</span></div><div class=\"line\"><span class=\"keyword\">var</span> certificates = <span class=\"keyword\">new</span> PaymentProtocol().makeX509Certificates();</div><div class=\"line\">certificates.set(<span class=\"string\">'certificate'</span>, [file_with_x509_der_cert]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// form the request</span></div><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> PaymentRequest().makePaymentRequest();</div><div class=\"line\">request.set(<span class=\"string\">'payment_details_version'</span>, <span class=\"number\">1</span>);</div><div class=\"line\">request.set(<span class=\"string\">'pki_type'</span>, <span class=\"string\">'x509+sha256'</span>);</div><div class=\"line\">request.set(<span class=\"string\">'pki_data'</span>, certificates.serialize());</div><div class=\"line\">request.set(<span class=\"string\">'serialized_payment_details'</span>, details.serialize());</div><div class=\"line\">request.sign(file_with_x509_private_key);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// serialize the request</span></div><div class=\"line\"><span class=\"keyword\">var</span> rawbody = request.serialize();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Example HTTP Response Headers:</span></div><div class=\"line\"><span class=\"comment\">// Content-Type: PaymentProtocol.PAYMENT_REQUEST_CONTENT_TYPE</span></div><div class=\"line\"><span class=\"comment\">// Content-Length: request.length</span></div><div class=\"line\"><span class=\"comment\">// Content-Transfer-Encoding: 'binary'</span></div></pre></td></tr></table></figure>\n\n<h2 id=\"Verify_a_Payment_Request\">Verify a Payment Request</h2>\n<p>The customers wallet would then verify the payment request as follows (after asking for the payment request message):</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Example HTTP Request Headers:</span></div><div class=\"line\"><span class=\"comment\">// Method: GET</span></div><div class=\"line\"><span class=\"comment\">// Accept: PaymentProtocol.PAYMENT_REQUEST_CONTENT_TYPE, PaymentProtocol.PAYMENT_ACK_CONTENT_TYPE</span></div><div class=\"line\"><span class=\"comment\">// Content-Type: 'application/octet-stream'</span></div><div class=\"line\"><span class=\"comment\">// Content-Length: 0</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> body = PaymentProtocol.PaymentRequest.decode(rawbody);</div><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> PaymentProtocol().makePaymentRequest(body);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> version = pr.get(<span class=\"string\">'payment_details_version'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> pki_type = pr.get(<span class=\"string\">'pki_type'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> pki_data = pr.get(<span class=\"string\">'pki_data'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> serializedDetails = pr.get(<span class=\"string\">'serialized_payment_details'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> signature = pr.get(<span class=\"string\">'signature'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Verify the signature</span></div><div class=\"line\"><span class=\"keyword\">var</span> verified = request.verify();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Get the payment details</span></div><div class=\"line\"><span class=\"keyword\">var</span> decodedDetails = PaymentProtocol.PaymentDetails.decode(serializedDetails);</div><div class=\"line\"><span class=\"keyword\">var</span> details = <span class=\"keyword\">new</span> PaymentProtocol().makePaymentDetails(decodedDetails);</div><div class=\"line\"><span class=\"keyword\">var</span> network = details.get(<span class=\"string\">'network'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> outputs = details.get(<span class=\"string\">'outputs'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> time = details.get(<span class=\"string\">'time'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> expires = details.get(<span class=\"string\">'expires'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> memo = details.get(<span class=\"string\">'memo'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> payment_url = details.get(<span class=\"string\">'payment_url'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> merchant_data = details.get(<span class=\"string\">'merchant_data'</span>);</div></pre></td></tr></table></figure>\n\n<h2 id=\"Send_a_Payment\">Send a Payment</h2>\n<p>After the request is verified a payment can be sent to the merchant, from the customer’s wallet:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// send the payment transaction</span></div><div class=\"line\"><span class=\"keyword\">var</span> payment = <span class=\"keyword\">new</span> PaymentProtocol().makePayment();</div><div class=\"line\">payment.set(<span class=\"string\">'merchant_data'</span>, merchant_data);</div><div class=\"line\">payment.set(<span class=\"string\">'transactions'</span>, [transaction_with_outputs]); <span class=\"comment\">// as from payment details</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// define the refund outputs</span></div><div class=\"line\"><span class=\"keyword\">var</span> refund_outputs = [];</div><div class=\"line\"><span class=\"keyword\">var</span> outputs = <span class=\"keyword\">new</span> PaymentProtocol().makeOutput();</div><div class=\"line\">outputs.set(<span class=\"string\">'amount'</span>, <span class=\"number\">0</span>);</div><div class=\"line\">outputs.set(<span class=\"string\">'script'</span>, script.toBuffer()); <span class=\"comment\">// an instance of script</span></div><div class=\"line\">refund_outputs.push(outputs.message);</div><div class=\"line\"></div><div class=\"line\">payment.set(<span class=\"string\">'refund_to'</span>, refund_outputs);</div><div class=\"line\">payment.set(<span class=\"string\">'memo'</span>, <span class=\"string\">'Here is a payment'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// serialize and send</span></div><div class=\"line\"><span class=\"keyword\">var</span> rawbody = pay.serialize();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Example Request Headers:</span></div><div class=\"line\"><span class=\"comment\">// Method: 'POST',</span></div><div class=\"line\"><span class=\"comment\">// Accept: PaymentProtocol.PAYMENT_REQUEST_CONTENT_TYPE, PaymentPrococl.PAYMENT_ACK_CONTENT_TYPE</span></div><div class=\"line\"><span class=\"comment\">// Content-Type: PaymentProtocol.PAYMENT_CONTENT_TYPE</span></div><div class=\"line\"><span class=\"comment\">// Content-Length: payment.length</span></div><div class=\"line\"><span class=\"comment\">// Content-Transfer-Encoding: 'binary'</span></div></pre></td></tr></table></figure>\n\n<h2 id=\"Receive_a_Payment\">Receive a Payment</h2>\n<p>The merchant would then receive the payment as follows:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> body = PaymentProtocol.Payment.decode(rawbody);</div><div class=\"line\"><span class=\"keyword\">var</span> payment = <span class=\"keyword\">new</span> PaymentProtocol().makePayment(body);</div><div class=\"line\"><span class=\"keyword\">var</span> merchant_data = payment.get(<span class=\"string\">'merchant_data'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> transactions = payment.get(<span class=\"string\">'transactions'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> refund_to = payment.get(<span class=\"string\">'refund_to'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> memo = payment.get(<span class=\"string\">'memo'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// send the transaction to the bitcoin network</span></div></pre></td></tr></table></figure>\n\n<h2 id=\"Send_a_Payment_Acknowledgement\">Send a Payment Acknowledgement</h2>\n<p>After the payment has been broadcasted, a payment acknowledgement can be sent in response:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// make a payment acknowledgement</span></div><div class=\"line\"><span class=\"keyword\">var</span> ack = <span class=\"keyword\">new</span> PaymentProtocol().makePaymentACK();</div><div class=\"line\">ack.set(<span class=\"string\">'payment'</span>, payment.message);</div><div class=\"line\">ack.set(<span class=\"string\">'memo'</span>, <span class=\"string\">'Thank you for your payment!'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> rawbody = ack.serialize();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Example Response Headers:</span></div><div class=\"line\"><span class=\"comment\">// Content-Type: PaymentProtocol.PAYMENT_ACK_CONTENT_TYPE</span></div><div class=\"line\"><span class=\"comment\">// Content-Length: ack.length</span></div><div class=\"line\"><span class=\"comment\">// Content-Transfer-Encoding: 'binary'</span></div></pre></td></tr></table></figure>\n\n<h2 id=\"Receive_an_Acknowledgement\">Receive an Acknowledgement</h2>\n<p>The customer’s wallet can then receive an acknowledgement of payment as follows:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> body = PaymentProtocol.PaymentACK.decode(rawbody);</div><div class=\"line\"><span class=\"keyword\">var</span> ack = <span class=\"keyword\">new</span> PaymentProtocol().makePaymentACK(body);</div><div class=\"line\"><span class=\"keyword\">var</span> serializedPayment = ack.get(<span class=\"string\">'payment'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> memo = ack.get(<span class=\"string\">'memo'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> decodedPayment = PaymentProtocol.Payment.decode(serializedPayment);</div><div class=\"line\"><span class=\"keyword\">var</span> payment = <span class=\"keyword\">new</span> PaymentProtocol().makePayment(decodedPayment);</div><div class=\"line\"><span class=\"keyword\">var</span> tx = payment.message.transactions[<span class=\"number\">0</span>];</div></pre></td></tr></table></figure>\n\n<p>For detailed diagram of the exchange of messages, please see the <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki#protocol\" target=\"_blank\" rel=\"external\">Protocol section of BIP70</a>.</p>\n","source":"guide/paymentprotocol.md","raw":"# Payment Protocol\n\n## Description\n\n`PaymentProtocol` and associated functions and methods will serialize, deserialize, sign and verify payment protocol messages both in Node.js and web browsers. Both X.509 and [bitcoin identity protocol](https://en.bitcoin.it/wiki/Identity_protocol_v1) are supported. For detailed technical information, please view [BIP70](https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki).\n\n```javascript\nvar bitcore = require('bitcore');\nvar PaymentProtocol = bitcore.PaymentProtocol;\n```\n\n## Make Payment Details\n\nHere the merchant's server will construct the payment details message:\n\n```javascript\nvar now = Date.now() / 1000 | 0;\n\n// construct the payment details\nvar details = new PaymentProtocol().makePaymentDetails();\ndetails.set('network', 'test');\ndetails.set('outputs', outputs);\ndetails.set('time', now);\ndetails.set('expires', now + 60 * 60 * 24);\ndetails.set('memo', 'A payment request from the merchant.');\ndetails.set('payment_url', 'https://localhost/-/pay');\ndetails.set('merchant_data', new Buffer({size: 7})); // identify the request\n\n```\n\nFor more information about these fields please visit [BIP70](https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki#paymentdetailspaymentrequest)\n\n\n## Sign a Payment Request\n\nThe merchant's server will then construct a payment request and send it to the customer:\n\n```javascript\n// load the X509 certificate\nvar certificates = new PaymentProtocol().makeX509Certificates();\ncertificates.set('certificate', [file_with_x509_der_cert]);\n\n// form the request\nvar request = new PaymentRequest().makePaymentRequest();\nrequest.set('payment_details_version', 1);\nrequest.set('pki_type', 'x509+sha256');\nrequest.set('pki_data', certificates.serialize());\nrequest.set('serialized_payment_details', details.serialize());\nrequest.sign(file_with_x509_private_key);\n\n// serialize the request\nvar rawbody = request.serialize();\n\n// Example HTTP Response Headers:\n// Content-Type: PaymentProtocol.PAYMENT_REQUEST_CONTENT_TYPE\n// Content-Length: request.length\n// Content-Transfer-Encoding: 'binary'\n\n```\n\n## Verify a Payment Request\n\nThe customers wallet would then verify the payment request as follows (after asking for the payment request message):\n\n```javascript\n\n// Example HTTP Request Headers:\n// Method: GET\n// Accept: PaymentProtocol.PAYMENT_REQUEST_CONTENT_TYPE, PaymentProtocol.PAYMENT_ACK_CONTENT_TYPE\n// Content-Type: 'application/octet-stream'\n// Content-Length: 0\n\nvar body = PaymentProtocol.PaymentRequest.decode(rawbody);\nvar request = new PaymentProtocol().makePaymentRequest(body);\n\nvar version = pr.get('payment_details_version');\nvar pki_type = pr.get('pki_type');\nvar pki_data = pr.get('pki_data');\nvar serializedDetails = pr.get('serialized_payment_details');\nvar signature = pr.get('signature');\n\n// Verify the signature\nvar verified = request.verify();\n\n// Get the payment details\nvar decodedDetails = PaymentProtocol.PaymentDetails.decode(serializedDetails);\nvar details = new PaymentProtocol().makePaymentDetails(decodedDetails);\nvar network = details.get('network');\nvar outputs = details.get('outputs');\nvar time = details.get('time');\nvar expires = details.get('expires');\nvar memo = details.get('memo');\nvar payment_url = details.get('payment_url');\nvar merchant_data = details.get('merchant_data');\n\n```\n\n## Send a Payment\n\nAfter the request is verified a payment can be sent to the merchant, from the customer's wallet:\n\n```javascript\n\n// send the payment transaction\nvar payment = new PaymentProtocol().makePayment();\npayment.set('merchant_data', merchant_data);\npayment.set('transactions', [transaction_with_outputs]); // as from payment details\n\n// define the refund outputs\nvar refund_outputs = [];\nvar outputs = new PaymentProtocol().makeOutput();\noutputs.set('amount', 0);\noutputs.set('script', script.toBuffer()); // an instance of script\nrefund_outputs.push(outputs.message);\n\npayment.set('refund_to', refund_outputs);\npayment.set('memo', 'Here is a payment');\n\n// serialize and send\nvar rawbody = pay.serialize();\n\n// Example Request Headers:\n// Method: 'POST',\n// Accept: PaymentProtocol.PAYMENT_REQUEST_CONTENT_TYPE, PaymentPrococl.PAYMENT_ACK_CONTENT_TYPE\n// Content-Type: PaymentProtocol.PAYMENT_CONTENT_TYPE\n// Content-Length: payment.length\n// Content-Transfer-Encoding: 'binary'\n\n```\n\n## Receive a Payment\n\nThe merchant would then receive the payment as follows:\n\n```javascript\n\nvar body = PaymentProtocol.Payment.decode(rawbody);\nvar payment = new PaymentProtocol().makePayment(body);\nvar merchant_data = payment.get('merchant_data');\nvar transactions = payment.get('transactions');\nvar refund_to = payment.get('refund_to');\nvar memo = payment.get('memo');\n\n// send the transaction to the bitcoin network\n\n```\n\n## Send a Payment Acknowledgement\n\nAfter the payment has been broadcasted, a payment acknowledgement can be sent in response:\n\n```javascript\n\n// make a payment acknowledgement\nvar ack = new PaymentProtocol().makePaymentACK();\nack.set('payment', payment.message);\nack.set('memo', 'Thank you for your payment!');\nvar rawbody = ack.serialize();\n\n// Example Response Headers:\n// Content-Type: PaymentProtocol.PAYMENT_ACK_CONTENT_TYPE\n// Content-Length: ack.length\n// Content-Transfer-Encoding: 'binary'\n\n```\n\n## Receive an Acknowledgement\n\nThe customer's wallet can then receive an acknowledgement of payment as follows:\n\n```javascript\nvar body = PaymentProtocol.PaymentACK.decode(rawbody);\nvar ack = new PaymentProtocol().makePaymentACK(body);\nvar serializedPayment = ack.get('payment');\nvar memo = ack.get('memo');\nvar decodedPayment = PaymentProtocol.Payment.decode(serializedPayment);\nvar payment = new PaymentProtocol().makePayment(decodedPayment);\nvar tx = payment.message.transactions[0];\n```\n\nFor detailed diagram of the exchange of messages, please see the [Protocol section of BIP70](https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki#protocol).\n","date":1419285019000,"updated":1419285019000,"path":"guide/paymentprotocol.html","excerpt":"","_id":"rwx5e5vhn46ku5r5","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"Peer\">Peer</h1>\n<h2 id=\"Description\">Description</h2>\n<p>Represents a node from the p2p bitcoin network. The Peer class supports connecting directly to other nodes or through a socks5 proxy like Tor.</p>\n<h2 id=\"Creating_a_peer\">Creating a peer</h2>\n<p>The code to create a new peer looks like this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> bitcore = <span class=\"built_in\">require</span>(<span class=\"string\">'bitcore'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> Peer = bitcore.transport.Peer;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// default port</span></div><div class=\"line\"><span class=\"keyword\">var</span> livenetPeer = <span class=\"keyword\">new</span> Peer(<span class=\"string\">'5.9.85.34'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> testnetPeer = <span class=\"keyword\">new</span> Peer(<span class=\"string\">'5.9.85.34'</span>, bitcore.testnet);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// custom port</span></div><div class=\"line\"><span class=\"keyword\">var</span> livenetPeer = <span class=\"keyword\">new</span> Peer(<span class=\"string\">'5.9.85.34'</span>, <span class=\"number\">8334</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> testnetPeer = <span class=\"keyword\">new</span> Peer(<span class=\"string\">'5.9.85.34'</span>, <span class=\"number\">18334</span>, bitcore.testnet);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// use sock5 proxy (Tor)</span></div><div class=\"line\"><span class=\"keyword\">var</span> peer = <span class=\"keyword\">new</span> Peer(<span class=\"string\">'5.9.85.34'</span>).setProxy(<span class=\"string\">'localhost'</span>, <span class=\"number\">9050</span>);</div></pre></td></tr></table></figure>\n\n<h2 id=\"States\">States</h2>\n<p>A peer instance is always in one of the following states:</p>\n<ul>\n<li><code>disconnected</code>: No connection with the remote node.</li>\n<li><code>connecting</code>: While establishing the connection.</li>\n<li><code>connected</code>: Exchanging version packages.</li>\n<li><code>ready</code>: Connection ready for sending and receiving messages.</li>\n</ul>\n<p>You can subscribe to the change of those states as follows:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> bitcore = <span class=\"built_in\">require</span>(<span class=\"string\">'bitcore'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> Peer = bitcore.transport.Peer;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> peer = <span class=\"keyword\">new</span> Peer(<span class=\"string\">'5.9.85.34'</span>);</div><div class=\"line\"></div><div class=\"line\">peer.on(<span class=\"string\">'ready'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>{</div><div class=\"line\">  <span class=\"comment\">// peer info</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(peer.version, peer.subversion, peer.bestHeight);</div><div class=\"line\">});</div><div class=\"line\"></div><div class=\"line\">peer.on(<span class=\"string\">'disconnect'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>{</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'connection closed'</span>);</div><div class=\"line\">});</div><div class=\"line\"></div><div class=\"line\">peer.connect();</div></pre></td></tr></table></figure>\n\n<h2 id=\"Handle_messages\">Handle messages</h2>\n<p>Once connected, a peer instance can send and receive messages. Every time a message arrives it’s emitted as a new event. Let’s see an example of this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> bitcore = <span class=\"built_in\">require</span>(<span class=\"string\">'bitcore'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> peer = <span class=\"keyword\">new</span> bitcore.transport.Peer(<span class=\"string\">'5.9.85.34'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// handle events</span></div><div class=\"line\">peer.on(<span class=\"string\">'inv'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(message)</span> </span>{</div><div class=\"line\">  <span class=\"comment\">// message.inventory[]</span></div><div class=\"line\">});</div><div class=\"line\"></div><div class=\"line\">peer.on(<span class=\"string\">'tx'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(message)</span> </span>{</div><div class=\"line\">  <span class=\"comment\">// message.transaction</span></div><div class=\"line\">});</div><div class=\"line\"></div><div class=\"line\">peer.on(<span class=\"string\">'addr'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(message)</span> </span>{</div><div class=\"line\">  <span class=\"comment\">// message.addresses[]</span></div><div class=\"line\">});</div><div class=\"line\"></div><div class=\"line\">peer.connect();</div></pre></td></tr></table></figure>\n\n<h2 id=\"Sending_messages\">Sending messages</h2>\n<p>In order to send messages the Peer class offers the <code>sendMessage(message)</code> method, which receives an instance of a message. All supported messages can be found on the <code>bitcore.transport.Messages</code> module. For more information about messages refer to the <a href=\"https://en.bitcoin.it/wiki/Protocol_specification\" target=\"_blank\" rel=\"external\">protocol specification</a>.</p>\n<p>An example for requesting other connected nodes to a peers looks like this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> bitcore = <span class=\"built_in\">require</span>(<span class=\"string\">'bitcore'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> peer = <span class=\"keyword\">new</span> bitcore.transport.Peer(<span class=\"string\">'5.9.85.34'</span>);</div><div class=\"line\"></div><div class=\"line\">peer.on(<span class=\"string\">'ready'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>{</div><div class=\"line\">  <span class=\"keyword\">var</span> message = <span class=\"keyword\">new</span> bitcore.transport.Messages.GetAddresses();</div><div class=\"line\">  peer.sendMessage(message);</div><div class=\"line\">});</div><div class=\"line\"></div><div class=\"line\">peer.on(<span class=\"string\">'addr'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(message)</span> </span>{</div><div class=\"line\">  message.addresses.forEach(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(address)</span> </span>{</div><div class=\"line\">    <span class=\"comment\">// do something</span></div><div class=\"line\">  });</div><div class=\"line\">});</div><div class=\"line\"></div><div class=\"line\">peer.connect();</div></pre></td></tr></table></figure>\n\n","source":"guide/peer.md","raw":"# Peer\n\n## Description\n\nRepresents a node from the p2p bitcoin network. The Peer class supports connecting directly to other nodes or through a socks5 proxy like Tor.\n\n## Creating a peer\n\nThe code to create a new peer looks like this:\n\n```javascript\nvar bitcore = require('bitcore');\nvar Peer = bitcore.transport.Peer;\n\n// default port\nvar livenetPeer = new Peer('5.9.85.34');\nvar testnetPeer = new Peer('5.9.85.34', bitcore.testnet);\n\n// custom port\nvar livenetPeer = new Peer('5.9.85.34', 8334);\nvar testnetPeer = new Peer('5.9.85.34', 18334, bitcore.testnet);\n\n// use sock5 proxy (Tor)\nvar peer = new Peer('5.9.85.34').setProxy('localhost', 9050);\n```\n\n## States\n\nA peer instance is always in one of the following states:\n\n* `disconnected`: No connection with the remote node.\n* `connecting`: While establishing the connection.\n* `connected`: Exchanging version packages.\n* `ready`: Connection ready for sending and receiving messages.\n\nYou can subscribe to the change of those states as follows:\n\n```javascript\nvar bitcore = require('bitcore');\nvar Peer = bitcore.transport.Peer;\n\nvar peer = new Peer('5.9.85.34');\n\npeer.on('ready', function() {\n  // peer info\n  console.log(peer.version, peer.subversion, peer.bestHeight);\n});\n\npeer.on('disconnect', function() {\n  console.log('connection closed');\n});\n\npeer.connect();\n```\n\n## Handle messages\n\nOnce connected, a peer instance can send and receive messages. Every time a message arrives it's emitted as a new event. Let's see an example of this:\n\n```javascript\nvar bitcore = require('bitcore');\nvar peer = new bitcore.transport.Peer('5.9.85.34');\n\n// handle events\npeer.on('inv', function(message) {\n  // message.inventory[]\n});\n\npeer.on('tx', function(message) {\n  // message.transaction\n});\n\npeer.on('addr', function(message) {\n  // message.addresses[]\n});\n\npeer.connect();\n```\n\n## Sending messages\n\nIn order to send messages the Peer class offers the `sendMessage(message)` method, which receives an instance of a message. All supported messages can be found on the `bitcore.transport.Messages` module. For more information about messages refer to the [protocol specification](https://en.bitcoin.it/wiki/Protocol_specification).\n\nAn example for requesting other connected nodes to a peers looks like this:\n\n```javascript\nvar bitcore = require('bitcore');\nvar peer = new bitcore.transport.Peer('5.9.85.34');\n\npeer.on('ready', function() {\n  var message = new bitcore.transport.Messages.GetAddresses();\n  peer.sendMessage(message);\n});\n\npeer.on('addr', function(message) {\n  message.addresses.forEach(function(address) {\n    // do something\n  });\n});\n\npeer.connect();\n```\n","date":1419285019000,"updated":1419285019000,"path":"guide/peer.html","excerpt":"","_id":"aefucgd8dz469tqc","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"Private_Key\">Private Key</h1>\n<h2 id=\"Description\">Description</h2>\n<p>Represents a bitcoin private key and is needed to be able to spend bitcoin and sign transactions. See the official <a href=\"https://en.bitcoin.it/wiki/Private_key\" target=\"_blank\" rel=\"external\">Bitcoin Wiki</a> for more information about private keys. A PrivateKey in Bitcore is an immutable object that has methods to import and export into a variety of formats including <a href=\"https://en.bitcoin.it/wiki/Wallet_import_format\" target=\"_blank\" rel=\"external\">Wallet Import Format</a>.</p>\n<h2 id=\"Instantiate_a_Private_Key\">Instantiate a Private Key</h2>\n<p>Here is how to create a new private key. It will generate a new random number using <code>window.crypto</code> or the Node.js <code>crypto</code> library.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> privateKey = <span class=\"keyword\">new</span> PrivateKey();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Creates a private key from a hexa encoded number</span></div><div class=\"line\"><span class=\"keyword\">var</span> privateKey2 = <span class=\"keyword\">new</span> PrivateKey(<span class=\"string\">'b221d9dbb083a7f33428d7c2a3c3198ae925614d70210e28716ccaa7cd4ddb79'</span>);</div></pre></td></tr></table></figure>\n\n<p>To export and import a private key, you can do the following:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// encode into wallet export format</span></div><div class=\"line\"><span class=\"keyword\">var</span> exported = privateKey.toWIF();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// instantiate from the exported (and saved) private key</span></div><div class=\"line\"><span class=\"keyword\">var</span> imported = PrivateKey.fromWIF(<span class=\"string\">'L3T1s1TYP9oyhHpXgkyLoJFGniEgkv2Jhi138d7R2yJ9F4QdDU2m'</span>);</div></pre></td></tr></table></figure>\n\n<p>Note: The WIF (Wallet Import Format) includes information about the network and if the associated public key is compressed or uncompressed (thus the same bitcoin address will be generated by using this format).</p>\n<p>To generate an Address or PublicKey from a PrivateKey:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> publicKey = privateKey.toPublicKey();</div><div class=\"line\"><span class=\"keyword\">var</span> address = publicKey.toAddress(Networks.livenet);</div></pre></td></tr></table></figure>\n\n<h2 id=\"Validating_a_Private_Key\">Validating a Private Key</h2>\n<p>The code to do these validations looks like this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// validate an address</span></div><div class=\"line\"><span class=\"keyword\">if</span> (PrivateKey.isValid(input)){</div><div class=\"line\">  ...</div><div class=\"line\">}</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// get the specific validation error that can occurred</span></div><div class=\"line\"><span class=\"keyword\">var</span> error = PrivateKey.getValidationError(input, Networks.livenet);</div><div class=\"line\"><span class=\"keyword\">if</span> (error) {</div><div class=\"line\">  <span class=\"comment\">// handle the error</span></div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n","source":"guide/privatekey.md","raw":"# Private Key\n\n## Description\n\nRepresents a bitcoin private key and is needed to be able to spend bitcoin and sign transactions. See the official [Bitcoin Wiki](https://en.bitcoin.it/wiki/Private_key) for more information about private keys. A PrivateKey in Bitcore is an immutable object that has methods to import and export into a variety of formats including [Wallet Import Format](https://en.bitcoin.it/wiki/Wallet_import_format).\n\n## Instantiate a Private Key\n\nHere is how to create a new private key. It will generate a new random number using `window.crypto` or the Node.js `crypto` library.\n\n```javascript\nvar privateKey = new PrivateKey();\n\n// Creates a private key from a hexa encoded number\nvar privateKey2 = new PrivateKey('b221d9dbb083a7f33428d7c2a3c3198ae925614d70210e28716ccaa7cd4ddb79'); \n```\n\nTo export and import a private key, you can do the following:\n\n```javascript\n// encode into wallet export format\nvar exported = privateKey.toWIF();\n\n// instantiate from the exported (and saved) private key\nvar imported = PrivateKey.fromWIF('L3T1s1TYP9oyhHpXgkyLoJFGniEgkv2Jhi138d7R2yJ9F4QdDU2m');\n```\n\nNote: The WIF (Wallet Import Format) includes information about the network and if the associated public key is compressed or uncompressed (thus the same bitcoin address will be generated by using this format).\n\nTo generate an Address or PublicKey from a PrivateKey:\n\n```javascript\nvar publicKey = privateKey.toPublicKey();\nvar address = publicKey.toAddress(Networks.livenet);\n```\n\n## Validating a Private Key\n\nThe code to do these validations looks like this:\n\n```javascript\n// validate an address\nif (PrivateKey.isValid(input)){\n  ...\n}\n\n// get the specific validation error that can occurred\nvar error = PrivateKey.getValidationError(input, Networks.livenet);\nif (error) {\n  // handle the error\n}\n```\n","date":1419285020000,"updated":1419285020000,"path":"guide/privatekey.html","excerpt":"","_id":"mogr0chtuw5997vp","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"Pool\">Pool</h1>\n<h2 id=\"Pool-1\">Pool</h2>\n<p>A pool maintains a connection of <a href=\"peer.md\">Peers</a>. A pool will discover peers via DNS seeds, as well as when peer addresses are announced through the network.</p>\n<p>The quickest way to get connected is to run the following:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> bitcore = <span class=\"built_in\">require</span>(<span class=\"string\">'bitcore'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> Pool = bitcore.transport.Pool;</div><div class=\"line\"><span class=\"keyword\">var</span> Networks = bitcore.Networks;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> pool = <span class=\"keyword\">new</span> Pool(Networks.livenet);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// connect to the network</span></div><div class=\"line\">pool.connect();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// attach peer events</span></div><div class=\"line\">pool.on(<span class=\"string\">'peerinv'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(peer, message)</span> </span>{</div><div class=\"line\">  <span class=\"comment\">// a new peer message has arrived</span></div><div class=\"line\">});</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// will disconnect all peers</span></div><div class=\"line\">pool.disconnect()</div></pre></td></tr></table></figure>\n\n<p>For more information about Peer events, please read the <a href=\"peer.md\">Peer</a> documentation. Peer events are relayed to the pool, a peer event <code>inv</code> in the pool would be <code>peerinv</code>. When a peer is disconnected the pool will try to connect to the list of known addresses to maintain connection.</p>\n","source":"guide/pool.md","raw":"# Pool\n\n## Pool\n\nA pool maintains a connection of [Peers](peer.md). A pool will discover peers via DNS seeds, as well as when peer addresses are announced through the network.\n\nThe quickest way to get connected is to run the following:\n\n```javascript\n\nvar bitcore = require('bitcore');\nvar Pool = bitcore.transport.Pool;\nvar Networks = bitcore.Networks;\n\nvar pool = new Pool(Networks.livenet);\n\n// connect to the network\npool.connect();\n\n// attach peer events\npool.on('peerinv', function(peer, message) {\n  // a new peer message has arrived\n});\n\n// will disconnect all peers\npool.disconnect()\n\n```\n\nFor more information about Peer events, please read the [Peer](peer.md) documentation. Peer events are relayed to the pool, a peer event `inv` in the pool would be `peerinv`. When a peer is disconnected the pool will try to connect to the list of known addresses to maintain connection.\n","date":1419285019000,"updated":1419285019000,"path":"guide/pool.html","excerpt":"","_id":"j5qbt9mb4f843liv","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"Public_Key\">Public Key</h1>\n<h2 id=\"Description\">Description</h2>\n<p>Represents a bitcoin public key and is needed to be able to receive bitcoin, as is usually represented as a bitcoin <a href=\"address.md\">Address</a>, see the official <a href=\"https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses\" target=\"_blank\" rel=\"external\">Bitcoin Wiki</a>. A PublicKey in Bitcore is an immutable object and can be instantiated from a <a href=\"crypto.md\">Point</a>, string, <a href=\"privatekey.md\">PrivateKey</a>, Buffer and a <a href=\"crypto.md\">BN</a>.</p>\n<h2 id=\"Instantiate_a_Public_Key\">Instantiate a Public Key</h2>\n<p>Here is how to instantiate a public key:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> privateKey = <span class=\"keyword\">new</span> PrivateKey();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// from a private key</span></div><div class=\"line\"><span class=\"keyword\">var</span> publicKey = <span class=\"keyword\">new</span> PublicKey(privateKey);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// from a der hex encoded string</span></div><div class=\"line\"><span class=\"keyword\">var</span> publicKey2 = <span class=\"keyword\">new</span> PublicKey(<span class=\"string\">'02a1633cafcc01ebfb6d78e39f687a1f0995c62fc95f51ead10a02ee0be551b5dc'</span>);</div></pre></td></tr></table></figure>\n\n<h2 id=\"Validating_a_Public_Key\">Validating a Public Key</h2>\n<p>A public key point should be on the <a href=\"https://en.bitcoin.it/wiki/Secp256k1\" target=\"_blank\" rel=\"external\">secp256k1</a> curve, instantiating a new PublicKey will validate this and will throw an error if it’s invalid. To check that a public key is valid:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (PublicKey.isValid(<span class=\"string\">'02a1633cafcc01ebfb6d78e39f687a1f0995c62fc95f51ead10a02ee0be551b5dc'</span>)){</div><div class=\"line\">  <span class=\"comment\">// valid public key</span></div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>Note: It’s important to note that there are two possible ways to represent public key, the standard is <em>compressed</em> and includes the x value and parity (as represented above in the documentation). There is also a longer version that is <em>uncompressed</em> which includes both x and y values, and using this can generate a different bitcoin address, so it’s important to note this possibility, however it’s discouraged to be used.</p>\n","source":"guide/publickey.md","raw":"# Public Key\n\n## Description\n\nRepresents a bitcoin public key and is needed to be able to receive bitcoin, as is usually represented as a bitcoin [Address](address.md), see the official [Bitcoin Wiki](https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses). A PublicKey in Bitcore is an immutable object and can be instantiated from a [Point](crypto.md), string, [PrivateKey](privatekey.md), Buffer and a [BN](crypto.md).\n\n## Instantiate a Public Key\n\nHere is how to instantiate a public key:\n\n```javascript\n\nvar privateKey = new PrivateKey();\n\n// from a private key\nvar publicKey = new PublicKey(privateKey);\n\n// from a der hex encoded string\nvar publicKey2 = new PublicKey('02a1633cafcc01ebfb6d78e39f687a1f0995c62fc95f51ead10a02ee0be551b5dc');\n\n```\n\n## Validating a Public Key\n\nA public key point should be on the [secp256k1](https://en.bitcoin.it/wiki/Secp256k1) curve, instantiating a new PublicKey will validate this and will throw an error if it's invalid. To check that a public key is valid:\n\n```javascript\nif (PublicKey.isValid('02a1633cafcc01ebfb6d78e39f687a1f0995c62fc95f51ead10a02ee0be551b5dc')){\n  // valid public key\n}\n```\n\nNote: It's important to note that there are two possible ways to represent public key, the standard is *compressed* and includes the x value and parity (as represented above in the documentation). There is also a longer version that is *uncompressed* which includes both x and y values, and using this can generate a different bitcoin address, so it's important to note this possibility, however it's discouraged to be used.\n","date":1419285020000,"updated":1419285020000,"path":"guide/publickey.html","excerpt":"","_id":"qbpdmny4qz39vfbe","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"Script\">Script</h1>\n<h2 id=\"Description\">Description</h2>\n<p>All bitcoin transactions have scripts embedded into its inputs and outputs.  The scripts use a very simple programming language, which is evaluated from left to right using a stack. The language is designed such that it guarantees all scripts will execute in a limited amount of time (it is not Turing-Complete).</p>\n<p>When a transaction is validated, the input scripts are concatenated with the output scripts and evaluated. To be valid, all transaction scripts must evaluate to true.  A good analogy for how this works is that the output scripts are puzzles that specify in which conditions can those bitcoins be spent. The input scripts provide the correct data to make those output scripts evaluate to true.</p>\n<p>For more detailed information about the bitcoin scripting language, check the online reference <a href=\"https://en.bitcoin.it/wiki/Script\" target=\"_blank\" rel=\"external\">on bitcoin’s wiki</a>.</p>\n<p>The <code>Script</code> object provides an interface to construct, parse, and identify bitcoin scripts. It also gives simple interfaces to create most common script types. This class is useful if you want to create custom input or output scripts. In other case, you should probably use <code>Transaction</code>.</p>\n<h2 id=\"Script_creation\">Script creation</h2>\n<p>Here’s how to use <code>Script</code> to create the five most common script types:</p>\n<h3 id=\"Pay_to_Public_Key_Hash_(p2pkh)\">Pay to Public Key Hash (p2pkh)</h3>\n<p>This is the most commonly used transaction output script. It’s used to pay to a bitcoin address (a bitcoin address is a public key hash encoded in base58check)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// create a new p2pkh paying to a specific address</span></div><div class=\"line\"><span class=\"keyword\">var</span> address = Address.fromString(<span class=\"string\">'1NaTVwXDDUJaXDQajoa9MqHhz4uTxtgK14'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> script = Script.buildPublicKeyHashOut(address);</div><div class=\"line\">assert(script.toString() === <span class=\"string\">'OP_DUP OP_HASH160 20 0xecae7d092947b7ee4998e254aa48900d26d2ce1d OP_EQUALVERIFY OP_CHECKSIG'</span>);</div></pre></td></tr></table></figure>\n\n<h3 id=\"Pay_to_Public_Key_(p2pk)\">Pay to Public Key (p2pk)</h3>\n<p>Pay to public key scripts are a simplified form of the p2pkh, but aren’t commonly used in new transactions anymore, because p2pkh scripts are more secure (the public key is not revealed until the output is spent). </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// create a new p2pk paying to a specific public key</span></div><div class=\"line\"><span class=\"keyword\">var</span> pubkey = <span class=\"keyword\">new</span> PublicKey(<span class=\"string\">'022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> script = Script.buildPublicKeyOut(pubkey);</div><div class=\"line\">assert(script.toString() === <span class=\"string\">'33 0x022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da OP_CHECKSIG'</span>);</div></pre></td></tr></table></figure>\n\n<h3 id=\"Pay_to_Multisig_(p2ms)\">Pay to Multisig (p2ms)</h3>\n<p>Multisig outputs allow to share control of bitcoins between several keys. When creating the script, one specifies the public keys that control the funds, and how many of those keys are required to sign off spending transactions to be valid. An output with N public keys of which M are required is called an m-of-n output (For example, 2-of-3, 3-of-5, 4-of-4, etc.)</p>\n<p>Note that regular multisig outputs are rarely used nowadays. The best practice is to use a p2sh multisig output (See Script#toScriptHashOut()).</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// create a new 2-of-3 multisig output from 3 given public keys</span></div><div class=\"line\"><span class=\"keyword\">var</span> pubkeys = [</div><div class=\"line\">  <span class=\"keyword\">new</span> PublicKey(<span class=\"string\">'022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da'</span>),</div><div class=\"line\">  <span class=\"keyword\">new</span> PublicKey(<span class=\"string\">'03e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e9'</span>),</div><div class=\"line\">  <span class=\"keyword\">new</span> PublicKey(<span class=\"string\">'021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc18'</span>),</div><div class=\"line\">];</div><div class=\"line\"><span class=\"keyword\">var</span> threshold = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> script = Script.buildMultisigOut(pubkeys, threshold);</div><div class=\"line\">assert(script.toString() === <span class=\"string\">'OP_2 33 0x022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da'</span></div><div class=\"line\">      + <span class=\"string\">' 33 0x03e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e9'</span></div><div class=\"line\">      + <span class=\"string\">' 33 0x021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc18 OP_3 OP_CHECKMULTISIG'</span>);</div></pre></td></tr></table></figure>\n\n<h3 id=\"Pay_to_Script_Hash_(p2sh)\">Pay to Script Hash (p2sh)</h3>\n<p>Pay to script hash outputs are scripts that contain the hash of another script, called <code>redeemScript</code>. To spend bitcoins sent in a p2sh output, the spending transaction must provide a script matching the script hash and data which makes the script evaluate to true.  This allows to defer revealing the spending conditions to the moment of spending. It also makes it possible for the receiver to set the conditions to spend those bitcoins. </p>\n<p>Most multisig transactions today use p2sh outputs where the redeemScript is a multisig output.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// create a p2sh multisig output</span></div><div class=\"line\"><span class=\"keyword\">var</span> pubkeys = [</div><div class=\"line\">  <span class=\"keyword\">new</span> PublicKey(<span class=\"string\">'022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da'</span>),</div><div class=\"line\">  <span class=\"keyword\">new</span> PublicKey(<span class=\"string\">'03e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e9'</span>),</div><div class=\"line\">  <span class=\"keyword\">new</span> PublicKey(<span class=\"string\">'021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc18'</span>),</div><div class=\"line\">];</div><div class=\"line\"><span class=\"keyword\">var</span> redeemScript = Script.buildMultisigOut(pubkeys, <span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> script = redeemScript.toScriptHashOut();</div><div class=\"line\">assert(script.toString() === <span class=\"string\">'OP_HASH160 20 0x620a6eeaf538ec9eb89b6ae83f2ed8ef98566a03 OP_EQUAL'</span>);</div></pre></td></tr></table></figure>\n\n<h3 id=\"Data_output\">Data output</h3>\n<p>Data outputs are used to push data into the blockchain. Up to 40 bytes can be pushed in a standard way, but more data can be used, if a miner decides to accept the transaction.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"string\">'hello world!!!'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> script = Script.buildDataOut(data);</div><div class=\"line\">assert(script.toString() === <span class=\"string\">'OP_RETURN 14 0x68656c6c6f20776f726c64212121'</span></div></pre></td></tr></table></figure>\n\n<h3 id=\"Custom_Scripts\">Custom Scripts</h3>\n<p>To create a custom <code>Script</code> instance, you must rely on the lower-level methods <code>add</code> and <code>prepend</code>. Both methods accept the same parameter types, and insert an opcode or data at the beginning (<code>prepend</code>) or end (<code>add</code>) of the <code>Script</code>.</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> script = Script()</div><div class=\"line\">  .<span class=\"keyword\">add</span>(<span class=\"string\">'OP_IF'</span>)                       <span class=\"comment\">// add an opcode by name</span></div><div class=\"line\">  .prepend(<span class=\"number\">114</span>)                       <span class=\"comment\">// add OP_2SWAP by code</span></div><div class=\"line\">  .<span class=\"keyword\">add</span>(Opcode.OP_NOT)                 <span class=\"comment\">// add an opcode object</span></div><div class=\"line\">  .<span class=\"keyword\">add</span>(<span class=\"keyword\">new</span> Buffer(<span class=\"string\">'bacacafe'</span>, <span class=\"string\">'hex'</span>)) <span class=\"comment\">// add a data buffer (will append the size of the push operation first)</span></div><div class=\"line\"></div><div class=\"line\">assert(script.toString() === <span class=\"string\">'OP_2SWAP OP_IF OP_NOT 4 0xbacacafe'</span>);</div></pre></td></tr></table></figure>\n\n<h2 id=\"Script_Parsing_and_Identification\">Script Parsing and Identification</h2>\n<p><code>Script</code> has an easy interface to parse raw scripts from the network or bitcoind, and to extract useful information. An illustrative example (for more options check the API reference)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> raw_script = <span class=\"keyword\">new</span> Buffer(<span class=\"string\">'5221022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da2103e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e921021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc1853ae'</span>, <span class=\"string\">'hex'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> Script(raw_script);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(s.toString());</div><div class=\"line\"><span class=\"comment\">// 'OP_2 33 0x022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da 33 0x03e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e9 33 0x021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc18 OP_3 OP_CHECKMULTISIG'</span></div><div class=\"line\"></div><div class=\"line\">s.isPublicKeyHashOut() <span class=\"comment\">// false</span></div><div class=\"line\">s.isScriptHashOut() <span class=\"comment\">// false</span></div><div class=\"line\">s.isMultisigOut() <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n\n<h2 id=\"Script_Interpreting_and_Validation\">Script Interpreting and Validation</h2>\n<p>To validate a transaction, the bitcoin network validates all of its inputs and outputs. To validate an input, the input’s script is concatenated with the referenced output script, and the result is executed. If at the end of execution the stack contains a ‘true’ value, then the transaction is valid.<br>You can do this in <code>bitcore</code> by using the <code>Interpreter</code> class. The entry point (and probably the only interface you’ll need for most applications) is the method <code>Interpreter#verify()</code>.</p>\n<p>You can use it like this:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> inputScript = Script(<span class=\"string\">'OP_1'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> outputScript = Script(<span class=\"string\">'OP_15 OP_ADD OP_16 OP_EQUAL'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> verified = Interpreter().verify(inputScript, outputScript);</div><div class=\"line\"><span class=\"comment\">// verified will be true</span></div></pre></td></tr></table></figure>\n\n<p>Note that <code>verify</code> expects two scripts: one is the input script (scriptSig) and the other is the output script (scriptPubkey). This is because different conditions are checked for each.</p>\n<p>It also accepts some optional parameters, assuming defaults if not provided:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// first we create a transaction</span></div><div class=\"line\"><span class=\"keyword\">var</span> tx = <span class=\"keyword\">new</span> Transaction()</div><div class=\"line\">  .<span class=\"keyword\">from</span>(utxo)</div><div class=\"line\">  .<span class=\"keyword\">to</span>(toAddress, <span class=\"number\">100000</span>)</div><div class=\"line\">  .sign(privateKey);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// we then extract the signature from the first input</span></div><div class=\"line\"><span class=\"keyword\">var</span> inputIndex = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> signature = tx.getSignatures(privateKey)[inputIndex].signature;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> scriptSig = Script.buildPublicKeyHashIn(publicKey, signature);</div><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">flags</span> = Interpreter.SCRIPT_VERIFY_P2SH | Interpreter.SCRIPT_VERIFY_STRICTENC;</div><div class=\"line\"><span class=\"keyword\">var</span> verified = Interpreter().verify(scriptSig, scriptPubkey, tx, inputIndex, <span class=\"keyword\">flags</span>);</div></pre></td></tr></table></figure>\n\n","source":"guide/script.md","raw":"# Script\n\n## Description\n\nAll bitcoin transactions have scripts embedded into its inputs and outputs.  The scripts use a very simple programming language, which is evaluated from left to right using a stack. The language is designed such that it guarantees all scripts will execute in a limited amount of time (it is not Turing-Complete).\n\nWhen a transaction is validated, the input scripts are concatenated with the output scripts and evaluated. To be valid, all transaction scripts must evaluate to true.  A good analogy for how this works is that the output scripts are puzzles that specify in which conditions can those bitcoins be spent. The input scripts provide the correct data to make those output scripts evaluate to true.\n\n\nFor more detailed information about the bitcoin scripting language, check the online reference [on bitcoin's wiki](https://en.bitcoin.it/wiki/Script).\n\nThe `Script` object provides an interface to construct, parse, and identify bitcoin scripts. It also gives simple interfaces to create most common script types. This class is useful if you want to create custom input or output scripts. In other case, you should probably use `Transaction`.\n\n## Script creation\n\nHere's how to use `Script` to create the five most common script types:\n\n### Pay to Public Key Hash (p2pkh)\n\nThis is the most commonly used transaction output script. It's used to pay to a bitcoin address (a bitcoin address is a public key hash encoded in base58check)\n\n```javascript\n// create a new p2pkh paying to a specific address\nvar address = Address.fromString('1NaTVwXDDUJaXDQajoa9MqHhz4uTxtgK14');\nvar script = Script.buildPublicKeyHashOut(address);\nassert(script.toString() === 'OP_DUP OP_HASH160 20 0xecae7d092947b7ee4998e254aa48900d26d2ce1d OP_EQUALVERIFY OP_CHECKSIG');\n```\n### Pay to Public Key (p2pk)\n\nPay to public key scripts are a simplified form of the p2pkh, but aren’t commonly used in new transactions anymore, because p2pkh scripts are more secure (the public key is not revealed until the output is spent). \n\n```javascript\n// create a new p2pk paying to a specific public key\nvar pubkey = new PublicKey('022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da');\nvar script = Script.buildPublicKeyOut(pubkey);\nassert(script.toString() === '33 0x022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da OP_CHECKSIG');\n```\n\n### Pay to Multisig (p2ms)\n\nMultisig outputs allow to share control of bitcoins between several keys. When creating the script, one specifies the public keys that control the funds, and how many of those keys are required to sign off spending transactions to be valid. An output with N public keys of which M are required is called an m-of-n output (For example, 2-of-3, 3-of-5, 4-of-4, etc.)\n\nNote that regular multisig outputs are rarely used nowadays. The best practice is to use a p2sh multisig output (See Script#toScriptHashOut()).\n\n```javascript\n// create a new 2-of-3 multisig output from 3 given public keys\nvar pubkeys = [\n  new PublicKey('022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da'),\n  new PublicKey('03e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e9'),\n  new PublicKey('021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc18'),\n];\nvar threshold = 2;\nvar script = Script.buildMultisigOut(pubkeys, threshold);\nassert(script.toString() === 'OP_2 33 0x022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da'\n      + ' 33 0x03e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e9'\n      + ' 33 0x021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc18 OP_3 OP_CHECKMULTISIG');\n```\n\n### Pay to Script Hash (p2sh)\n\nPay to script hash outputs are scripts that contain the hash of another script, called `redeemScript`. To spend bitcoins sent in a p2sh output, the spending transaction must provide a script matching the script hash and data which makes the script evaluate to true.  This allows to defer revealing the spending conditions to the moment of spending. It also makes it possible for the receiver to set the conditions to spend those bitcoins. \n\nMost multisig transactions today use p2sh outputs where the redeemScript is a multisig output.\n\n```javascript\n// create a p2sh multisig output\nvar pubkeys = [\n  new PublicKey('022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da'),\n  new PublicKey('03e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e9'),\n  new PublicKey('021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc18'),\n];\nvar redeemScript = Script.buildMultisigOut(pubkeys, 2);\nvar script = redeemScript.toScriptHashOut();\nassert(script.toString() === 'OP_HASH160 20 0x620a6eeaf538ec9eb89b6ae83f2ed8ef98566a03 OP_EQUAL');\n```\n### Data output\n\nData outputs are used to push data into the blockchain. Up to 40 bytes can be pushed in a standard way, but more data can be used, if a miner decides to accept the transaction.\n\n```javascript\nvar data = 'hello world!!!';\nvar script = Script.buildDataOut(data);\nassert(script.toString() === 'OP_RETURN 14 0x68656c6c6f20776f726c64212121'\n```\n\n### Custom Scripts\n\nTo create a custom `Script` instance, you must rely on the lower-level methods `add` and `prepend`. Both methods accept the same parameter types, and insert an opcode or data at the beginning (`prepend`) or end (`add`) of the `Script`.\n\n```\nvar script = Script()\n  .add('OP_IF')                       // add an opcode by name\n  .prepend(114)                       // add OP_2SWAP by code\n  .add(Opcode.OP_NOT)                 // add an opcode object\n  .add(new Buffer('bacacafe', 'hex')) // add a data buffer (will append the size of the push operation first)\n\nassert(script.toString() === 'OP_2SWAP OP_IF OP_NOT 4 0xbacacafe');\n```\n\n## Script Parsing and Identification\n\n`Script` has an easy interface to parse raw scripts from the network or bitcoind, and to extract useful information. An illustrative example (for more options check the API reference)\n\n```javascript\nvar raw_script = new Buffer('5221022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da2103e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e921021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc1853ae', 'hex');\nvar s = new Script(raw_script);\nconsole.log(s.toString());\n// 'OP_2 33 0x022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da 33 0x03e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e9 33 0x021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc18 OP_3 OP_CHECKMULTISIG'\n\ns.isPublicKeyHashOut() // false\ns.isScriptHashOut() // false\ns.isMultisigOut() // true\n```\n\n## Script Interpreting and Validation\n\nTo validate a transaction, the bitcoin network validates all of its inputs and outputs. To validate an input, the input's script is concatenated with the referenced output script, and the result is executed. If at the end of execution the stack contains a 'true' value, then the transaction is valid.\nYou can do this in `bitcore` by using the `Interpreter` class. The entry point (and probably the only interface you'll need for most applications) is the method `Interpreter#verify()`.\n\nYou can use it like this:\n\n```\nvar inputScript = Script('OP_1');\nvar outputScript = Script('OP_15 OP_ADD OP_16 OP_EQUAL');\n\nvar verified = Interpreter().verify(inputScript, outputScript);\n// verified will be true\n```\n\nNote that `verify` expects two scripts: one is the input script (scriptSig) and the other is the output script (scriptPubkey). This is because different conditions are checked for each.\n\nIt also accepts some optional parameters, assuming defaults if not provided:\n```\n// first we create a transaction\nvar tx = new Transaction()\n  .from(utxo)\n  .to(toAddress, 100000)\n  .sign(privateKey);\n\n// we then extract the signature from the first input\nvar inputIndex = 0;\nvar signature = tx.getSignatures(privateKey)[inputIndex].signature;\n\nvar scriptSig = Script.buildPublicKeyHashIn(publicKey, signature);\nvar flags = Interpreter.SCRIPT_VERIFY_P2SH | Interpreter.SCRIPT_VERIFY_STRICTENC;\nvar verified = Interpreter().verify(scriptSig, scriptPubkey, tx, inputIndex, flags);\n```\n","date":1419285020000,"updated":1419285020000,"path":"guide/script.html","excerpt":"","_id":"51suf0nzfxk91ri0","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"Transaction\">Transaction</h1>\n<h2 id=\"Description\">Description</h2>\n<p>Bitcore provides a very simple API for creating transactions. We expect this API to be accessible for developers without knowing the working internals of bitcoin in deep detail. What follows is a small introduction to transactions with some basic knowledge required to use this API.</p>\n<p>A Transaction contains a set of inputs and a set of outputs. Each input contains a reference to another transaction’s output, and a signature that allows the value referenced in that ouput to be used in this transaction.</p>\n<p>Note also that an output can be used only once. That’s why there’s a concept of “change address” in the bitcoin ecosystem: if an output of 10 BTC is available for me to spend, but I only need to transmit 1 BTC, I’ll create a transaction with two outputs, one with 1 BTC that I want to spend, and the other with 9 BTC to a change address, so I can spend this 9 BTC with another private key that I own.</p>\n<p>So, in order to transmit a valid transaction, you must know what other transactions on the network store outputs that have not been spent and that are available for you to spend (meaning that you have the set of keys that can validate you own those funds). The unspent outputs are usually referred to as “utxo”s.</p>\n<p>Let’s take a look at some very simple transactions:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> transaction = <span class=\"keyword\">new</span> Transaction()</div><div class=\"line\">    .from(utxos)          <span class=\"comment\">// Feed information about what unspend outputs one can use</span></div><div class=\"line\">    .to(address, amount)  <span class=\"comment\">// Add an output with the given amount of satoshis</span></div><div class=\"line\">    .change(address)      <span class=\"comment\">// Sets up a change address where the rest of the funds will go</span></div><div class=\"line\">    .sign(privkeySet)     <span class=\"comment\">// Signs all the inputs it can</span></div></pre></td></tr></table></figure>\n\n<p>Now, this could just be serialized to hexadecimal ASCII values (<code>transaction.serialize()</code>) and sent over to the bitcoind reference client.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bitcoin-cli sendrawtransaction &lt;serialized transaction&gt;</div></pre></td></tr></table></figure>\n\n<p>You can also override the fee estimation with another amount, specified in satoshis:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> transaction = <span class=\"keyword\">new</span> Transaction().fee(<span class=\"number\">5430</span>); <span class=\"comment\">// Minimum non-dust amount</span></div><div class=\"line\"><span class=\"keyword\">var</span> transaction = <span class=\"keyword\">new</span> Transaction().fee(<span class=\"number\">1e8</span>);  <span class=\"comment\">// Generous fee of 1 BTC</span></div></pre></td></tr></table></figure>\n\n<h2 id=\"Transaction_API\">Transaction API</h2>\n<h2 id=\"Input\">Input</h2>\n<p>Transaction inputs are instances of either <a href=\"https://github.com/bitpay/bitcore/tree/master/lib/transaction/input\" target=\"_blank\" rel=\"external\">Input</a> or its subclasses.</p>\n<h2 id=\"Output\">Output</h2>\n<p>Transaction outputs are a very thin wrapper around the information provided by a transaction output: its script and its output amount.</p>\n<h2 id=\"Multisig_Transactions\">Multisig Transactions</h2>\n<p>To send a transaction to a multisig address, the API is the same as in the above example. To spend outputs that require multiple signatures, the process needs extra information: the public keys of the signers that can unlock that output.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> multiSigTx = <span class=\"keyword\">new</span> Transaction()</div><div class=\"line\">    .from(utxo, publicKeys, threshold)</div><div class=\"line\">    .change(address)</div><div class=\"line\">    .sign(myKeys);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> serialized = multiSigTx.serialize();</div></pre></td></tr></table></figure>\n\n<p>This can be serialized and sent to another party, to complete with the needed signatures:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> multiSigTx = <span class=\"keyword\">new</span> Transaction(serialized)</div><div class=\"line\">    .from(utxo, publicKeys, threshold)       <span class=\"comment\">// provide info about the multisig output</span></div><div class=\"line\">                                             <span class=\"comment\">// (lost on serialization)</span></div><div class=\"line\">    .sign(anotherSetOfKeys);</div><div class=\"line\"></div><div class=\"line\">assert(multiSigTx.isFullySigned());</div></pre></td></tr></table></figure>\n\n<h2 id=\"Advanced_topics\">Advanced topics</h2>\n<h3 id=\"Internal_Workings\">Internal Workings</h3>\n<p>There are a number of data structures being stored internally in a <code>Transaction</code> instance. These are kept up to date and change through successive calls to its methods.</p>\n<ul>\n<li><code>inputs</code>: The ordered set of inputs for this transaction</li>\n<li><code>outputs</code>: This is the ordered set of output scripts</li>\n<li><code>_inputAmount</code>: sum of the amount for all the inputs</li>\n<li><code>_outputAmount</code>: sum of the amount for all the outputs</li>\n<li><code>_fee</code>: if user specified a non-standard fee, the amount (in satoshis) will be stored in this variable so the change amount can be calculated.</li>\n<li><code>_change</code>: stores the value provided by calling the <code>change</code> method.</li>\n</ul>\n<h3 id=\"Unspent_Output_Selection\">Unspent Output Selection</h3>\n<p>If you have a larger set of unspent outputs, only some of them will be selected to fulfill the amount. This is done by storing a cache of unspent outputs in a protected member called <code>_utxos</code>. When the <code>to()</code> method is called, some of these outputs will be selected to pay the requested amount to the appropriate address.</p>\n<p>A detail that you should have in mind is that when the transaction is serialized, this cache can’t be included in the serialized form.</p>\n<h2 id=\"Upcoming_changes\">Upcoming changes</h2>\n<p>We’re debating an API for Merge Avoidance, CoinJoin, Smart contracts, CoinSwap, and Stealth Addresses. We’re expecting to have all of them by some time in early 2015. First draft implementations of Payment Channel smart contracts extensions to this library are already being implemented independently.</p>\n","source":"guide/transaction.md","raw":"# Transaction\n\n## Description\n\nBitcore provides a very simple API for creating transactions. We expect this API to be accessible for developers without knowing the working internals of bitcoin in deep detail. What follows is a small introduction to transactions with some basic knowledge required to use this API.\n\nA Transaction contains a set of inputs and a set of outputs. Each input contains a reference to another transaction's output, and a signature that allows the value referenced in that ouput to be used in this transaction.\n\nNote also that an output can be used only once. That's why there's a concept of \"change address\" in the bitcoin ecosystem: if an output of 10 BTC is available for me to spend, but I only need to transmit 1 BTC, I'll create a transaction with two outputs, one with 1 BTC that I want to spend, and the other with 9 BTC to a change address, so I can spend this 9 BTC with another private key that I own.\n\nSo, in order to transmit a valid transaction, you must know what other transactions on the network store outputs that have not been spent and that are available for you to spend (meaning that you have the set of keys that can validate you own those funds). The unspent outputs are usually referred to as \"utxo\"s.\n\nLet's take a look at some very simple transactions:\n\n```javascript\nvar transaction = new Transaction()\n    .from(utxos)          // Feed information about what unspend outputs one can use\n    .to(address, amount)  // Add an output with the given amount of satoshis\n    .change(address)      // Sets up a change address where the rest of the funds will go\n    .sign(privkeySet)     // Signs all the inputs it can\n```\n\nNow, this could just be serialized to hexadecimal ASCII values (`transaction.serialize()`) and sent over to the bitcoind reference client.\n\n```bash\nbitcoin-cli sendrawtransaction <serialized transaction>\n```\n\nYou can also override the fee estimation with another amount, specified in satoshis:\n```javascript\nvar transaction = new Transaction().fee(5430); // Minimum non-dust amount\nvar transaction = new Transaction().fee(1e8);  // Generous fee of 1 BTC\n```\n\n## Transaction API\n\n## Input\n\nTransaction inputs are instances of either [Input](https://github.com/bitpay/bitcore/tree/master/lib/transaction/input) or its subclasses.\n\n## Output\n\nTransaction outputs are a very thin wrapper around the information provided by a transaction output: its script and its output amount.\n\n## Multisig Transactions\n\nTo send a transaction to a multisig address, the API is the same as in the above example. To spend outputs that require multiple signatures, the process needs extra information: the public keys of the signers that can unlock that output.\n\n```javascript\n  var multiSigTx = new Transaction()\n      .from(utxo, publicKeys, threshold)\n      .change(address)\n      .sign(myKeys);\n\n  var serialized = multiSigTx.serialize();\n```\n\nThis can be serialized and sent to another party, to complete with the needed signatures:\n\n```javascript\n  var multiSigTx = new Transaction(serialized)\n      .from(utxo, publicKeys, threshold)       // provide info about the multisig output\n                                               // (lost on serialization)\n      .sign(anotherSetOfKeys);\n\n  assert(multiSigTx.isFullySigned());\n```\n\n## Advanced topics\n\n### Internal Workings\n\nThere are a number of data structures being stored internally in a `Transaction` instance. These are kept up to date and change through successive calls to its methods.\n\n* `inputs`: The ordered set of inputs for this transaction\n* `outputs`: This is the ordered set of output scripts\n* `_inputAmount`: sum of the amount for all the inputs\n* `_outputAmount`: sum of the amount for all the outputs\n* `_fee`: if user specified a non-standard fee, the amount (in satoshis) will be stored in this variable so the change amount can be calculated.\n* `_change`: stores the value provided by calling the `change` method.\n\n### Unspent Output Selection\n\nIf you have a larger set of unspent outputs, only some of them will be selected to fulfill the amount. This is done by storing a cache of unspent outputs in a protected member called `_utxos`. When the `to()` method is called, some of these outputs will be selected to pay the requested amount to the appropriate address.\n\nA detail that you should have in mind is that when the transaction is serialized, this cache can't be included in the serialized form.\n\n## Upcoming changes\n\nWe're debating an API for Merge Avoidance, CoinJoin, Smart contracts, CoinSwap, and Stealth Addresses. We're expecting to have all of them by some time in early 2015. First draft implementations of Payment Channel smart contracts extensions to this library are already being implemented independently.\n","date":1419285021000,"updated":1419285021000,"path":"guide/transaction.html","excerpt":"","_id":"ybjt9xsdddd6xg7o","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"Unit\">Unit</h1>\n<h2 id=\"Description\">Description</h2>\n<p>Unit is an utility for handling and converting bitcoin units. We strongly recommend to always use satoshis to represent amount inside your application and only convert them to other units in the front-end.</p>\n<h2 id=\"Supported_units\">Supported units</h2>\n<p>The supported units are BTC, mBTC, bits (micro BTCs, uBTC) and satoshis. The codes for each unit can be found as members of the Unit class.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> btcCode = Unit.BTC;</div><div class=\"line\"><span class=\"keyword\">var</span> mbtcCode = Unit.mBTC;</div><div class=\"line\"><span class=\"keyword\">var</span> ubtcCode = Unit.uBTC;</div><div class=\"line\"><span class=\"keyword\">var</span> bitsCode = Unit.bits;</div><div class=\"line\"><span class=\"keyword\">var</span> satsCode = Unit.satoshis;</div></pre></td></tr></table></figure>\n\n<h2 id=\"Creating_units\">Creating units</h2>\n<p>There are two ways for creating a unit instance. You can instantiate the class using a value and a unit code; alternatively if the unit it’s fixed you could you some of the static methods. Check some examples below:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> unit;</div><div class=\"line\"><span class=\"keyword\">var</span> amount = <span class=\"number\">100</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// using a unit code</span></div><div class=\"line\"><span class=\"keyword\">var</span> unitPreference = Unit.BTC;</div><div class=\"line\">unit = <span class=\"keyword\">new</span> Unit(amount, unitPreference);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// using a known unit</span></div><div class=\"line\">unit = Unit.fromBTC(amount);</div><div class=\"line\">unit = Unit.fromMilis(amount);</div><div class=\"line\">unit = Unit.fromBits(amount);</div><div class=\"line\">unit = Unit.fromSatoshis(amount);</div></pre></td></tr></table></figure>\n\n<h2 id=\"Conversion\">Conversion</h2>\n<p>Once you have a unit instance, you can check its representantion in all the available units. For your convinience the classes expose three ways to acomplish this. Using the <code>.to(unitCode)</code> method, using a fixed unit like <code>.toSatoshis()</code> or by using the accessors.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> unit;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// using a unit code</span></div><div class=\"line\"><span class=\"keyword\">var</span> unitPreference = Unit.BTC;</div><div class=\"line\">value = Unit.fromSatoshis(amount).to(unitPreference);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// using a known unit</span></div><div class=\"line\">value = Unit.fromBTC(amount).toBTC();</div><div class=\"line\">value = Unit.fromBTC(amount).toMilis();</div><div class=\"line\">value = Unit.fromBTC(amount).toBits();</div><div class=\"line\">value = Unit.fromBTC(amount).toSatoshis();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// using accessors</span></div><div class=\"line\">value = Unit.fromBTC(amount).BTC;</div><div class=\"line\">value = Unit.fromBTC(amount).mBTC;</div><div class=\"line\">value = Unit.fromBTC(amount).bits;</div><div class=\"line\">value = Unit.fromBTC(amount).satoshis;</div></pre></td></tr></table></figure>\n\n","source":"guide/unit.md","raw":"# Unit\n\n## Description\n\nUnit is an utility for handling and converting bitcoin units. We strongly recommend to always use satoshis to represent amount inside your application and only convert them to other units in the front-end.\n\n## Supported units\n\nThe supported units are BTC, mBTC, bits (micro BTCs, uBTC) and satoshis. The codes for each unit can be found as members of the Unit class.\n\n```javascript\nvar btcCode = Unit.BTC;\nvar mbtcCode = Unit.mBTC;\nvar ubtcCode = Unit.uBTC;\nvar bitsCode = Unit.bits;\nvar satsCode = Unit.satoshis;\n```\n\n## Creating units\n\nThere are two ways for creating a unit instance. You can instantiate the class using a value and a unit code; alternatively if the unit it's fixed you could you some of the static methods. Check some examples below:\n\n```javascript\nvar unit;\nvar amount = 100;\n\n// using a unit code\nvar unitPreference = Unit.BTC;\nunit = new Unit(amount, unitPreference);\n\n// using a known unit\nunit = Unit.fromBTC(amount);\nunit = Unit.fromMilis(amount);\nunit = Unit.fromBits(amount);\nunit = Unit.fromSatoshis(amount);\n```\n\n## Conversion\n\nOnce you have a unit instance, you can check its representantion in all the available units. For your convinience the classes expose three ways to acomplish this. Using the `.to(unitCode)` method, using a fixed unit like `.toSatoshis()` or by using the accessors.\n\n```javascript\nvar unit;\n\n// using a unit code\nvar unitPreference = Unit.BTC;\nvalue = Unit.fromSatoshis(amount).to(unitPreference);\n\n// using a known unit\nvalue = Unit.fromBTC(amount).toBTC();\nvalue = Unit.fromBTC(amount).toMilis();\nvalue = Unit.fromBTC(amount).toBits();\nvalue = Unit.fromBTC(amount).toSatoshis();\n\n// using accessors\nvalue = Unit.fromBTC(amount).BTC;\nvalue = Unit.fromBTC(amount).mBTC;\nvalue = Unit.fromBTC(amount).bits;\nvalue = Unit.fromBTC(amount).satoshis;\n```\n","date":1419285021000,"updated":1419285021000,"path":"guide/unit.html","excerpt":"","_id":"o047idmtsw9duqcv","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"URI\">URI</h1>\n<h2 id=\"Description\">Description</h2>\n<p>Represents a bitcoin payment URI. Bitcoin URI strings became the most popular way to share payment request, sometimes as a bitcoin link and others using a QR code.</p>\n<p>URI Examples:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">bitcoin:<span class=\"number\">12</span>A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu</div><div class=\"line\">bitcoin:<span class=\"number\">12</span>A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu?<span class=\"variable\">amount=</span><span class=\"number\">1.2</span></div><div class=\"line\">bitcoin:<span class=\"number\">12</span>A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu?<span class=\"variable\">amount=</span><span class=\"number\">1.2</span>&<span class=\"variable\">message=</span>Payment&<span class=\"variable\">label=</span>Satoshi&<span class=\"variable\">extra=</span>other-param</div></pre></td></tr></table></figure>\n\n<h2 id=\"URI_Validation\">URI Validation</h2>\n<p>The main use that we expect you’ll have for the <code>URI</code> class in bitcore is validating and parsing bitcoin URIs. A <code>URI</code> instance exposes the address as a bitcore <code>Address</code> object and the amount in Satoshis, if present.</p>\n<p>The code for validating uris looks like this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> uriString = <span class=\"string\">'bitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu?amount=1.2'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> valid = URI.isValid(uriString);</div><div class=\"line\"><span class=\"keyword\">var</span> uri = <span class=\"keyword\">new</span> URI(uriString);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(uri.address.network, uri.amount); <span class=\"comment\">// 'livenet', 120000000</span></div></pre></td></tr></table></figure>\n\n<h2 id=\"URI_Parameters\">URI Parameters</h2>\n<p>All standard parameters can be found as members of the <code>URI</code> instance. However a bitcoin URI may contain other non-standard parameters, all those can be found under the <code>extra</code> namespace.</p>\n<p>See <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki\" target=\"_blank\" rel=\"external\">the official BIP21 spec</a> for more information.</p>\n<h2 id=\"Create_URI\">Create URI</h2>\n<p>Another important use case for the <code>URI</code> class is creating a bitcoin URI for sharing a payment request. That can be accomplished by using a dictionary to create an instance of URI.</p>\n<p>The code for creating an URI from an Object looks like this:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> uriString = <span class=\"keyword\">new</span> URI({</div><div class=\"line\">  address: <span class=\"string\">'12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu'</span>,</div><div class=\"line\">  amount : <span class=\"number\">10000</span>, <span class=\"comment\">// in satoshis</span></div><div class=\"line\">  message: <span class=\"string\">'My payment request'</span></div><div class=\"line\">});</div><div class=\"line\"><span class=\"keyword\">var</span> uriString = uri.toString();</div></pre></td></tr></table></figure>\n\n","source":"guide/uri.md","raw":"# URI\n\n## Description\n\nRepresents a bitcoin payment URI. Bitcoin URI strings became the most popular way to share payment request, sometimes as a bitcoin link and others using a QR code.\n\nURI Examples:\n```\nbitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu\nbitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu?amount=1.2\nbitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu?amount=1.2&message=Payment&label=Satoshi&extra=other-param\n```\n\n## URI Validation\n\nThe main use that we expect you'll have for the `URI` class in bitcore is validating and parsing bitcoin URIs. A `URI` instance exposes the address as a bitcore `Address` object and the amount in Satoshis, if present.\n\nThe code for validating uris looks like this:\n```javascript\nvar uriString = 'bitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu?amount=1.2';\nvar valid = URI.isValid(uriString);\nvar uri = new URI(uriString);\nconsole.log(uri.address.network, uri.amount); // 'livenet', 120000000\n```\n\n## URI Parameters\nAll standard parameters can be found as members of the `URI` instance. However a bitcoin URI may contain other non-standard parameters, all those can be found under the `extra` namespace.\n\nSee [the official BIP21 spec](https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki) for more information.\n\n## Create URI\n\nAnother important use case for the `URI` class is creating a bitcoin URI for sharing a payment request. That can be accomplished by using a dictionary to create an instance of URI.\n\nThe code for creating an URI from an Object looks like this:\n```javascript\nvar uriString = new URI({\n  address: '12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu',\n  amount : 10000, // in satoshis\n  message: 'My payment request'\n});\nvar uriString = uri.toString();\n```\n","date":1419285021000,"updated":1419285021000,"path":"guide/uri.html","excerpt":"","_id":"xmms4qyostt0wzk5","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"Address\"></a></p>\n<h1 id=\"class:_Address\">class: Address</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#Address\">class: Address</a><ul>\n<li><a href=\"#new_Address\">new Address(data, [network], [type])</a></li>\n<li><a href=\"#Address.PayToPublicKeyHash\">Address.PayToPublicKeyHash</a></li>\n<li><a href=\"#Address.PayToScriptHash\">Address.PayToScriptHash</a></li>\n<li><a href=\"#Address#_classifyArguments\">address._classifyArguments(data, [network], [type])</a></li>\n<li><a href=\"#Address.createMultisig\">Address.createMultisig(publicKeys, threshold, network)</a></li>\n<li><a href=\"#Address.fromPublicKey\">Address.fromPublicKey(data, network)</a></li>\n<li><a href=\"#Address.fromPublicKeyHash\">Address.fromPublicKeyHash(hash, network)</a></li>\n<li><a href=\"#Address.fromScriptHash\">Address.fromScriptHash(hash, network)</a></li>\n<li><a href=\"#Address.fromScript\">Address.fromScript(script, network)</a></li>\n<li><a href=\"#Address.fromBuffer\">Address.fromBuffer(buffer, [network], [type])</a></li>\n<li><a href=\"#Address.fromString\">Address.fromString(str, [network], [type])</a></li>\n<li><a href=\"#Address.fromJSON\">Address.fromJSON(json)</a></li>\n<li><a href=\"#Address.getValidationError\">Address.getValidationError(data, network, type)</a></li>\n<li><a href=\"#Address.isValid\">Address.isValid(data, network, type)</a></li>\n<li><a href=\"#Address#isPayToPublicKeyHash\">address.isPayToPublicKeyHash()</a></li>\n<li><a href=\"#Address#isPayToScriptHash\">address.isPayToScriptHash()</a></li>\n<li><a href=\"#Address#toBuffer\">address.toBuffer()</a></li>\n<li><a href=\"#Address#toObject\">address.toObject()</a></li>\n<li><a href=\"#Address#toJSON\">address.toJSON()</a></li>\n<li><a href=\"#Address#toString\">address.toString()</a></li>\n<li><a href=\"#Address#inspect\">address.inspect()</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"new_Address\"></a></p>\n<h2 id=\"new_Address(data,_[network],_[type])\">new Address(data, [network], [type])</h2>\n<p>Instantiate an address from an address String or Buffer, a public key or script hash Buffer,<br>or an instance of <code>PublicKey</code> or <code>Script</code>.</p>\n<p>This is an immutable class, and if the first parameter provided to this constructor is an<br><code>Address</code> instance, the same argument will be returned.</p>\n<p>An address has two key properties: <code>network</code> and <code>type</code>. The type is either<br><code>Address.PayToPublicKeyHash</code> (value is the <code>&#39;pubkeyhash&#39;</code> string)<br>or <code>Address.PayToScriptHash</code> (the string <code>&#39;scripthash&#39;</code>). The network is an instance of <code>Network</code>.<br>You can quickly check whether an address is of a given kind by using the methods<br><code>isPayToPublicKeyHash</code> and <code>isPayToScriptHash</code></p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>*</code> - The encoded data in various formats  </li>\n<li>[network] <code>Network</code> | <code>String</code> | <code>number</code> - The network: ‘livenet’ or ‘testnet’  </li>\n<li>[type] <code>String</code> - The type of address: ‘script’ or ‘pubkey’  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Address\">Address</a> - A new valid and frozen instance of an Address<br><strong>Example</strong>  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// validate that an input field is valid</span></div><div class=\"line\"><span class=\"keyword\">var</span> error = Address.getValidationError(input, <span class=\"string\">'testnet'</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> (!error) {</div><div class=\"line\">  <span class=\"keyword\">var</span> address = Address(input, <span class=\"string\">'testnet'</span>);</div><div class=\"line\">} <span class=\"keyword\">else</span> {</div><div class=\"line\">  <span class=\"comment\">// invalid network or checksum (typo?)</span></div><div class=\"line\">  <span class=\"keyword\">var</span> message = error.messsage;</div><div class=\"line\">}</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// get an address from a public key</span></div><div class=\"line\"><span class=\"keyword\">var</span> address = Address(publicKey, <span class=\"string\">'testnet'</span>).toString();</div></pre></td></tr></table></figure>\n\n<p><a name=\"Address.PayToPublicKeyHash\"></a></p>\n<h2 id=\"Address-PayToPublicKeyHash\">Address.PayToPublicKeyHash</h2>\n<p><a name=\"Address.PayToScriptHash\"></a></p>\n<h2 id=\"Address-PayToScriptHash\">Address.PayToScriptHash</h2>\n<p><a name=\"Address#_classifyArguments\"></a></p>\n<h2 id=\"address-_classifyArguments(data,_[network],_[type])\">address._classifyArguments(data, [network], [type])</h2>\n<p>Internal function used to split different kinds of arguments of the constructor</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>*</code> - The encoded data in various formats  </li>\n<li>[network] <code>Network</code> | <code>String</code> | <code>number</code> - The network: ‘livenet’ or ‘testnet’  </li>\n<li>[type] <code>String</code> - The type of address: ‘script’ or ‘pubkey’  </li>\n</ul>\n<p><strong>Returns</strong>: <code>Object</code> - An “info” object with “type”, “network”, and “hashBuffer”<br><a name=\"Address.createMultisig\"></a></p>\n<h2 id=\"Address-createMultisig(publicKeys,_threshold,_network)\">Address.createMultisig(publicKeys, threshold, network)</h2>\n<p>Creates a P2SH address from a set of public keys and a threshold.</p>\n<p>The addresses will be sorted lexicographically, as that is the trend in bitcoin.<br>To create an address from unsorted public keys, use the <code>Script#buildMultisigOut</code><br>interface.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>publicKeys <code>Array</code> - a set of public keys to create an address  </li>\n<li>threshold <code>number</code> - the number of signatures needed to release the funds  </li>\n<li>network <code>String</code> | <code>Network</code> - either a Network instance, ‘livenet’, or ‘testnet’  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Address\">Address</a><br><a name=\"Address.fromPublicKey\"></a></p>\n<h2 id=\"Address-fromPublicKey(data,_network)\">Address.fromPublicKey(data, network)</h2>\n<p>Instantiate an address from a PublicKey instance</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>PublicKey</code>  </li>\n<li>network <code>String</code> | <code>Network</code> - either a Network instance, ‘livenet’, or ‘testnet’  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Address\">Address</a> - A new valid and frozen instance of an Address<br><a name=\"Address.fromPublicKeyHash\"></a></p>\n<h2 id=\"Address-fromPublicKeyHash(hash,_network)\">Address.fromPublicKeyHash(hash, network)</h2>\n<p>Instantiate an address from a ripemd160 public key hash</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>hash <code>Buffer</code> - An instance of buffer of the hash  </li>\n<li>network <code>String</code> | <code>Network</code> - either a Network instance, ‘livenet’, or ‘testnet’  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Address\">Address</a> - A new valid and frozen instance of an Address<br><a name=\"Address.fromScriptHash\"></a></p>\n<h2 id=\"Address-fromScriptHash(hash,_network)\">Address.fromScriptHash(hash, network)</h2>\n<p>Instantiate an address from a ripemd160 script hash</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>hash <code>Buffer</code> - An instance of buffer of the hash  </li>\n<li>network <code>String</code> | <code>Network</code> - either a Network instance, ‘livenet’, or ‘testnet’  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Address\">Address</a> - A new valid and frozen instance of an Address<br><a name=\"Address.fromScript\"></a></p>\n<h2 id=\"Address-fromScript(script,_network)\">Address.fromScript(script, network)</h2>\n<p>Instantiate an address from a Script</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>script <code>Script</code> - An instance of Script  </li>\n<li>network <code>String</code> | <code>Network</code> - either a Network instance, ‘livenet’, or ‘testnet’  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Address\">Address</a> - A new valid and frozen instance of an Address<br><a name=\"Address.fromBuffer\"></a></p>\n<h2 id=\"Address-fromBuffer(buffer,_[network],_[type])\">Address.fromBuffer(buffer, [network], [type])</h2>\n<p>Instantiate an address from a buffer of the address</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>buffer <code>Buffer</code> - An instance of buffer of the address  </li>\n<li>[network] <code>String</code> | <code>Network</code> - either a Network instance, ‘livenet’, or ‘testnet’  </li>\n<li>[type] <code>String</code> - The type of address: ‘script’ or ‘pubkey’  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Address\">Address</a> - A new valid and frozen instance of an Address<br><a name=\"Address.fromString\"></a></p>\n<h2 id=\"Address-fromString(str,_[network],_[type])\">Address.fromString(str, [network], [type])</h2>\n<p>Instantiate an address from an address string</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>str <code>String</code> - An string of the bitcoin address  </li>\n<li>[network] <code>String</code> | <code>Network</code> - either a Network instance, ‘livenet’, or ‘testnet’  </li>\n<li>[type] <code>String</code> - The type of address: ‘script’ or ‘pubkey’  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Address\">Address</a> - A new valid and frozen instance of an Address<br><a name=\"Address.fromJSON\"></a></p>\n<h2 id=\"Address-fromJSON(json)\">Address.fromJSON(json)</h2>\n<p>Instantiate an address from JSON</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>json <code>String</code> - An JSON string or Object with keys: hash, network and type  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Address\">Address</a> - A new valid instance of an Address<br><a name=\"Address.getValidationError\"></a></p>\n<h2 id=\"Address-getValidationError(data,_network,_type)\">Address.getValidationError(data, network, type)</h2>\n<p>Will return a validation error if exists</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>String</code> - The encoded data  </li>\n<li>network <code>String</code> | <code>Network</code> - either a Network instance, ‘livenet’, or ‘testnet’  </li>\n<li>type <code>String</code> - The type of address: ‘script’ or ‘pubkey’  </li>\n</ul>\n<p><strong>Returns</strong>: <code>null</code> | <code>Error</code> - The corresponding error message<br><strong>Example</strong>  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// a network mismatch error</span></div><div class=\"line\"><span class=\"keyword\">var</span> error = Address.getValidationError(<span class=\"string\">'15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2'</span>, <span class=\"string\">'testnet'</span>);</div></pre></td></tr></table></figure>\n\n<p><a name=\"Address.isValid\"></a></p>\n<h2 id=\"Address-isValid(data,_network,_type)\">Address.isValid(data, network, type)</h2>\n<p>Will return a boolean if an address is valid</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>String</code> - The encoded data  </li>\n<li>network <code>String</code> | <code>Network</code> - either a Network instance, ‘livenet’, or ‘testnet’  </li>\n<li>type <code>String</code> - The type of address: ‘script’ or ‘pubkey’  </li>\n</ul>\n<p><strong>Returns</strong>: <code>boolean</code> - The corresponding error message<br><strong>Example</strong>  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">assert(Address.isValid(<span class=\"string\">'15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2'</span>, <span class=\"string\">'livenet'</span>));</div></pre></td></tr></table></figure>\n\n<p><a name=\"Address#isPayToPublicKeyHash\"></a></p>\n<h2 id=\"address-isPayToPublicKeyHash()\">address.isPayToPublicKeyHash()</h2>\n<p>Returns true if an address is of pay to public key hash type</p>\n<p><strong>Returns</strong>:  - boolean<br><a name=\"Address#isPayToScriptHash\"></a></p>\n<h2 id=\"address-isPayToScriptHash()\">address.isPayToScriptHash()</h2>\n<p>Returns true if an address is of pay to script hash type</p>\n<p><strong>Returns</strong>:  - boolean<br><a name=\"Address#toBuffer\"></a></p>\n<h2 id=\"address-toBuffer()\">address.toBuffer()</h2>\n<p>Will return a buffer representation of the address</p>\n<p><strong>Returns</strong>: <code>Buffer</code> - Bitcoin address buffer<br><a name=\"Address#toObject\"></a></p>\n<h2 id=\"address-toObject()\">address.toObject()</h2>\n<p><strong>Returns</strong>: <code>Object</code> - A plain object with the address information<br><a name=\"Address#toJSON\"></a></p>\n<h2 id=\"address-toJSON()\">address.toJSON()</h2>\n<p><strong>Returns</strong>: <code>String</code> - A JSON representation of a plain object with the address information<br><a name=\"Address#toString\"></a></p>\n<h2 id=\"address-toString()\">address.toString()</h2>\n<p>Will return a the string representation of the address</p>\n<p><strong>Returns</strong>: <code>String</code> - Bitcoin address<br><a name=\"Address#inspect\"></a></p>\n<h2 id=\"address-inspect()\">address.inspect()</h2>\n<p>Will return a string formatted for the console</p>\n<p><strong>Returns</strong>: <code>String</code> - Bitcoin address  </p>\n","source":"api/address.md","raw":"<a name=\"Address\"></a>\n#class: Address\n**Members**\n\n* [class: Address](#Address)\n  * [new Address(data, [network], [type])](#new_Address)\n  * [Address.PayToPublicKeyHash](#Address.PayToPublicKeyHash)\n  * [Address.PayToScriptHash](#Address.PayToScriptHash)\n  * [address._classifyArguments(data, [network], [type])](#Address#_classifyArguments)\n  * [Address.createMultisig(publicKeys, threshold, network)](#Address.createMultisig)\n  * [Address.fromPublicKey(data, network)](#Address.fromPublicKey)\n  * [Address.fromPublicKeyHash(hash, network)](#Address.fromPublicKeyHash)\n  * [Address.fromScriptHash(hash, network)](#Address.fromScriptHash)\n  * [Address.fromScript(script, network)](#Address.fromScript)\n  * [Address.fromBuffer(buffer, [network], [type])](#Address.fromBuffer)\n  * [Address.fromString(str, [network], [type])](#Address.fromString)\n  * [Address.fromJSON(json)](#Address.fromJSON)\n  * [Address.getValidationError(data, network, type)](#Address.getValidationError)\n  * [Address.isValid(data, network, type)](#Address.isValid)\n  * [address.isPayToPublicKeyHash()](#Address#isPayToPublicKeyHash)\n  * [address.isPayToScriptHash()](#Address#isPayToScriptHash)\n  * [address.toBuffer()](#Address#toBuffer)\n  * [address.toObject()](#Address#toObject)\n  * [address.toJSON()](#Address#toJSON)\n  * [address.toString()](#Address#toString)\n  * [address.inspect()](#Address#inspect)\n\n<a name=\"new_Address\"></a>\n##new Address(data, [network], [type])\nInstantiate an address from an address String or Buffer, a public key or script hash Buffer,\nor an instance of `PublicKey` or `Script`.\n\nThis is an immutable class, and if the first parameter provided to this constructor is an\n`Address` instance, the same argument will be returned.\n\nAn address has two key properties: `network` and `type`. The type is either\n`Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string)\nor `Address.PayToScriptHash` (the string `'scripthash'`). The network is an instance of `Network`.\nYou can quickly check whether an address is of a given kind by using the methods\n`isPayToPublicKeyHash` and `isPayToScriptHash`\n\n**Params**\n\n- data `*` - The encoded data in various formats  \n- \\[network\\] `Network` | `String` | `number` - The network: 'livenet' or 'testnet'  \n- \\[type\\] `String` - The type of address: 'script' or 'pubkey'  \n\n**Returns**: [Address](#Address) - A new valid and frozen instance of an Address  \n**Example**  \n```javascript\n// validate that an input field is valid\nvar error = Address.getValidationError(input, 'testnet');\nif (!error) {\n  var address = Address(input, 'testnet');\n} else {\n  // invalid network or checksum (typo?)\n  var message = error.messsage;\n}\n\n// get an address from a public key\nvar address = Address(publicKey, 'testnet').toString();\n```\n\n<a name=\"Address.PayToPublicKeyHash\"></a>\n##Address.PayToPublicKeyHash\n<a name=\"Address.PayToScriptHash\"></a>\n##Address.PayToScriptHash\n<a name=\"Address#_classifyArguments\"></a>\n##address._classifyArguments(data, [network], [type])\nInternal function used to split different kinds of arguments of the constructor\n\n**Params**\n\n- data `*` - The encoded data in various formats  \n- \\[network\\] `Network` | `String` | `number` - The network: 'livenet' or 'testnet'  \n- \\[type\\] `String` - The type of address: 'script' or 'pubkey'  \n\n**Returns**: `Object` - An \"info\" object with \"type\", \"network\", and \"hashBuffer\"  \n<a name=\"Address.createMultisig\"></a>\n##Address.createMultisig(publicKeys, threshold, network)\nCreates a P2SH address from a set of public keys and a threshold.\n\nThe addresses will be sorted lexicographically, as that is the trend in bitcoin.\nTo create an address from unsorted public keys, use the `Script#buildMultisigOut`\ninterface.\n\n**Params**\n\n- publicKeys `Array` - a set of public keys to create an address  \n- threshold `number` - the number of signatures needed to release the funds  \n- network `String` | `Network` - either a Network instance, 'livenet', or 'testnet'  \n\n**Returns**: [Address](#Address)  \n<a name=\"Address.fromPublicKey\"></a>\n##Address.fromPublicKey(data, network)\nInstantiate an address from a PublicKey instance\n\n**Params**\n\n- data `PublicKey`  \n- network `String` | `Network` - either a Network instance, 'livenet', or 'testnet'  \n\n**Returns**: [Address](#Address) - A new valid and frozen instance of an Address  \n<a name=\"Address.fromPublicKeyHash\"></a>\n##Address.fromPublicKeyHash(hash, network)\nInstantiate an address from a ripemd160 public key hash\n\n**Params**\n\n- hash `Buffer` - An instance of buffer of the hash  \n- network `String` | `Network` - either a Network instance, 'livenet', or 'testnet'  \n\n**Returns**: [Address](#Address) - A new valid and frozen instance of an Address  \n<a name=\"Address.fromScriptHash\"></a>\n##Address.fromScriptHash(hash, network)\nInstantiate an address from a ripemd160 script hash\n\n**Params**\n\n- hash `Buffer` - An instance of buffer of the hash  \n- network `String` | `Network` - either a Network instance, 'livenet', or 'testnet'  \n\n**Returns**: [Address](#Address) - A new valid and frozen instance of an Address  \n<a name=\"Address.fromScript\"></a>\n##Address.fromScript(script, network)\nInstantiate an address from a Script\n\n**Params**\n\n- script `Script` - An instance of Script  \n- network `String` | `Network` - either a Network instance, 'livenet', or 'testnet'  \n\n**Returns**: [Address](#Address) - A new valid and frozen instance of an Address  \n<a name=\"Address.fromBuffer\"></a>\n##Address.fromBuffer(buffer, [network], [type])\nInstantiate an address from a buffer of the address\n\n**Params**\n\n- buffer `Buffer` - An instance of buffer of the address  \n- \\[network\\] `String` | `Network` - either a Network instance, 'livenet', or 'testnet'  \n- \\[type\\] `String` - The type of address: 'script' or 'pubkey'  \n\n**Returns**: [Address](#Address) - A new valid and frozen instance of an Address  \n<a name=\"Address.fromString\"></a>\n##Address.fromString(str, [network], [type])\nInstantiate an address from an address string\n\n**Params**\n\n- str `String` - An string of the bitcoin address  \n- \\[network\\] `String` | `Network` - either a Network instance, 'livenet', or 'testnet'  \n- \\[type\\] `String` - The type of address: 'script' or 'pubkey'  \n\n**Returns**: [Address](#Address) - A new valid and frozen instance of an Address  \n<a name=\"Address.fromJSON\"></a>\n##Address.fromJSON(json)\nInstantiate an address from JSON\n\n**Params**\n\n- json `String` - An JSON string or Object with keys: hash, network and type  \n\n**Returns**: [Address](#Address) - A new valid instance of an Address  \n<a name=\"Address.getValidationError\"></a>\n##Address.getValidationError(data, network, type)\nWill return a validation error if exists\n\n**Params**\n\n- data `String` - The encoded data  \n- network `String` | `Network` - either a Network instance, 'livenet', or 'testnet'  \n- type `String` - The type of address: 'script' or 'pubkey'  \n\n**Returns**: `null` | `Error` - The corresponding error message  \n**Example**  \n```javascript\n// a network mismatch error\nvar error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');\n```\n\n<a name=\"Address.isValid\"></a>\n##Address.isValid(data, network, type)\nWill return a boolean if an address is valid\n\n**Params**\n\n- data `String` - The encoded data  \n- network `String` | `Network` - either a Network instance, 'livenet', or 'testnet'  \n- type `String` - The type of address: 'script' or 'pubkey'  \n\n**Returns**: `boolean` - The corresponding error message  \n**Example**  \n```javascript\nassert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));\n```\n\n<a name=\"Address#isPayToPublicKeyHash\"></a>\n##address.isPayToPublicKeyHash()\nReturns true if an address is of pay to public key hash type\n\n**Returns**:  - boolean  \n<a name=\"Address#isPayToScriptHash\"></a>\n##address.isPayToScriptHash()\nReturns true if an address is of pay to script hash type\n\n**Returns**:  - boolean  \n<a name=\"Address#toBuffer\"></a>\n##address.toBuffer()\nWill return a buffer representation of the address\n\n**Returns**: `Buffer` - Bitcoin address buffer  \n<a name=\"Address#toObject\"></a>\n##address.toObject()\n**Returns**: `Object` - A plain object with the address information  \n<a name=\"Address#toJSON\"></a>\n##address.toJSON()\n**Returns**: `String` - A JSON representation of a plain object with the address information  \n<a name=\"Address#toString\"></a>\n##address.toString()\nWill return a the string representation of the address\n\n**Returns**: `String` - Bitcoin address  \n<a name=\"Address#inspect\"></a>\n##address.inspect()\nWill return a string formatted for the console\n\n**Returns**: `String` - Bitcoin address  \n","date":1419285021000,"updated":1419285021000,"path":"api/address.html","excerpt":"","_id":"htmnzverk36294tl","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"Block\"></a></p>\n<h1 id=\"class:_Block\">class: Block</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#Block\">class: Block</a><ul>\n<li><a href=\"#new_Block\">new Block(arg)</a></li>\n<li><a href=\"#Block#magicnum\">block.magicnum</a></li>\n<li><a href=\"#Block#size\">block.size</a></li>\n<li><a href=\"#Block#header\">block.header</a></li>\n<li><a href=\"#Block#txs\">block.txs</a></li>\n<li><a href=\"#Block.fromJSON\">Block.fromJSON(json)</a></li>\n<li><a href=\"#Block.fromBufferReader\">Block.fromBufferReader(br)</a></li>\n<li><a href=\"#Block.fromBuffer\">Block.fromBuffer(buf)</a></li>\n<li><a href=\"#Block.fromString\">Block.fromString(str)</a></li>\n<li><a href=\"#Block.fromRawBlock\">Block.fromRawBlock(data)</a></li>\n<li><a href=\"#Block#toObject\">block.toObject()</a></li>\n<li><a href=\"#Block#toJSON\">block.toJSON()</a></li>\n<li><a href=\"#Block#toBuffer\">block.toBuffer()</a></li>\n<li><a href=\"#Block#toString\">block.toString()</a></li>\n<li><a href=\"#Block#toBufferWriter\">block.toBufferWriter(bw)</a></li>\n<li><a href=\"#Block#getTransactionHashes\">block.getTransactionHashes()</a></li>\n<li><a href=\"#Block#getMerkleTree\">block.getMerkleTree()</a></li>\n<li><a href=\"#Block#getMerkleRoot\">block.getMerkleRoot()</a></li>\n<li><a href=\"#Block#validMerkleRoot\">block.validMerkleRoot()</a></li>\n<li><a href=\"#Block#_getHash\">block._getHash()</a></li>\n<li><a href=\"#Block#inspect\">block.inspect()</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"new_Block\"></a></p>\n<h2 id=\"new_Block(arg)\">new Block(arg)</h2>\n<p>Instantiate a Block from a Buffer, JSON object, or Object with<br>the properties of the Block</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>arg <code>*</code> - A Buffer, JSON string, or Object  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Block\">Block</a><br><a name=\"Block#magicnum\"></a></p>\n<h2 id=\"block-magicnum\">block.magicnum</h2>\n<p><strong>Type</strong>: <code>number</code><br><a name=\"Block#size\"></a></p>\n<h2 id=\"block-size\">block.size</h2>\n<p><strong>Type</strong>: <code>number</code><br><a name=\"Block#header\"></a></p>\n<h2 id=\"block-header\">block.header</h2>\n<p><strong>Type</strong>: <code>BlockHeader</code><br><a name=\"Block#txs\"></a></p>\n<h2 id=\"block-txs\">block.txs</h2>\n<p><strong>Type</strong>: <code>Array.&lt;Transaction&gt;</code><br><a name=\"Block.fromJSON\"></a></p>\n<h2 id=\"Block-fromJSON(json)\">Block.fromJSON(json)</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>json <code>String</code> | <code>Object</code> - A JSON string or object  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Block\">Block</a> - - An instance of block<br><a name=\"Block.fromBufferReader\"></a></p>\n<h2 id=\"Block-fromBufferReader(br)\">Block.fromBufferReader(br)</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>br <code>BufferReader</code> - A buffer reader of the block  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Block\">Block</a> - - An instance of block<br><a name=\"Block.fromBuffer\"></a></p>\n<h2 id=\"Block-fromBuffer(buf)\">Block.fromBuffer(buf)</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>buf <code>Buffer</code> - A buffer of the block  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Block\">Block</a> - - An instance of block<br><a name=\"Block.fromString\"></a></p>\n<h2 id=\"Block-fromString(str)\">Block.fromString(str)</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>str <code>String</code> - str - A hex encoded string of the block  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Block\">Block</a> - - A hex encoded string of the block<br><a name=\"Block.fromRawBlock\"></a></p>\n<h2 id=\"Block-fromRawBlock(data)\">Block.fromRawBlock(data)</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>Binary</code> - Raw block binary data or buffer  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Block\">Block</a> - - An instance of block<br><a name=\"Block#toObject\"></a></p>\n<h2 id=\"block-toObject()\">block.toObject()</h2>\n<p><strong>Returns</strong>: <code>Object</code> - - A plain object with the block properties<br><a name=\"Block#toJSON\"></a></p>\n<h2 id=\"block-toJSON()\">block.toJSON()</h2>\n<p><strong>Returns</strong>: <code>String</code> - - A JSON string<br><a name=\"Block#toBuffer\"></a></p>\n<h2 id=\"block-toBuffer()\">block.toBuffer()</h2>\n<p><strong>Returns</strong>: <code>Buffer</code> - - A buffer of the block<br><a name=\"Block#toString\"></a></p>\n<h2 id=\"block-toString()\">block.toString()</h2>\n<p><strong>Returns</strong>: <code>String</code> - - A hex encoded string of the block<br><a name=\"Block#toBufferWriter\"></a></p>\n<h2 id=\"block-toBufferWriter(bw)\">block.toBufferWriter(bw)</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>bw <code>BufferWriter</code> - An existing instance of BufferWriter  </li>\n</ul>\n<p><strong>Returns</strong>: <code>BufferWriter</code> - - An instance of BufferWriter representation of the Block<br><a name=\"Block#getTransactionHashes\"></a></p>\n<h2 id=\"block-getTransactionHashes()\">block.getTransactionHashes()</h2>\n<p>Will iterate through each transaction and return an array of hashes</p>\n<p><strong>Returns</strong>: <code>Array</code> - - An array with transaction hashes<br><a name=\"Block#getMerkleTree\"></a></p>\n<h2 id=\"block-getMerkleTree()\">block.getMerkleTree()</h2>\n<p>Will build a merkle tree of all the transactions, ultimately arriving at<br>a single point, the merkle root.</p>\n<p><strong>Returns</strong>: <code>Array</code> - - An array with each level of the tree after the other.<br><a name=\"Block#getMerkleRoot\"></a></p>\n<h2 id=\"block-getMerkleRoot()\">block.getMerkleRoot()</h2>\n<p>Calculates the merkleRoot from the transactions.</p>\n<p><strong>Returns</strong>: <code>Buffer</code> - - A buffer of the merkle root hash<br><a name=\"Block#validMerkleRoot\"></a></p>\n<h2 id=\"block-validMerkleRoot()\">block.validMerkleRoot()</h2>\n<p>Verifies that the transactions in the block match the header merkle root</p>\n<p><strong>Returns</strong>: <code>Boolean</code> - - If the merkle roots match<br><a name=\"Block#_getHash\"></a></p>\n<h2 id=\"block-_getHash()\">block._getHash()</h2>\n<p><strong>Returns</strong>: <code>Buffer</code> - - The little endian hash buffer of the header<br><a name=\"Block#inspect\"></a></p>\n<h2 id=\"block-inspect()\">block.inspect()</h2>\n<p><strong>Returns</strong>: <code>String</code> - - A string formated for the console  </p>\n","source":"api/block.md","raw":"<a name=\"Block\"></a>\n#class: Block\n**Members**\n\n* [class: Block](#Block)\n  * [new Block(arg)](#new_Block)\n  * [block.magicnum](#Block#magicnum)\n  * [block.size](#Block#size)\n  * [block.header](#Block#header)\n  * [block.txs](#Block#txs)\n  * [Block.fromJSON(json)](#Block.fromJSON)\n  * [Block.fromBufferReader(br)](#Block.fromBufferReader)\n  * [Block.fromBuffer(buf)](#Block.fromBuffer)\n  * [Block.fromString(str)](#Block.fromString)\n  * [Block.fromRawBlock(data)](#Block.fromRawBlock)\n  * [block.toObject()](#Block#toObject)\n  * [block.toJSON()](#Block#toJSON)\n  * [block.toBuffer()](#Block#toBuffer)\n  * [block.toString()](#Block#toString)\n  * [block.toBufferWriter(bw)](#Block#toBufferWriter)\n  * [block.getTransactionHashes()](#Block#getTransactionHashes)\n  * [block.getMerkleTree()](#Block#getMerkleTree)\n  * [block.getMerkleRoot()](#Block#getMerkleRoot)\n  * [block.validMerkleRoot()](#Block#validMerkleRoot)\n  * [block._getHash()](#Block#_getHash)\n  * [block.inspect()](#Block#inspect)\n\n<a name=\"new_Block\"></a>\n##new Block(arg)\nInstantiate a Block from a Buffer, JSON object, or Object with\nthe properties of the Block\n\n**Params**\n\n- arg `*` - A Buffer, JSON string, or Object  \n\n**Returns**: [Block](#Block)  \n<a name=\"Block#magicnum\"></a>\n##block.magicnum\n**Type**: `number`  \n<a name=\"Block#size\"></a>\n##block.size\n**Type**: `number`  \n<a name=\"Block#header\"></a>\n##block.header\n**Type**: `BlockHeader`  \n<a name=\"Block#txs\"></a>\n##block.txs\n**Type**: `Array.<Transaction>`  \n<a name=\"Block.fromJSON\"></a>\n##Block.fromJSON(json)\n**Params**\n\n- json `String` | `Object` - A JSON string or object  \n\n**Returns**: [Block](#Block) - - An instance of block  \n<a name=\"Block.fromBufferReader\"></a>\n##Block.fromBufferReader(br)\n**Params**\n\n- br `BufferReader` - A buffer reader of the block  \n\n**Returns**: [Block](#Block) - - An instance of block  \n<a name=\"Block.fromBuffer\"></a>\n##Block.fromBuffer(buf)\n**Params**\n\n- buf `Buffer` - A buffer of the block  \n\n**Returns**: [Block](#Block) - - An instance of block  \n<a name=\"Block.fromString\"></a>\n##Block.fromString(str)\n**Params**\n\n- str `String` - str - A hex encoded string of the block  \n\n**Returns**: [Block](#Block) - - A hex encoded string of the block  \n<a name=\"Block.fromRawBlock\"></a>\n##Block.fromRawBlock(data)\n**Params**\n\n- data `Binary` - Raw block binary data or buffer  \n\n**Returns**: [Block](#Block) - - An instance of block  \n<a name=\"Block#toObject\"></a>\n##block.toObject()\n**Returns**: `Object` - - A plain object with the block properties  \n<a name=\"Block#toJSON\"></a>\n##block.toJSON()\n**Returns**: `String` - - A JSON string  \n<a name=\"Block#toBuffer\"></a>\n##block.toBuffer()\n**Returns**: `Buffer` - - A buffer of the block  \n<a name=\"Block#toString\"></a>\n##block.toString()\n**Returns**: `String` - - A hex encoded string of the block  \n<a name=\"Block#toBufferWriter\"></a>\n##block.toBufferWriter(bw)\n**Params**\n\n- bw `BufferWriter` - An existing instance of BufferWriter  \n\n**Returns**: `BufferWriter` - - An instance of BufferWriter representation of the Block  \n<a name=\"Block#getTransactionHashes\"></a>\n##block.getTransactionHashes()\nWill iterate through each transaction and return an array of hashes\n\n**Returns**: `Array` - - An array with transaction hashes  \n<a name=\"Block#getMerkleTree\"></a>\n##block.getMerkleTree()\nWill build a merkle tree of all the transactions, ultimately arriving at\na single point, the merkle root.\n\n**Returns**: `Array` - - An array with each level of the tree after the other.  \n<a name=\"Block#getMerkleRoot\"></a>\n##block.getMerkleRoot()\nCalculates the merkleRoot from the transactions.\n\n**Returns**: `Buffer` - - A buffer of the merkle root hash  \n<a name=\"Block#validMerkleRoot\"></a>\n##block.validMerkleRoot()\nVerifies that the transactions in the block match the header merkle root\n\n**Returns**: `Boolean` - - If the merkle roots match  \n<a name=\"Block#_getHash\"></a>\n##block._getHash()\n**Returns**: `Buffer` - - The little endian hash buffer of the header  \n<a name=\"Block#inspect\"></a>\n##block.inspect()\n**Returns**: `String` - - A string formated for the console  \n","date":1419285021000,"updated":1419285021000,"path":"api/block.html","excerpt":"","_id":"ha6ak031lgburqmu","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"BlockHeader\"></a></p>\n<h1 id=\"class:_BlockHeader\">class: BlockHeader</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#BlockHeader\">class: BlockHeader</a><ul>\n<li><a href=\"#new_BlockHeader\">new BlockHeader()</a></li>\n<li><a href=\"#BlockHeader.fromJSON\">BlockHeader.fromJSON(json)</a></li>\n<li><a href=\"#BlockHeader.fromRawBlock\">BlockHeader.fromRawBlock(data)</a></li>\n<li><a href=\"#BlockHeader.fromBuffer\">BlockHeader.fromBuffer(buf)</a></li>\n<li><a href=\"#BlockHeader.fromString\">BlockHeader.fromString(str)</a></li>\n<li><a href=\"#BlockHeader.fromBufferReader\">BlockHeader.fromBufferReader(br)</a></li>\n<li><a href=\"#BlockHeader#toObject\">blockHeader.toObject()</a></li>\n<li><a href=\"#BlockHeader#toJSON\">blockHeader.toJSON()</a></li>\n<li><a href=\"#BlockHeader#toBuffer\">blockHeader.toBuffer()</a></li>\n<li><a href=\"#BlockHeader#toString\">blockHeader.toString()</a></li>\n<li><a href=\"#BlockHeader#toBufferWriter\">blockHeader.toBufferWriter(bw)</a></li>\n<li><a href=\"#BlockHeader#getTargetDifficulty\">blockHeader.getTargetDifficulty()</a></li>\n<li><a href=\"#BlockHeader#_getHash\">blockHeader._getHash()</a></li>\n<li><a href=\"#BlockHeader#validTimestamp\">blockHeader.validTimestamp()</a></li>\n<li><a href=\"#BlockHeader#validProofOfWork\">blockHeader.validProofOfWork()</a></li>\n<li><a href=\"#BlockHeader#inspect\">blockHeader.inspect()</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"new_BlockHeader\"></a></p>\n<h2 id=\"new_BlockHeader()\">new BlockHeader()</h2>\n<p>Instantiate a BlockHeader from a Buffer, JSON object, or Object with<br>the properties of the BlockHeader</p>\n<p><strong>Params</strong></p>\n<ul>\n<li><code>*</code> - A Buffer, JSON string, or Object  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#BlockHeader\">BlockHeader</a> - - An instance of block header<br><a name=\"BlockHeader.fromJSON\"></a></p>\n<h2 id=\"BlockHeader-fromJSON(json)\">BlockHeader.fromJSON(json)</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>json <code>String</code> | <code>Object</code> - A JSON string or object  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#BlockHeader\">BlockHeader</a> - - An instance of block header<br><a name=\"BlockHeader.fromRawBlock\"></a></p>\n<h2 id=\"BlockHeader-fromRawBlock(data)\">BlockHeader.fromRawBlock(data)</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>Binary</code> - Raw block binary data or buffer  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#BlockHeader\">BlockHeader</a> - - An instance of block header<br><a name=\"BlockHeader.fromBuffer\"></a></p>\n<h2 id=\"BlockHeader-fromBuffer(buf)\">BlockHeader.fromBuffer(buf)</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>buf <code>Buffer</code> - A buffer of the block header  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#BlockHeader\">BlockHeader</a> - - An instance of block header<br><a name=\"BlockHeader.fromString\"></a></p>\n<h2 id=\"BlockHeader-fromString(str)\">BlockHeader.fromString(str)</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>str <code>String</code> - A hex encoded buffer of the block header  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#BlockHeader\">BlockHeader</a> - - An instance of block header<br><a name=\"BlockHeader.fromBufferReader\"></a></p>\n<h2 id=\"BlockHeader-fromBufferReader(br)\">BlockHeader.fromBufferReader(br)</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>br <code>BufferReader</code> - A BufferReader of the block header  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#BlockHeader\">BlockHeader</a> - - An instance of block header<br><a name=\"BlockHeader#toObject\"></a></p>\n<h2 id=\"blockHeader-toObject()\">blockHeader.toObject()</h2>\n<p><strong>Returns</strong>: <code>Object</code> - - A plain object of the BlockHeader<br><a name=\"BlockHeader#toJSON\"></a></p>\n<h2 id=\"blockHeader-toJSON()\">blockHeader.toJSON()</h2>\n<p><strong>Returns</strong>: <code>String</code> - - A JSON string<br><a name=\"BlockHeader#toBuffer\"></a></p>\n<h2 id=\"blockHeader-toBuffer()\">blockHeader.toBuffer()</h2>\n<p><strong>Returns</strong>: <code>Buffer</code> - - A Buffer of the BlockHeader<br><a name=\"BlockHeader#toString\"></a></p>\n<h2 id=\"blockHeader-toString()\">blockHeader.toString()</h2>\n<p><strong>Returns</strong>: <code>String</code> - - A hex encoded string of the BlockHeader<br><a name=\"BlockHeader#toBufferWriter\"></a></p>\n<h2 id=\"blockHeader-toBufferWriter(bw)\">blockHeader.toBufferWriter(bw)</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>bw <code>BufferWriter</code> - An existing instance BufferWriter  </li>\n</ul>\n<p><strong>Returns</strong>: <code>BufferWriter</code> - - An instance of BufferWriter representation of the BlockHeader<br><a name=\"BlockHeader#getTargetDifficulty\"></a></p>\n<h2 id=\"blockHeader-getTargetDifficulty()\">blockHeader.getTargetDifficulty()</h2>\n<p><strong>Returns</strong>: <code>BN</code> - - An instance of BN with the decoded difficulty bits<br><a name=\"BlockHeader#_getHash\"></a></p>\n<h2 id=\"blockHeader-_getHash()\">blockHeader._getHash()</h2>\n<p><strong>Returns</strong>: <code>Buffer</code> - - The little endian hash buffer of the header<br><a name=\"BlockHeader#validTimestamp\"></a></p>\n<h2 id=\"blockHeader-validTimestamp()\">blockHeader.validTimestamp()</h2>\n<p><strong>Returns</strong>: <code>Boolean</code> - - If timestamp is not too far in the future<br><a name=\"BlockHeader#validProofOfWork\"></a></p>\n<h2 id=\"blockHeader-validProofOfWork()\">blockHeader.validProofOfWork()</h2>\n<p><strong>Returns</strong>: <code>Boolean</code> - - If the proof-of-work hash satisfies the target difficulty<br><a name=\"BlockHeader#inspect\"></a></p>\n<h2 id=\"blockHeader-inspect()\">blockHeader.inspect()</h2>\n<p><strong>Returns</strong>: <code>String</code> - - A string formated for the console  </p>\n","source":"api/blockheader.md","raw":"<a name=\"BlockHeader\"></a>\n#class: BlockHeader\n**Members**\n\n* [class: BlockHeader](#BlockHeader)\n  * [new BlockHeader()](#new_BlockHeader)\n  * [BlockHeader.fromJSON(json)](#BlockHeader.fromJSON)\n  * [BlockHeader.fromRawBlock(data)](#BlockHeader.fromRawBlock)\n  * [BlockHeader.fromBuffer(buf)](#BlockHeader.fromBuffer)\n  * [BlockHeader.fromString(str)](#BlockHeader.fromString)\n  * [BlockHeader.fromBufferReader(br)](#BlockHeader.fromBufferReader)\n  * [blockHeader.toObject()](#BlockHeader#toObject)\n  * [blockHeader.toJSON()](#BlockHeader#toJSON)\n  * [blockHeader.toBuffer()](#BlockHeader#toBuffer)\n  * [blockHeader.toString()](#BlockHeader#toString)\n  * [blockHeader.toBufferWriter(bw)](#BlockHeader#toBufferWriter)\n  * [blockHeader.getTargetDifficulty()](#BlockHeader#getTargetDifficulty)\n  * [blockHeader._getHash()](#BlockHeader#_getHash)\n  * [blockHeader.validTimestamp()](#BlockHeader#validTimestamp)\n  * [blockHeader.validProofOfWork()](#BlockHeader#validProofOfWork)\n  * [blockHeader.inspect()](#BlockHeader#inspect)\n\n<a name=\"new_BlockHeader\"></a>\n##new BlockHeader()\nInstantiate a BlockHeader from a Buffer, JSON object, or Object with\nthe properties of the BlockHeader\n\n**Params**\n\n-  `*` - A Buffer, JSON string, or Object  \n\n**Returns**: [BlockHeader](#BlockHeader) - - An instance of block header  \n<a name=\"BlockHeader.fromJSON\"></a>\n##BlockHeader.fromJSON(json)\n**Params**\n\n- json `String` | `Object` - A JSON string or object  \n\n**Returns**: [BlockHeader](#BlockHeader) - - An instance of block header  \n<a name=\"BlockHeader.fromRawBlock\"></a>\n##BlockHeader.fromRawBlock(data)\n**Params**\n\n- data `Binary` - Raw block binary data or buffer  \n\n**Returns**: [BlockHeader](#BlockHeader) - - An instance of block header  \n<a name=\"BlockHeader.fromBuffer\"></a>\n##BlockHeader.fromBuffer(buf)\n**Params**\n\n- buf `Buffer` - A buffer of the block header  \n\n**Returns**: [BlockHeader](#BlockHeader) - - An instance of block header  \n<a name=\"BlockHeader.fromString\"></a>\n##BlockHeader.fromString(str)\n**Params**\n\n- str `String` - A hex encoded buffer of the block header  \n\n**Returns**: [BlockHeader](#BlockHeader) - - An instance of block header  \n<a name=\"BlockHeader.fromBufferReader\"></a>\n##BlockHeader.fromBufferReader(br)\n**Params**\n\n- br `BufferReader` - A BufferReader of the block header  \n\n**Returns**: [BlockHeader](#BlockHeader) - - An instance of block header  \n<a name=\"BlockHeader#toObject\"></a>\n##blockHeader.toObject()\n**Returns**: `Object` - - A plain object of the BlockHeader  \n<a name=\"BlockHeader#toJSON\"></a>\n##blockHeader.toJSON()\n**Returns**: `String` - - A JSON string  \n<a name=\"BlockHeader#toBuffer\"></a>\n##blockHeader.toBuffer()\n**Returns**: `Buffer` - - A Buffer of the BlockHeader  \n<a name=\"BlockHeader#toString\"></a>\n##blockHeader.toString()\n**Returns**: `String` - - A hex encoded string of the BlockHeader  \n<a name=\"BlockHeader#toBufferWriter\"></a>\n##blockHeader.toBufferWriter(bw)\n**Params**\n\n- bw `BufferWriter` - An existing instance BufferWriter  \n\n**Returns**: `BufferWriter` - - An instance of BufferWriter representation of the BlockHeader  \n<a name=\"BlockHeader#getTargetDifficulty\"></a>\n##blockHeader.getTargetDifficulty()\n**Returns**: `BN` - - An instance of BN with the decoded difficulty bits  \n<a name=\"BlockHeader#_getHash\"></a>\n##blockHeader._getHash()\n**Returns**: `Buffer` - - The little endian hash buffer of the header  \n<a name=\"BlockHeader#validTimestamp\"></a>\n##blockHeader.validTimestamp()\n**Returns**: `Boolean` - - If timestamp is not too far in the future  \n<a name=\"BlockHeader#validProofOfWork\"></a>\n##blockHeader.validProofOfWork()\n**Returns**: `Boolean` - - If the proof-of-work hash satisfies the target difficulty  \n<a name=\"BlockHeader#inspect\"></a>\n##blockHeader.inspect()\n**Returns**: `String` - - A string formated for the console  \n","date":1419285022000,"updated":1419285022000,"path":"api/blockheader.html","excerpt":"","_id":"utmjhovddyx3qpn9","title":"","comments":true,"layout":"page"},{"content":"","source":"api/hdkeycache.md","raw":"","date":1419285018000,"updated":1419285018000,"path":"api/hdkeycache.html","excerpt":"","_id":"71lwmd1u6zkizz6y","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"HDPrivateKey\"></a></p>\n<h1 id=\"class:_HDPrivateKey\">class: HDPrivateKey</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#HDPrivateKey\">class: HDPrivateKey</a><ul>\n<li><a href=\"#new_HDPrivateKey\">new HDPrivateKey(arg)</a></li>\n<li><a href=\"#HDPrivateKey#derive\">hDPrivateKey.derive(arg, hardened)</a></li>\n<li><a href=\"#HDPrivateKey.isValidSerialized\">HDPrivateKey.isValidSerialized(data, network)</a></li>\n<li><a href=\"#HDPrivateKey.getSerializedError\">HDPrivateKey.getSerializedError(data, network)</a></li>\n<li><a href=\"#HDPrivateKey.fromSeed\">HDPrivateKey.fromSeed(hexa, network)</a></li>\n<li><a href=\"#HDPrivateKey#_buildFromBuffers\">hDPrivateKey._buildFromBuffers(arg)</a></li>\n<li><a href=\"#HDPrivateKey#toString\">hDPrivateKey.toString()</a></li>\n<li><a href=\"#HDPrivateKey#inspect\">hDPrivateKey.inspect()</a></li>\n<li><a href=\"#HDPrivateKey#toObject\">hDPrivateKey.toObject()</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"new_HDPrivateKey\"></a></p>\n<h2 id=\"new_HDPrivateKey(arg)\">new HDPrivateKey(arg)</h2>\n<p>Represents an instance of an hierarchically derived private key.</p>\n<p>More info on <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\" target=\"_blank\" rel=\"external\">https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki</a></p>\n<p><strong>Params</strong></p>\n<ul>\n<li>arg <code>string</code> | <code>Buffer</code> | <code>Object</code>  </li>\n</ul>\n<p><a name=\"HDPrivateKey#derive\"></a></p>\n<h2 id=\"hDPrivateKey-derive(arg,_hardened)\">hDPrivateKey.derive(arg, hardened)</h2>\n<p>Get a derivated child based on a string or number.</p>\n<p>If the first argument is a string, it’s parsed as the full path of<br>derivation. Valid values for this argument include “m” (which returns the<br>same private key), “m/0/1/40/2’/1000”, where the ‘ quote means a hardened<br>derivation.</p>\n<p>If the first argument is a number, the child with that index will be<br>derived. If the second argument is truthy, the hardened version will be<br>derived. See the example usage for clarification.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>arg <code>string</code> | <code>number</code>  </li>\n<li>hardened <code>boolean</code>  </li>\n</ul>\n<p><strong>Example</strong>  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> HDPrivateKey(<span class=\"string\">'xprv...'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> child_0_1_2h = parent.derive(<span class=\"number\">0</span>).derive(<span class=\"number\">1</span>).derive(<span class=\"number\">2</span>, <span class=\"literal\">true</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> copy_of_child_0_1_2h = parent.derive(<span class=\"string\">\"m/0/1/2'\"</span>);</div><div class=\"line\">assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);</div></pre></td></tr></table></figure>\n\n<p><a name=\"HDPrivateKey.isValidSerialized\"></a></p>\n<h2 id=\"HDPrivateKey-isValidSerialized(data,_network)\">HDPrivateKey.isValidSerialized(data, network)</h2>\n<p>Verifies that a given serialized private key in base58 with checksum format<br>is valid.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>string</code> | <code>Buffer</code> - the serialized private key  </li>\n<li>network <code>string</code> | <code>Network</code> - optional, if present, checks that the<br>  network provided matches the network serialized.  </li>\n</ul>\n<p><strong>Returns</strong>: <code>boolean</code><br><a name=\"HDPrivateKey.getSerializedError\"></a></p>\n<h2 id=\"HDPrivateKey-getSerializedError(data,_network)\">HDPrivateKey.getSerializedError(data, network)</h2>\n<p>Checks what’s the error that causes the validation of a serialized private key<br>in base58 with checksum to fail.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>string</code> | <code>Buffer</code> - the serialized private key  </li>\n<li>network <code>string</code> | <code>Network</code> - optional, if present, checks that the<br>  network provided matches the network serialized.  </li>\n</ul>\n<p><strong>Returns</strong>: <code>errors.InvalidArgument</code> | <code>null</code><br><a name=\"HDPrivateKey.fromSeed\"></a></p>\n<h2 id=\"HDPrivateKey-fromSeed(hexa,_network)\">HDPrivateKey.fromSeed(hexa, network)</h2>\n<p>Generate a private key from a seed, as described in BIP32</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>hexa <code>string</code> | <code>Buffer</code>  </li>\n<li>network <code>*</code>  </li>\n</ul>\n<p><strong>Returns</strong>:  - HDPrivateKey<br><a name=\"HDPrivateKey#_buildFromBuffers\"></a></p>\n<h2 id=\"hDPrivateKey-_buildFromBuffers(arg)\">hDPrivateKey._buildFromBuffers(arg)</h2>\n<p>Receives a object with buffers in all the properties and populates the<br>internal structure</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>arg <code>Object</code>  <ul>\n<li>version <code>buffer.Buffer</code>  </li>\n<li>depth <code>buffer.Buffer</code>  </li>\n<li>parentFingerPrint <code>buffer.Buffer</code>  </li>\n<li>childIndex <code>buffer.Buffer</code>  </li>\n<li>chainCode <code>buffer.Buffer</code>  </li>\n<li>privateKey <code>buffer.Buffer</code>  </li>\n<li>checksum <code>buffer.Buffer</code>  </li>\n<li>[xprivkey] <code>string</code> - if set, don’t recalculate the base58<br> representation  </li>\n</ul>\n</li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#HDPrivateKey\">HDPrivateKey</a> - this<br><a name=\"HDPrivateKey#toString\"></a></p>\n<h2 id=\"hDPrivateKey-toString()\">hDPrivateKey.toString()</h2>\n<p>Returns the string representation of this private key (a string starting<br>with “xprv…”</p>\n<p><strong>Returns</strong>:  - string<br><a name=\"HDPrivateKey#inspect\"></a></p>\n<h2 id=\"hDPrivateKey-inspect()\">hDPrivateKey.inspect()</h2>\n<p>Returns the console representation of this extended private key.</p>\n<p><strong>Returns</strong>:  - string<br><a name=\"HDPrivateKey#toObject\"></a></p>\n<h2 id=\"hDPrivateKey-toObject()\">hDPrivateKey.toObject()</h2>\n<p>Returns a plain object with a representation of this private key.</p>\n<p>Fields include:<ul></ul></p>\n<p><li> network: either ‘livenet’ or ‘testnet’</li></p>\n<p><li> depth: a number ranging from 0 to 255</li></p>\n<p><li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the</li></p>\n<p><li>     associated public key</li></p>\n<p><li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash</li></p>\n<p><li>     of this parent’s associated public key or zero.</li></p>\n<p><li> childIndex: the index from which this child was derived (or zero)</li></p>\n<p><li> chainCode: an hexa string representing a number used in the derivation</li></p>\n<p><li> privateKey: the private key associated, in hexa representation</li></p>\n<p><li> xprivkey: the representation of this extended private key in checksum</li></p>\n<p><li>     base58 format</li></p>\n<p><li> checksum: the base58 checksum of xprivkey<br></li></p>\n<p><strong>Returns</strong>: <code>Object</code>  </p>\n","source":"api/hdprivatekey.md","raw":"<a name=\"HDPrivateKey\"></a>\n#class: HDPrivateKey\n**Members**\n\n* [class: HDPrivateKey](#HDPrivateKey)\n  * [new HDPrivateKey(arg)](#new_HDPrivateKey)\n  * [hDPrivateKey.derive(arg, hardened)](#HDPrivateKey#derive)\n  * [HDPrivateKey.isValidSerialized(data, network)](#HDPrivateKey.isValidSerialized)\n  * [HDPrivateKey.getSerializedError(data, network)](#HDPrivateKey.getSerializedError)\n  * [HDPrivateKey.fromSeed(hexa, network)](#HDPrivateKey.fromSeed)\n  * [hDPrivateKey._buildFromBuffers(arg)](#HDPrivateKey#_buildFromBuffers)\n  * [hDPrivateKey.toString()](#HDPrivateKey#toString)\n  * [hDPrivateKey.inspect()](#HDPrivateKey#inspect)\n  * [hDPrivateKey.toObject()](#HDPrivateKey#toObject)\n\n<a name=\"new_HDPrivateKey\"></a>\n##new HDPrivateKey(arg)\nRepresents an instance of an hierarchically derived private key.\n\nMore info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n\n**Params**\n\n- arg `string` | `Buffer` | `Object`  \n\n<a name=\"HDPrivateKey#derive\"></a>\n##hDPrivateKey.derive(arg, hardened)\nGet a derivated child based on a string or number.\n\nIf the first argument is a string, it's parsed as the full path of\nderivation. Valid values for this argument include \"m\" (which returns the\nsame private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\nderivation.\n\nIf the first argument is a number, the child with that index will be\nderived. If the second argument is truthy, the hardened version will be\nderived. See the example usage for clarification.\n\n**Params**\n\n- arg `string` | `number`  \n- hardened `boolean`  \n\n**Example**  \n```javascript\nvar parent = new HDPrivateKey('xprv...');\nvar child_0_1_2h = parent.derive(0).derive(1).derive(2, true);\nvar copy_of_child_0_1_2h = parent.derive(\"m/0/1/2'\");\nassert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n```\n\n<a name=\"HDPrivateKey.isValidSerialized\"></a>\n##HDPrivateKey.isValidSerialized(data, network)\nVerifies that a given serialized private key in base58 with checksum format\nis valid.\n\n**Params**\n\n- data `string` | `Buffer` - the serialized private key  \n- network `string` | `Network` - optional, if present, checks that the\n    network provided matches the network serialized.  \n\n**Returns**: `boolean`  \n<a name=\"HDPrivateKey.getSerializedError\"></a>\n##HDPrivateKey.getSerializedError(data, network)\nChecks what's the error that causes the validation of a serialized private key\nin base58 with checksum to fail.\n\n**Params**\n\n- data `string` | `Buffer` - the serialized private key  \n- network `string` | `Network` - optional, if present, checks that the\n    network provided matches the network serialized.  \n\n**Returns**: `errors.InvalidArgument` | `null`  \n<a name=\"HDPrivateKey.fromSeed\"></a>\n##HDPrivateKey.fromSeed(hexa, network)\nGenerate a private key from a seed, as described in BIP32\n\n**Params**\n\n- hexa `string` | `Buffer`  \n- network `*`  \n\n**Returns**:  - HDPrivateKey  \n<a name=\"HDPrivateKey#_buildFromBuffers\"></a>\n##hDPrivateKey._buildFromBuffers(arg)\nReceives a object with buffers in all the properties and populates the\ninternal structure\n\n**Params**\n\n- arg `Object`  \n  - version `buffer.Buffer`  \n  - depth `buffer.Buffer`  \n  - parentFingerPrint `buffer.Buffer`  \n  - childIndex `buffer.Buffer`  \n  - chainCode `buffer.Buffer`  \n  - privateKey `buffer.Buffer`  \n  - checksum `buffer.Buffer`  \n  - \\[xprivkey\\] `string` - if set, don't recalculate the base58\n     representation  \n\n**Returns**: [HDPrivateKey](#HDPrivateKey) - this  \n<a name=\"HDPrivateKey#toString\"></a>\n##hDPrivateKey.toString()\nReturns the string representation of this private key (a string starting\nwith \"xprv...\"\n\n**Returns**:  - string  \n<a name=\"HDPrivateKey#inspect\"></a>\n##hDPrivateKey.inspect()\nReturns the console representation of this extended private key.\n\n**Returns**:  - string  \n<a name=\"HDPrivateKey#toObject\"></a>\n##hDPrivateKey.toObject()\nReturns a plain object with a representation of this private key.\n\nFields include:<ul>\n<li> network: either 'livenet' or 'testnet'\n<li> depth: a number ranging from 0 to 255\n<li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the\n<li>     associated public key\n<li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash\n<li>     of this parent's associated public key or zero.\n<li> childIndex: the index from which this child was derived (or zero)\n<li> chainCode: an hexa string representing a number used in the derivation\n<li> privateKey: the private key associated, in hexa representation\n<li> xprivkey: the representation of this extended private key in checksum\n<li>     base58 format\n<li> checksum: the base58 checksum of xprivkey\n</ul>\n\n**Returns**: `Object`  \n","date":1419285022000,"updated":1419285022000,"path":"api/hdprivatekey.html","excerpt":"","_id":"esnnqkmp41z4zb4g","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"HDPublicKey\"></a></p>\n<h1 id=\"class:_HDPublicKey\">class: HDPublicKey</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#HDPublicKey\">class: HDPublicKey</a><ul>\n<li><a href=\"#new_HDPublicKey\">new HDPublicKey(arg)</a></li>\n<li><a href=\"#HDPublicKey#derive\">hDPublicKey.derive(arg, hardened)</a></li>\n<li><a href=\"#HDPublicKey.isValidSerialized\">HDPublicKey.isValidSerialized(data, network)</a></li>\n<li><a href=\"#HDPublicKey.getSerializedError\">HDPublicKey.getSerializedError(data, network)</a></li>\n<li><a href=\"#HDPublicKey#_buildFromBuffers\">hDPublicKey._buildFromBuffers(arg)</a></li>\n<li><a href=\"#HDPublicKey#toString\">hDPublicKey.toString()</a></li>\n<li><a href=\"#HDPublicKey#inspect\">hDPublicKey.inspect()</a></li>\n<li><a href=\"#HDPublicKey#toObject\">hDPublicKey.toObject()</a></li>\n<li><a href=\"#HDPublicKey#toJSON\">hDPublicKey.toJSON()</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"new_HDPublicKey\"></a></p>\n<h2 id=\"new_HDPublicKey(arg)\">new HDPublicKey(arg)</h2>\n<p>The representation of an hierarchically derived public key.</p>\n<p>See <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\" target=\"_blank\" rel=\"external\">https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki</a></p>\n<p><strong>Params</strong></p>\n<ul>\n<li>arg <code>Object</code> | <code>string</code> | <code>Buffer</code>  </li>\n</ul>\n<p><a name=\"HDPublicKey#derive\"></a></p>\n<h2 id=\"hDPublicKey-derive(arg,_hardened)\">hDPublicKey.derive(arg, hardened)</h2>\n<p>Get a derivated child based on a string or number.</p>\n<p>If the first argument is a string, it’s parsed as the full path of<br>derivation. Valid values for this argument include “m” (which returns the<br>same private key), “m/0/1/40/2/1000”.</p>\n<p>Note that hardened keys can’t be derived from a public extended key.</p>\n<p>If the first argument is a number, the child with that index will be<br>derived. See the example usage for clarification.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>arg <code>string</code> | <code>number</code>  </li>\n<li>hardened <code>boolean</code>  </li>\n</ul>\n<p><strong>Example</strong>  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> HDPublicKey(<span class=\"string\">'xpub...'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> child_0_1_2 = parent.derive(<span class=\"number\">0</span>).derive(<span class=\"number\">1</span>).derive(<span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> copy_of_child_0_1_2 = parent.derive(<span class=\"string\">\"m/0/1/2\"</span>);</div><div class=\"line\">assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);</div></pre></td></tr></table></figure>\n\n<p><a name=\"HDPublicKey.isValidSerialized\"></a></p>\n<h2 id=\"HDPublicKey-isValidSerialized(data,_network)\">HDPublicKey.isValidSerialized(data, network)</h2>\n<p>Verifies that a given serialized private key in base58 with checksum format<br>is valid.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>string</code> | <code>Buffer</code> - the serialized private key  </li>\n<li>network <code>string</code> | <code>Network</code> - optional, if present, checks that the<br>  network provided matches the network serialized.  </li>\n</ul>\n<p><strong>Returns</strong>: <code>boolean</code><br><a name=\"HDPublicKey.getSerializedError\"></a></p>\n<h2 id=\"HDPublicKey-getSerializedError(data,_network)\">HDPublicKey.getSerializedError(data, network)</h2>\n<p>Checks what’s the error that causes the validation of a serialized private key<br>in base58 with checksum to fail.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>string</code> | <code>Buffer</code> - the serialized private key  </li>\n<li>network <code>string</code> | <code>Network</code> - optional, if present, checks that the<br>  network provided matches the network serialized.  </li>\n</ul>\n<p><strong>Returns</strong>: <code>errors</code> | <code>null</code><br><a name=\"HDPublicKey#_buildFromBuffers\"></a></p>\n<h2 id=\"hDPublicKey-_buildFromBuffers(arg)\">hDPublicKey._buildFromBuffers(arg)</h2>\n<p>Receives a object with buffers in all the properties and populates the<br>internal structure</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>arg <code>Object</code>  <ul>\n<li>version <code>buffer.Buffer</code>  </li>\n<li>depth <code>buffer.Buffer</code>  </li>\n<li>parentFingerPrint <code>buffer.Buffer</code>  </li>\n<li>childIndex <code>buffer.Buffer</code>  </li>\n<li>chainCode <code>buffer.Buffer</code>  </li>\n<li>publicKey <code>buffer.Buffer</code>  </li>\n<li>checksum <code>buffer.Buffer</code>  </li>\n<li>[xpubkey] <code>string</code> - if set, don’t recalculate the base58<br> representation  </li>\n</ul>\n</li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#HDPublicKey\">HDPublicKey</a> - this<br><a name=\"HDPublicKey#toString\"></a></p>\n<h2 id=\"hDPublicKey-toString()\">hDPublicKey.toString()</h2>\n<p>Returns the base58 checked representation of the public key</p>\n<p><strong>Returns</strong>: <code>string</code> - a string starting with “xpub…” in livenet<br><a name=\"HDPublicKey#inspect\"></a></p>\n<h2 id=\"hDPublicKey-inspect()\">hDPublicKey.inspect()</h2>\n<p>Returns the console representation of this extended public key.</p>\n<p><strong>Returns</strong>:  - string<br><a name=\"HDPublicKey#toObject\"></a></p>\n<h2 id=\"hDPublicKey-toObject()\">hDPublicKey.toObject()</h2>\n<p>Returns a plain javascript object with information to reconstruct a key.</p>\n<p>Fields are: <ul><br> <li> network: ‘livenet’ or ‘testnet’<br> </li><li> depth: a number from 0 to 255, the depth to the master extended key<br> </li><li> fingerPrint: a number of 32 bits taken from the hash of the public key<br> </li><li> fingerPrint: a number of 32 bits taken from the hash of this key’s<br> </li><li>     parent’s public key<br> </li><li> childIndex: index with which this key was derived<br> </li><li> chainCode: string in hexa encoding used for derivation<br> </li><li> publicKey: string, hexa encoded, in compressed key format<br> </li><li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),<br> </li><li> xpubkey: the string with the base58 representation of this extended key<br> </li><li> checksum: the base58 checksum of xpubkey<br></li></ul></p>\n<p><a name=\"HDPublicKey#toJSON\"></a></p>\n<h2 id=\"hDPublicKey-toJSON()\">hDPublicKey.toJSON()</h2>\n<p>Serializes this object into a JSON string</p>\n<p><strong>Returns</strong>: <code>string</code>  </p>\n","source":"api/hdpublickey.md","raw":"<a name=\"HDPublicKey\"></a>\n#class: HDPublicKey\n**Members**\n\n* [class: HDPublicKey](#HDPublicKey)\n  * [new HDPublicKey(arg)](#new_HDPublicKey)\n  * [hDPublicKey.derive(arg, hardened)](#HDPublicKey#derive)\n  * [HDPublicKey.isValidSerialized(data, network)](#HDPublicKey.isValidSerialized)\n  * [HDPublicKey.getSerializedError(data, network)](#HDPublicKey.getSerializedError)\n  * [hDPublicKey._buildFromBuffers(arg)](#HDPublicKey#_buildFromBuffers)\n  * [hDPublicKey.toString()](#HDPublicKey#toString)\n  * [hDPublicKey.inspect()](#HDPublicKey#inspect)\n  * [hDPublicKey.toObject()](#HDPublicKey#toObject)\n  * [hDPublicKey.toJSON()](#HDPublicKey#toJSON)\n\n<a name=\"new_HDPublicKey\"></a>\n##new HDPublicKey(arg)\nThe representation of an hierarchically derived public key.\n\nSee https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n\n**Params**\n\n- arg `Object` | `string` | `Buffer`  \n\n<a name=\"HDPublicKey#derive\"></a>\n##hDPublicKey.derive(arg, hardened)\nGet a derivated child based on a string or number.\n\nIf the first argument is a string, it's parsed as the full path of\nderivation. Valid values for this argument include \"m\" (which returns the\nsame private key), \"m/0/1/40/2/1000\".\n\nNote that hardened keys can't be derived from a public extended key.\n\nIf the first argument is a number, the child with that index will be\nderived. See the example usage for clarification.\n\n**Params**\n\n- arg `string` | `number`  \n- hardened `boolean`  \n\n**Example**  \n```javascript\nvar parent = new HDPublicKey('xpub...');\nvar child_0_1_2 = parent.derive(0).derive(1).derive(2);\nvar copy_of_child_0_1_2 = parent.derive(\"m/0/1/2\");\nassert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n```\n\n<a name=\"HDPublicKey.isValidSerialized\"></a>\n##HDPublicKey.isValidSerialized(data, network)\nVerifies that a given serialized private key in base58 with checksum format\nis valid.\n\n**Params**\n\n- data `string` | `Buffer` - the serialized private key  \n- network `string` | `Network` - optional, if present, checks that the\n    network provided matches the network serialized.  \n\n**Returns**: `boolean`  \n<a name=\"HDPublicKey.getSerializedError\"></a>\n##HDPublicKey.getSerializedError(data, network)\nChecks what's the error that causes the validation of a serialized private key\nin base58 with checksum to fail.\n\n**Params**\n\n- data `string` | `Buffer` - the serialized private key  \n- network `string` | `Network` - optional, if present, checks that the\n    network provided matches the network serialized.  \n\n**Returns**: `errors` | `null`  \n<a name=\"HDPublicKey#_buildFromBuffers\"></a>\n##hDPublicKey._buildFromBuffers(arg)\nReceives a object with buffers in all the properties and populates the\ninternal structure\n\n**Params**\n\n- arg `Object`  \n  - version `buffer.Buffer`  \n  - depth `buffer.Buffer`  \n  - parentFingerPrint `buffer.Buffer`  \n  - childIndex `buffer.Buffer`  \n  - chainCode `buffer.Buffer`  \n  - publicKey `buffer.Buffer`  \n  - checksum `buffer.Buffer`  \n  - \\[xpubkey\\] `string` - if set, don't recalculate the base58\n     representation  \n\n**Returns**: [HDPublicKey](#HDPublicKey) - this  \n<a name=\"HDPublicKey#toString\"></a>\n##hDPublicKey.toString()\nReturns the base58 checked representation of the public key\n\n**Returns**: `string` - a string starting with \"xpub...\" in livenet  \n<a name=\"HDPublicKey#inspect\"></a>\n##hDPublicKey.inspect()\nReturns the console representation of this extended public key.\n\n**Returns**:  - string  \n<a name=\"HDPublicKey#toObject\"></a>\n##hDPublicKey.toObject()\nReturns a plain javascript object with information to reconstruct a key.\n\nFields are: <ul>\n <li> network: 'livenet' or 'testnet'\n <li> depth: a number from 0 to 255, the depth to the master extended key\n <li> fingerPrint: a number of 32 bits taken from the hash of the public key\n <li> fingerPrint: a number of 32 bits taken from the hash of this key's\n <li>     parent's public key\n <li> childIndex: index with which this key was derived\n <li> chainCode: string in hexa encoding used for derivation\n <li> publicKey: string, hexa encoded, in compressed key format\n <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n <li> xpubkey: the string with the base58 representation of this extended key\n <li> checksum: the base58 checksum of xpubkey\n</ul>\n\n<a name=\"HDPublicKey#toJSON\"></a>\n##hDPublicKey.toJSON()\nSerializes this object into a JSON string\n\n**Returns**: `string`  \n","date":1419285022000,"updated":1419285022000,"path":"api/hdpublickey.html","excerpt":"","_id":"lvh77x35rw0ozx9f","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"Examples\">Examples</h1>\n<h2 id=\"Create_a_Private_Key\">Create a Private Key</h2>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> privKey = <span class=\"keyword\">new</span> bitcore.PrivateKey();</div></pre></td></tr></table></figure>\n\n<h2 id=\"Create_an_Address\">Create an Address</h2>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> privKey = <span class=\"keyword\">new</span> bitcore.PrivateKey();</div><div class=\"line\"><span class=\"keyword\">var</span> address = privKey.toAddress();</div></pre></td></tr></table></figure>\n\n<h2 id=\"Create_a_Multisig_Address\">Create a Multisig Address</h2>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Build a 2-of-3 address from public keys</span></div><div class=\"line\"><span class=\"keyword\">var</span> P2SHAddress = <span class=\"keyword\">new</span> bitcore.Address([publicKey1, publicKey2, publicKey3], <span class=\"number\">2</span>);</div></pre></td></tr></table></figure>\n\n<h2 id=\"Request_a_Payment\">Request a Payment</h2>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> paymentInfo = {</div><div class=\"line\">  address: <span class=\"string\">'1DNtTk4PUCGAdiNETAzQFWZiy2fCHtGnPx'</span>,</div><div class=\"line\">  amount: <span class=\"number\">120000</span> <span class=\"comment\">//satoshis</span></div><div class=\"line\">};</div><div class=\"line\"><span class=\"keyword\">var</span> uri = <span class=\"keyword\">new</span> bitcore.URI(paymentInfo).toString();</div></pre></td></tr></table></figure>\n\n<h2 id=\"Create_a_Transaction\">Create a Transaction</h2>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> transaction = <span class=\"keyword\">new</span> Transaction()</div><div class=\"line\">    .<span class=\"keyword\">from</span>(utxos)          <span class=\"comment\">// Feed information about what unspend outputs one can use</span></div><div class=\"line\">    .<span class=\"keyword\">to</span>(address, amount)  <span class=\"comment\">// Add an output with the given amount of satoshis</span></div><div class=\"line\">    .change(address)      <span class=\"comment\">// Sets up a change address where the rest of the funds will go</span></div><div class=\"line\">    .sign(privkeySet)     <span class=\"comment\">// Signs all the inputs it can</span></div></pre></td></tr></table></figure>\n\n<h2 id=\"Connect_to_the_Network\">Connect to the Network</h2>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> peer = <span class=\"keyword\">new</span> Peer(<span class=\"string\">'5.9.85.34'</span>);</div><div class=\"line\"></div><div class=\"line\">peer.on(<span class=\"string\">'inv'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(message)</span> </span>{</div><div class=\"line\">  <span class=\"comment\">// new invetory</span></div><div class=\"line\">});</div><div class=\"line\"></div><div class=\"line\">peer.connect();</div></pre></td></tr></table></figure>\n\n","source":"api/index.md","raw":"# Examples\n\n## Create a Private Key\n\n```\nvar privKey = new bitcore.PrivateKey();\n```\n\n## Create an Address\n```\nvar privKey = new bitcore.PrivateKey();\nvar address = privKey.toAddress();\n```\n\n## Create a Multisig Address\n```\n// Build a 2-of-3 address from public keys\nvar P2SHAddress = new bitcore.Address([publicKey1, publicKey2, publicKey3], 2);\n```\n\n## Request a Payment\n```\nvar paymentInfo = {\n  address: '1DNtTk4PUCGAdiNETAzQFWZiy2fCHtGnPx',\n  amount: 120000 //satoshis\n};\nvar uri = new bitcore.URI(paymentInfo).toString();\n```\n\n## Create a Transaction\n```\nvar transaction = new Transaction()\n    .from(utxos)          // Feed information about what unspend outputs one can use\n    .to(address, amount)  // Add an output with the given amount of satoshis\n    .change(address)      // Sets up a change address where the rest of the funds will go\n    .sign(privkeySet)     // Signs all the inputs it can\n```\n\n## Connect to the Network\n```\nvar peer = new Peer('5.9.85.34');\n\npeer.on('inv', function(message) {\n  // new invetory\n});\n\npeer.connect();\n```\n","date":1419285024000,"updated":1419285024000,"path":"api/index.html","excerpt":"","_id":"aa6p8021vw2gy8sl","title":"","comments":true,"layout":"page"},{"content":"<h1 id=\"Index\">Index</h1>\n<p><strong>Classes</strong></p>\n<ul>\n<li><a href=\"#Network\">class: Network</a><ul>\n<li><a href=\"#new_Network\">new Network()</a></li>\n<li><a href=\"#Network#livenet\">network.livenet</a></li>\n<li><a href=\"#Network#testnet\">network.testnet</a></li>\n<li><a href=\"#Network#getNetwork\">network.getNetwork</a></li>\n</ul>\n</li>\n</ul>\n<p><strong>Namespaces</strong></p>\n<ul>\n<li><a href=\"#Network\">Network</a><ul>\n<li><a href=\"#Network#livenet\">network.livenet</a></li>\n<li><a href=\"#Network#testnet\">network.testnet</a></li>\n<li><a href=\"#Network#getNetwork\">network.getNetwork</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"Network\"></a></p>\n<h1 id=\"class:_Network\">class: Network</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#Network\">class: Network</a><ul>\n<li><a href=\"#new_Network\">new Network()</a></li>\n<li><a href=\"#Network#livenet\">network.livenet</a></li>\n<li><a href=\"#Network#testnet\">network.testnet</a></li>\n<li><a href=\"#Network#getNetwork\">network.getNetwork</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"new_Network\"></a></p>\n<h2 id=\"new_Network()\">new Network()</h2>\n<p>A network is merely a map containing values that correspond to version<br>numbers for each bitcoin network. Currently only supporting “livenet”<br>(a.k.a. “mainnet”) and “testnet”.</p>\n<p><a name=\"Network#livenet\"></a></p>\n<h2 id=\"network-livenet\">network.livenet</h2>\n<p><a name=\"Network#testnet\"></a></p>\n<h2 id=\"network-testnet\">network.testnet</h2>\n<p><a name=\"Network#getNetwork\"></a></p>\n<h2 id=\"network-getNetwork\">network.getNetwork</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>arg <code>string</code> | <code>number</code> | <code><a href=\"#Network\">Network</a></code>  </li>\n<li>key <code>string</code> - if set, only check if the magic number associated with this name matches  </li>\n</ul>\n<p><strong>Returns</strong>:  - Network<br><a name=\"Network\"></a></p>\n<h1 id=\"Network\">Network</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#Network\">Network</a><ul>\n<li><a href=\"#Network#livenet\">network.livenet</a></li>\n<li><a href=\"#Network#testnet\">network.testnet</a></li>\n<li><a href=\"#Network#getNetwork\">network.getNetwork</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"Network#livenet\"></a></p>\n<h2 id=\"network-livenet-1\">network.livenet</h2>\n<p><a name=\"Network#testnet\"></a></p>\n<h2 id=\"network-testnet-1\">network.testnet</h2>\n<p><a name=\"Network#getNetwork\"></a></p>\n<h2 id=\"network-getNetwork-1\">network.getNetwork</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>arg <code>string</code> | <code>number</code> | <code><a href=\"#Network\">Network</a></code>  </li>\n<li>key <code>string</code> - if set, only check if the magic number associated with this name matches  </li>\n</ul>\n<p><strong>Returns</strong>:  - Network  </p>\n","source":"api/networks.md","raw":"#Index\n\n**Classes**\n\n* [class: Network](#Network)\n  * [new Network()](#new_Network)\n  * [network.livenet](#Network#livenet)\n  * [network.testnet](#Network#testnet)\n  * [network.getNetwork](#Network#getNetwork)\n\n**Namespaces**\n\n* [Network](#Network)\n  * [network.livenet](#Network#livenet)\n  * [network.testnet](#Network#testnet)\n  * [network.getNetwork](#Network#getNetwork)\n \n<a name=\"Network\"></a>\n#class: Network\n**Members**\n\n* [class: Network](#Network)\n  * [new Network()](#new_Network)\n  * [network.livenet](#Network#livenet)\n  * [network.testnet](#Network#testnet)\n  * [network.getNetwork](#Network#getNetwork)\n\n<a name=\"new_Network\"></a>\n##new Network()\nA network is merely a map containing values that correspond to version\nnumbers for each bitcoin network. Currently only supporting \"livenet\"\n(a.k.a. \"mainnet\") and \"testnet\".\n\n<a name=\"Network#livenet\"></a>\n##network.livenet\n<a name=\"Network#testnet\"></a>\n##network.testnet\n<a name=\"Network#getNetwork\"></a>\n##network.getNetwork\n**Params**\n\n- arg `string` | `number` | <code>[Network](#Network)</code>  \n- key `string` - if set, only check if the magic number associated with this name matches  \n\n**Returns**:  - Network  \n<a name=\"Network\"></a>\n#Network\n**Members**\n\n* [Network](#Network)\n  * [network.livenet](#Network#livenet)\n  * [network.testnet](#Network#testnet)\n  * [network.getNetwork](#Network#getNetwork)\n\n<a name=\"Network#livenet\"></a>\n##network.livenet\n<a name=\"Network#testnet\"></a>\n##network.testnet\n<a name=\"Network#getNetwork\"></a>\n##network.getNetwork\n**Params**\n\n- arg `string` | `number` | <code>[Network](#Network)</code>  \n- key `string` - if set, only check if the magic number associated with this name matches  \n\n**Returns**:  - Network  \n","date":1419285021000,"updated":1419285021000,"path":"api/networks.html","excerpt":"","_id":"c5ocndtyqoqy3dkr","title":"","comments":true,"layout":"page"},{"content":"","source":"api/opcode.md","raw":"","date":1419285018000,"updated":1419285018000,"path":"api/opcode.html","excerpt":"","_id":"1a00iodxium6osvl","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"PrivateKey\"></a></p>\n<h1 id=\"class:_PrivateKey\">class: PrivateKey</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#PrivateKey\">class: PrivateKey</a><ul>\n<li><a href=\"#new_PrivateKey\">new PrivateKey(data, [network])</a></li>\n<li><a href=\"#PrivateKey.fromString\">PrivateKey.fromString</a></li>\n<li><a href=\"#PrivateKey#toString\">privateKey.toString</a></li>\n<li><a href=\"#PrivateKey#_classifyArguments\">privateKey._classifyArguments(data, [network])</a></li>\n<li><a href=\"#PrivateKey.fromJSON\">PrivateKey.fromJSON(json)</a></li>\n<li><a href=\"#PrivateKey.fromRandom\">PrivateKey.fromRandom([network])</a></li>\n<li><a href=\"#PrivateKey.getValidationError\">PrivateKey.getValidationError(data, [network])</a></li>\n<li><a href=\"#PrivateKey.isValid\">PrivateKey.isValid(data, [network])</a></li>\n<li><a href=\"#PrivateKey#toBigNumber\">privateKey.toBigNumber()</a></li>\n<li><a href=\"#PrivateKey#toBuffer\">privateKey.toBuffer()</a></li>\n<li><a href=\"#PrivateKey#toPublicKey\">privateKey.toPublicKey()</a></li>\n<li><a href=\"#PrivateKey#toAddress\">privateKey.toAddress()</a></li>\n<li><a href=\"#PrivateKey#toObject\">privateKey.toObject()</a></li>\n<li><a href=\"#PrivateKey#inspect\">privateKey.inspect()</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"new_PrivateKey\"></a></p>\n<h2 id=\"new_PrivateKey(data,_[network])\">new PrivateKey(data, [network])</h2>\n<p>Instantiate a PrivateKey from a BN, Buffer and WIF.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>string</code> - The encoded data in various formats  </li>\n<li>[network] <code>Network</code> | <code>string</code> - a <code>Network</code> object, or a string with the network name  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#PrivateKey\">PrivateKey</a> - A new valid instance of an PrivateKey<br><strong>Example</strong>  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// generate a new random key</span></div><div class=\"line\"><span class=\"keyword\">var</span> key = PrivateKey();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// get the associated address</span></div><div class=\"line\"><span class=\"keyword\">var</span> address = key.toAddress();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// encode into wallet export format</span></div><div class=\"line\"><span class=\"keyword\">var</span> exported = key.toWIF();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// instantiate from the exported (and saved) private key</span></div><div class=\"line\"><span class=\"keyword\">var</span> imported = PrivateKey.fromWIF(exported);</div></pre></td></tr></table></figure>\n\n<p><a name=\"PrivateKey.fromString\"></a></p>\n<h2 id=\"PrivateKey-fromString\">PrivateKey.fromString</h2>\n<p>Instantiate a PrivateKey from a WIF string</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>str <code>String</code> - The WIF encoded private key string  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#PrivateKey\">PrivateKey</a> - A new valid instance of PrivateKey<br><a name=\"PrivateKey#toString\"></a></p>\n<h2 id=\"privateKey-toString\">privateKey.toString</h2>\n<p>Will output the PrivateKey to a WIF string</p>\n<p><strong>Returns</strong>: <code>String</code> - A WIP representation of the private key<br><a name=\"PrivateKey#_classifyArguments\"></a></p>\n<h2 id=\"privateKey-_classifyArguments(data,_[network])\">privateKey._classifyArguments(data, [network])</h2>\n<p>Internal helper to instantiate PrivateKey internal <code>info</code> object from<br>different kinds of arguments passed to the constructor.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>*</code>  </li>\n<li>[network] <code>Network</code> | <code>string</code> - a <code>Network</code> object, or a string with the network name  </li>\n</ul>\n<p><strong>Returns</strong>: <code>Object</code><br><a name=\"PrivateKey.fromJSON\"></a></p>\n<h2 id=\"PrivateKey-fromJSON(json)\">PrivateKey.fromJSON(json)</h2>\n<p>Instantiate a PrivateKey from a JSON string</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>json <code>String</code> - The JSON encoded private key string  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#PrivateKey\">PrivateKey</a> - A new valid instance of PrivateKey<br><a name=\"PrivateKey.fromRandom\"></a></p>\n<h2 id=\"PrivateKey-fromRandom([network])\">PrivateKey.fromRandom([network])</h2>\n<p>Instantiate a PrivateKey from random bytes</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>[network] <code>String</code> - Either “livenet” or “testnet”  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#PrivateKey\">PrivateKey</a> - A new valid instance of PrivateKey<br><a name=\"PrivateKey.getValidationError\"></a></p>\n<h2 id=\"PrivateKey-getValidationError(data,_[network])\">PrivateKey.getValidationError(data, [network])</h2>\n<p>Check if there would be any errors when initializing a PrivateKey</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>String</code> - The encoded data in various formats  </li>\n<li>[network] <code>String</code> - Either “livenet” or “testnet”  </li>\n</ul>\n<p><strong>Returns</strong>: <code>null</code> | <code>Error</code> - An error if exists<br><a name=\"PrivateKey.isValid\"></a></p>\n<h2 id=\"PrivateKey-isValid(data,_[network])\">PrivateKey.isValid(data, [network])</h2>\n<p>Check if the parameters are valid</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>String</code> - The encoded data in various formats  </li>\n<li>[network] <code>String</code> - Either “livenet” or “testnet”  </li>\n</ul>\n<p><strong>Returns</strong>: <code>Boolean</code> - If the private key is would be valid<br><a name=\"PrivateKey#toBigNumber\"></a></p>\n<h2 id=\"privateKey-toBigNumber()\">privateKey.toBigNumber()</h2>\n<p>Will return the private key as a BN instance</p>\n<p><strong>Returns</strong>: <code>BN</code> - A BN instance of the private key<br><a name=\"PrivateKey#toBuffer\"></a></p>\n<h2 id=\"privateKey-toBuffer()\">privateKey.toBuffer()</h2>\n<p>Will return the private key as a BN buffer</p>\n<p><strong>Returns</strong>: <code>Buffer</code> - A buffer of the private key<br><a name=\"PrivateKey#toPublicKey\"></a></p>\n<h2 id=\"privateKey-toPublicKey()\">privateKey.toPublicKey()</h2>\n<p>Will return the corresponding public key</p>\n<p><strong>Returns</strong>: <code>PublicKey</code> - A public key generated from the private key<br><a name=\"PrivateKey#toAddress\"></a></p>\n<h2 id=\"privateKey-toAddress()\">privateKey.toAddress()</h2>\n<p>Will return an address for the private key</p>\n<p><strong>Returns</strong>: <code>Address</code> - An address generated from the private key<br><a name=\"PrivateKey#toObject\"></a></p>\n<h2 id=\"privateKey-toObject()\">privateKey.toObject()</h2>\n<p><strong>Returns</strong>: <code>Object</code> - A plain object representation<br><a name=\"PrivateKey#inspect\"></a></p>\n<h2 id=\"privateKey-inspect()\">privateKey.inspect()</h2>\n<p>Will return a string formatted for the console</p>\n<p><strong>Returns</strong>: <code>String</code> - Private key  </p>\n","source":"api/privatekey.md","raw":"<a name=\"PrivateKey\"></a>\n#class: PrivateKey\n**Members**\n\n* [class: PrivateKey](#PrivateKey)\n  * [new PrivateKey(data, [network])](#new_PrivateKey)\n  * [PrivateKey.fromString](#PrivateKey.fromString)\n  * [privateKey.toString](#PrivateKey#toString)\n  * [privateKey._classifyArguments(data, [network])](#PrivateKey#_classifyArguments)\n  * [PrivateKey.fromJSON(json)](#PrivateKey.fromJSON)\n  * [PrivateKey.fromRandom([network])](#PrivateKey.fromRandom)\n  * [PrivateKey.getValidationError(data, [network])](#PrivateKey.getValidationError)\n  * [PrivateKey.isValid(data, [network])](#PrivateKey.isValid)\n  * [privateKey.toBigNumber()](#PrivateKey#toBigNumber)\n  * [privateKey.toBuffer()](#PrivateKey#toBuffer)\n  * [privateKey.toPublicKey()](#PrivateKey#toPublicKey)\n  * [privateKey.toAddress()](#PrivateKey#toAddress)\n  * [privateKey.toObject()](#PrivateKey#toObject)\n  * [privateKey.inspect()](#PrivateKey#inspect)\n\n<a name=\"new_PrivateKey\"></a>\n##new PrivateKey(data, [network])\nInstantiate a PrivateKey from a BN, Buffer and WIF.\n\n**Params**\n\n- data `string` - The encoded data in various formats  \n- \\[network\\] `Network` | `string` - a `Network` object, or a string with the network name  \n\n**Returns**: [PrivateKey](#PrivateKey) - A new valid instance of an PrivateKey  \n**Example**  \n```javascript\n// generate a new random key\nvar key = PrivateKey();\n\n// get the associated address\nvar address = key.toAddress();\n\n// encode into wallet export format\nvar exported = key.toWIF();\n\n// instantiate from the exported (and saved) private key\nvar imported = PrivateKey.fromWIF(exported);\n```\n\n<a name=\"PrivateKey.fromString\"></a>\n##PrivateKey.fromString\nInstantiate a PrivateKey from a WIF string\n\n**Params**\n\n- str `String` - The WIF encoded private key string  \n\n**Returns**: [PrivateKey](#PrivateKey) - A new valid instance of PrivateKey  \n<a name=\"PrivateKey#toString\"></a>\n##privateKey.toString\nWill output the PrivateKey to a WIF string\n\n**Returns**: `String` - A WIP representation of the private key  \n<a name=\"PrivateKey#_classifyArguments\"></a>\n##privateKey._classifyArguments(data, [network])\nInternal helper to instantiate PrivateKey internal `info` object from\ndifferent kinds of arguments passed to the constructor.\n\n**Params**\n\n- data `*`  \n- \\[network\\] `Network` | `string` - a `Network` object, or a string with the network name  \n\n**Returns**: `Object`  \n<a name=\"PrivateKey.fromJSON\"></a>\n##PrivateKey.fromJSON(json)\nInstantiate a PrivateKey from a JSON string\n\n**Params**\n\n- json `String` - The JSON encoded private key string  \n\n**Returns**: [PrivateKey](#PrivateKey) - A new valid instance of PrivateKey  \n<a name=\"PrivateKey.fromRandom\"></a>\n##PrivateKey.fromRandom([network])\nInstantiate a PrivateKey from random bytes\n\n**Params**\n\n- \\[network\\] `String` - Either \"livenet\" or \"testnet\"  \n\n**Returns**: [PrivateKey](#PrivateKey) - A new valid instance of PrivateKey  \n<a name=\"PrivateKey.getValidationError\"></a>\n##PrivateKey.getValidationError(data, [network])\nCheck if there would be any errors when initializing a PrivateKey\n\n**Params**\n\n- data `String` - The encoded data in various formats  \n- \\[network\\] `String` - Either \"livenet\" or \"testnet\"  \n\n**Returns**: `null` | `Error` - An error if exists  \n<a name=\"PrivateKey.isValid\"></a>\n##PrivateKey.isValid(data, [network])\nCheck if the parameters are valid\n\n**Params**\n\n- data `String` - The encoded data in various formats  \n- \\[network\\] `String` - Either \"livenet\" or \"testnet\"  \n\n**Returns**: `Boolean` - If the private key is would be valid  \n<a name=\"PrivateKey#toBigNumber\"></a>\n##privateKey.toBigNumber()\nWill return the private key as a BN instance\n\n**Returns**: `BN` - A BN instance of the private key  \n<a name=\"PrivateKey#toBuffer\"></a>\n##privateKey.toBuffer()\nWill return the private key as a BN buffer\n\n**Returns**: `Buffer` - A buffer of the private key  \n<a name=\"PrivateKey#toPublicKey\"></a>\n##privateKey.toPublicKey()\nWill return the corresponding public key\n\n**Returns**: `PublicKey` - A public key generated from the private key  \n<a name=\"PrivateKey#toAddress\"></a>\n##privateKey.toAddress()\nWill return an address for the private key\n\n**Returns**: `Address` - An address generated from the private key  \n<a name=\"PrivateKey#toObject\"></a>\n##privateKey.toObject()\n**Returns**: `Object` - A plain object representation  \n<a name=\"PrivateKey#inspect\"></a>\n##privateKey.inspect()\nWill return a string formatted for the console\n\n**Returns**: `String` - Private key  \n","date":1419285022000,"updated":1419285022000,"path":"api/privatekey.html","excerpt":"","_id":"n6x1lswt3fpjfi3g","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"PublicKey\"></a></p>\n<h1 id=\"class:_PublicKey\">class: PublicKey</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#PublicKey\">class: PublicKey</a><ul>\n<li><a href=\"#new_PublicKey\">new PublicKey(data, extra)</a></li>\n<li><a href=\"#PublicKey.fromDER\">PublicKey.fromDER</a></li>\n<li><a href=\"#PublicKey#toBuffer\">publicKey.toBuffer</a></li>\n<li><a href=\"#PublicKey#_classifyArgs\">publicKey._classifyArgs(data, extra)</a></li>\n<li><a href=\"#PublicKey.fromJSON\">PublicKey.fromJSON(json)</a></li>\n<li><a href=\"#PublicKey.fromPrivateKey\">PublicKey.fromPrivateKey(privkey)</a></li>\n<li><a href=\"#PublicKey.fromPoint\">PublicKey.fromPoint(point, [compressed])</a></li>\n<li><a href=\"#PublicKey.fromString\">PublicKey.fromString(str, [encoding])</a></li>\n<li><a href=\"#PublicKey.fromX\">PublicKey.fromX(odd, x)</a></li>\n<li><a href=\"#PublicKey.getValidationError\">PublicKey.getValidationError(data, [compressed])</a></li>\n<li><a href=\"#PublicKey.isValid\">PublicKey.isValid(data, [compressed])</a></li>\n<li><a href=\"#PublicKey#toObject\">publicKey.toObject()</a></li>\n<li><a href=\"#PublicKey#toAddress\">publicKey.toAddress()</a></li>\n<li><a href=\"#PublicKey#toString\">publicKey.toString()</a></li>\n<li><a href=\"#PublicKey#inspect\">publicKey.inspect()</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"new_PublicKey\"></a></p>\n<h2 id=\"new_PublicKey(data,_extra)\">new PublicKey(data, extra)</h2>\n<p>Instantiate a PublicKey from a <code>PrivateKey</code>, <code>Point</code>, <code>string</code>, or <code>Buffer</code>.</p>\n<p>There are two internal properties, <code>network</code> and <code>compressed</code>, that deal with importing<br>a PublicKey from a PrivateKey in WIF format. More details described on <code>PrivateKey</code></p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>String</code> - The encoded data in various formats  </li>\n<li>extra <code>Object</code> - additional options  <ul>\n<li>[network] <code>Network</code> - Which network should the address for this public key be for  </li>\n<li>[compressed] <code>String</code> - If the public key is compressed  </li>\n</ul>\n</li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#PublicKey\">PublicKey</a> - A new valid instance of an PublicKey<br><strong>Example</strong>  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// instantiate from a private key</span></div><div class=\"line\"><span class=\"keyword\">var</span> key = PublicKey(privateKey, <span class=\"literal\">true</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// export to as a DER hex encoded string</span></div><div class=\"line\"><span class=\"keyword\">var</span> exported = key.toString();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// import the public key</span></div><div class=\"line\"><span class=\"keyword\">var</span> imported = PublicKey.fromString(exported);</div></pre></td></tr></table></figure>\n\n<p><a name=\"PublicKey.fromDER\"></a></p>\n<h2 id=\"PublicKey-fromDER\">PublicKey.fromDER</h2>\n<p>Instantiate a PublicKey from a Buffer</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>buf <code>Buffer</code> - A DER hex buffer  </li>\n<li>[strict] <code>bool</code> - if set to false, will loosen some conditions  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#PublicKey\">PublicKey</a> - A new valid instance of PublicKey<br><a name=\"PublicKey#toBuffer\"></a></p>\n<h2 id=\"publicKey-toBuffer\">publicKey.toBuffer</h2>\n<p>Will output the PublicKey to a DER Buffer</p>\n<p><strong>Returns</strong>: <code>Buffer</code> - A DER hex encoded buffer<br><a name=\"PublicKey#_classifyArgs\"></a></p>\n<h2 id=\"publicKey-_classifyArgs(data,_extra)\">publicKey._classifyArgs(data, extra)</h2>\n<p>Internal function to differentiate between arguments passed to the constructor</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>*</code>  </li>\n<li>extra <code>Object</code>  </li>\n</ul>\n<p><a name=\"PublicKey.fromJSON\"></a></p>\n<h2 id=\"PublicKey-fromJSON(json)\">PublicKey.fromJSON(json)</h2>\n<p>Instantiate a PublicKey from JSON</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>json <code>String</code> - A JSON string  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#PublicKey\">PublicKey</a> - A new valid instance of PublicKey<br><a name=\"PublicKey.fromPrivateKey\"></a></p>\n<h2 id=\"PublicKey-fromPrivateKey(privkey)\">PublicKey.fromPrivateKey(privkey)</h2>\n<p>Instantiate a PublicKey from a PrivateKey</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>privkey <code>PrivateKey</code> - An instance of PrivateKey  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#PublicKey\">PublicKey</a> - A new valid instance of PublicKey<br><a name=\"PublicKey.fromPoint\"></a></p>\n<h2 id=\"PublicKey-fromPoint(point,_[compressed])\">PublicKey.fromPoint(point, [compressed])</h2>\n<p>Instantiate a PublicKey from a Point</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>point <code>Point</code> - A Point instance  </li>\n<li>[compressed] <code>boolean</code> - whether to store this public key as compressed format  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#PublicKey\">PublicKey</a> - A new valid instance of PublicKey<br><a name=\"PublicKey.fromString\"></a></p>\n<h2 id=\"PublicKey-fromString(str,_[encoding])\">PublicKey.fromString(str, [encoding])</h2>\n<p>Instantiate a PublicKey from a DER hex encoded string</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>str <code>String</code> - A DER hex string  </li>\n<li>[encoding] <code>String</code> - The type of string encoding  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#PublicKey\">PublicKey</a> - A new valid instance of PublicKey<br><a name=\"PublicKey.fromX\"></a></p>\n<h2 id=\"PublicKey-fromX(odd,_x)\">PublicKey.fromX(odd, x)</h2>\n<p>Instantiate a PublicKey from an X Point</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>odd <code>Boolean</code> - If the point is above or below the x axis  </li>\n<li>x <code>Point</code> - The x point  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#PublicKey\">PublicKey</a> - A new valid instance of PublicKey<br><a name=\"PublicKey.getValidationError\"></a></p>\n<h2 id=\"PublicKey-getValidationError(data,_[compressed])\">PublicKey.getValidationError(data, [compressed])</h2>\n<p>Check if there would be any errors when initializing a PublicKey</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>String</code> - The encoded data in various formats  </li>\n<li>[compressed] <code>String</code> - If the public key is compressed  </li>\n</ul>\n<p><strong>Returns</strong>: <code>null</code> | <code>Error</code> - An error if exists<br><a name=\"PublicKey.isValid\"></a></p>\n<h2 id=\"PublicKey-isValid(data,_[compressed])\">PublicKey.isValid(data, [compressed])</h2>\n<p>Check if the parameters are valid</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>String</code> - The encoded data in various formats  </li>\n<li>[compressed] <code>String</code> - If the public key is compressed  </li>\n</ul>\n<p><strong>Returns</strong>: <code>Boolean</code> - If the public key would be valid<br><a name=\"PublicKey#toObject\"></a></p>\n<h2 id=\"publicKey-toObject()\">publicKey.toObject()</h2>\n<p><strong>Returns</strong>: <code>Object</code> - A plain object of the PublicKey<br><a name=\"PublicKey#toAddress\"></a></p>\n<h2 id=\"publicKey-toAddress()\">publicKey.toAddress()</h2>\n<p>Will return an address for the public key</p>\n<p><strong>Returns</strong>: <code>Address</code> - An address generated from the public key<br><a name=\"PublicKey#toString\"></a></p>\n<h2 id=\"publicKey-toString()\">publicKey.toString()</h2>\n<p>Will output the PublicKey to a DER encoded hex string</p>\n<p><strong>Returns</strong>: <code>String</code> - A DER hex encoded string<br><a name=\"PublicKey#inspect\"></a></p>\n<h2 id=\"publicKey-inspect()\">publicKey.inspect()</h2>\n<p>Will return a string formatted for the console</p>\n<p><strong>Returns</strong>: <code>String</code> - Public key  </p>\n","source":"api/publickey.md","raw":"<a name=\"PublicKey\"></a>\n#class: PublicKey\n**Members**\n\n* [class: PublicKey](#PublicKey)\n  * [new PublicKey(data, extra)](#new_PublicKey)\n  * [PublicKey.fromDER](#PublicKey.fromDER)\n  * [publicKey.toBuffer](#PublicKey#toBuffer)\n  * [publicKey._classifyArgs(data, extra)](#PublicKey#_classifyArgs)\n  * [PublicKey.fromJSON(json)](#PublicKey.fromJSON)\n  * [PublicKey.fromPrivateKey(privkey)](#PublicKey.fromPrivateKey)\n  * [PublicKey.fromPoint(point, [compressed])](#PublicKey.fromPoint)\n  * [PublicKey.fromString(str, [encoding])](#PublicKey.fromString)\n  * [PublicKey.fromX(odd, x)](#PublicKey.fromX)\n  * [PublicKey.getValidationError(data, [compressed])](#PublicKey.getValidationError)\n  * [PublicKey.isValid(data, [compressed])](#PublicKey.isValid)\n  * [publicKey.toObject()](#PublicKey#toObject)\n  * [publicKey.toAddress()](#PublicKey#toAddress)\n  * [publicKey.toString()](#PublicKey#toString)\n  * [publicKey.inspect()](#PublicKey#inspect)\n\n<a name=\"new_PublicKey\"></a>\n##new PublicKey(data, extra)\nInstantiate a PublicKey from a `PrivateKey`, `Point`, `string`, or `Buffer`.\n\nThere are two internal properties, `network` and `compressed`, that deal with importing\na PublicKey from a PrivateKey in WIF format. More details described on `PrivateKey`\n\n**Params**\n\n- data `String` - The encoded data in various formats  \n- extra `Object` - additional options  \n  - \\[network\\] `Network` - Which network should the address for this public key be for  \n  - \\[compressed\\] `String` - If the public key is compressed  \n\n**Returns**: [PublicKey](#PublicKey) - A new valid instance of an PublicKey  \n**Example**  \n```javascript\n// instantiate from a private key\nvar key = PublicKey(privateKey, true);\n\n// export to as a DER hex encoded string\nvar exported = key.toString();\n\n// import the public key\nvar imported = PublicKey.fromString(exported);\n```\n\n<a name=\"PublicKey.fromDER\"></a>\n##PublicKey.fromDER\nInstantiate a PublicKey from a Buffer\n\n**Params**\n\n- buf `Buffer` - A DER hex buffer  \n- \\[strict\\] `bool` - if set to false, will loosen some conditions  \n\n**Returns**: [PublicKey](#PublicKey) - A new valid instance of PublicKey  \n<a name=\"PublicKey#toBuffer\"></a>\n##publicKey.toBuffer\nWill output the PublicKey to a DER Buffer\n\n**Returns**: `Buffer` - A DER hex encoded buffer  \n<a name=\"PublicKey#_classifyArgs\"></a>\n##publicKey._classifyArgs(data, extra)\nInternal function to differentiate between arguments passed to the constructor\n\n**Params**\n\n- data `*`  \n- extra `Object`  \n\n<a name=\"PublicKey.fromJSON\"></a>\n##PublicKey.fromJSON(json)\nInstantiate a PublicKey from JSON\n\n**Params**\n\n- json `String` - A JSON string  \n\n**Returns**: [PublicKey](#PublicKey) - A new valid instance of PublicKey  \n<a name=\"PublicKey.fromPrivateKey\"></a>\n##PublicKey.fromPrivateKey(privkey)\nInstantiate a PublicKey from a PrivateKey\n\n**Params**\n\n- privkey `PrivateKey` - An instance of PrivateKey  \n\n**Returns**: [PublicKey](#PublicKey) - A new valid instance of PublicKey  \n<a name=\"PublicKey.fromPoint\"></a>\n##PublicKey.fromPoint(point, [compressed])\nInstantiate a PublicKey from a Point\n\n**Params**\n\n- point `Point` - A Point instance  \n- \\[compressed\\] `boolean` - whether to store this public key as compressed format  \n\n**Returns**: [PublicKey](#PublicKey) - A new valid instance of PublicKey  \n<a name=\"PublicKey.fromString\"></a>\n##PublicKey.fromString(str, [encoding])\nInstantiate a PublicKey from a DER hex encoded string\n\n**Params**\n\n- str `String` - A DER hex string  \n- \\[encoding\\] `String` - The type of string encoding  \n\n**Returns**: [PublicKey](#PublicKey) - A new valid instance of PublicKey  \n<a name=\"PublicKey.fromX\"></a>\n##PublicKey.fromX(odd, x)\nInstantiate a PublicKey from an X Point\n\n**Params**\n\n- odd `Boolean` - If the point is above or below the x axis  \n- x `Point` - The x point  \n\n**Returns**: [PublicKey](#PublicKey) - A new valid instance of PublicKey  \n<a name=\"PublicKey.getValidationError\"></a>\n##PublicKey.getValidationError(data, [compressed])\nCheck if there would be any errors when initializing a PublicKey\n\n**Params**\n\n- data `String` - The encoded data in various formats  \n- \\[compressed\\] `String` - If the public key is compressed  \n\n**Returns**: `null` | `Error` - An error if exists  \n<a name=\"PublicKey.isValid\"></a>\n##PublicKey.isValid(data, [compressed])\nCheck if the parameters are valid\n\n**Params**\n\n- data `String` - The encoded data in various formats  \n- \\[compressed\\] `String` - If the public key is compressed  \n\n**Returns**: `Boolean` - If the public key would be valid  \n<a name=\"PublicKey#toObject\"></a>\n##publicKey.toObject()\n**Returns**: `Object` - A plain object of the PublicKey  \n<a name=\"PublicKey#toAddress\"></a>\n##publicKey.toAddress()\nWill return an address for the public key\n\n**Returns**: `Address` - An address generated from the public key  \n<a name=\"PublicKey#toString\"></a>\n##publicKey.toString()\nWill output the PublicKey to a DER encoded hex string\n\n**Returns**: `String` - A DER hex encoded string  \n<a name=\"PublicKey#inspect\"></a>\n##publicKey.inspect()\nWill return a string formatted for the console\n\n**Returns**: `String` - Public key  \n","date":1419285022000,"updated":1419285022000,"path":"api/publickey.html","excerpt":"","_id":"ip5o942m1hp1pmfy","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"Unit\"></a></p>\n<h1 id=\"class:_Unit\">class: Unit</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#Unit\">class: Unit</a><ul>\n<li><a href=\"#new_Unit\">new Unit(amount, code)</a></li>\n<li><a href=\"#Unit.fromMicros\">Unit.fromMicros</a></li>\n<li><a href=\"#Unit#toMicros\">unit.toMicros</a></li>\n<li><a href=\"#Unit.fromJSON\">Unit.fromJSON(json)</a></li>\n<li><a href=\"#Unit.fromBTC\">Unit.fromBTC(amount)</a></li>\n<li><a href=\"#Unit.fromMilis\">Unit.fromMilis(amount)</a></li>\n<li><a href=\"#Unit.fromSatoshis\">Unit.fromSatoshis(amount)</a></li>\n<li><a href=\"#Unit#to\">unit.to(code)</a></li>\n<li><a href=\"#Unit#toBTC\">unit.toBTC()</a></li>\n<li><a href=\"#Unit#toMilis\">unit.toMilis()</a></li>\n<li><a href=\"#Unit#toSatoshis\">unit.toSatoshis()</a></li>\n<li><a href=\"#Unit#toString\">unit.toString()</a></li>\n<li><a href=\"#Unit#toObject\">unit.toObject()</a></li>\n<li><a href=\"#Unit#inspect\">unit.inspect()</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"new_Unit\"></a></p>\n<h2 id=\"new_Unit(amount,_code)\">new Unit(amount, code)</h2>\n<p>Utility for handling and converting bitcoins units. The supported units are<br>BTC, mBTC, bits (also named uBTC) and satoshis. A unit instance can be created with an<br>amount and a unit code, or alternatively using static methods like {fromBTC}.<br>You can consult for different representation of a unit instance using it’s<br>{to} method, the fixed unit methods like {toSatoshis} or alternatively using<br>the unit accessors.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>amount <code>Number</code> - The amount to be represented  </li>\n<li>code <code>String</code> - The unit of the amount  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Unit\">Unit</a> - A new instance of an Unit<br><strong>Example</strong>  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> sats = Unit.fromBTC(<span class=\"number\">1.3</span>).toSatoshis();</div><div class=\"line\"><span class=\"keyword\">var</span> mili = Unit.fromBits(<span class=\"number\">1.3</span>).to(Unit.mBTC);</div><div class=\"line\"><span class=\"keyword\">var</span> btc = <span class=\"keyword\">new</span> Unit(<span class=\"number\">1.3</span>, Unit.bits).BTC;</div></pre></td></tr></table></figure>\n\n<p><a name=\"Unit.fromMicros\"></a></p>\n<h2 id=\"Unit-fromMicros\">Unit.fromMicros</h2>\n<p>Returns a Unit instance created from an amount in bits</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>amount <code>Number</code> - The amount in bits  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Unit\">Unit</a> - A Unit instance<br><a name=\"Unit#toMicros\"></a></p>\n<h2 id=\"unit-toMicros\">unit.toMicros</h2>\n<p>Returns the value represented in bits</p>\n<p><strong>Returns</strong>: <code>Number</code> - The value converted to bits<br><a name=\"Unit.fromJSON\"></a></p>\n<h2 id=\"Unit-fromJSON(json)\">Unit.fromJSON(json)</h2>\n<p>Returns a Unit instance created from JSON string or object</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>json <code>String</code> | <code>Object</code> - JSON with keys: amount and code  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Unit\">Unit</a> - A Unit instance<br><a name=\"Unit.fromBTC\"></a></p>\n<h2 id=\"Unit-fromBTC(amount)\">Unit.fromBTC(amount)</h2>\n<p>Returns a Unit instance created from an amount in BTC</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>amount <code>Number</code> - The amount in BTC  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Unit\">Unit</a> - A Unit instance<br><a name=\"Unit.fromMilis\"></a></p>\n<h2 id=\"Unit-fromMilis(amount)\">Unit.fromMilis(amount)</h2>\n<p>Returns a Unit instance created from an amount in mBTC</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>amount <code>Number</code> - The amount in mBTC  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Unit\">Unit</a> - A Unit instance<br><a name=\"Unit.fromSatoshis\"></a></p>\n<h2 id=\"Unit-fromSatoshis(amount)\">Unit.fromSatoshis(amount)</h2>\n<p>Returns a Unit instance created from an amount in satoshis</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>amount <code>Number</code> - The amount in satoshis  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Unit\">Unit</a> - A Unit instance<br><a name=\"Unit#to\"></a></p>\n<h2 id=\"unit-to(code)\">unit.to(code)</h2>\n<p>Returns the value represented in the specified unit</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>code <code>string</code> - The unit code  </li>\n</ul>\n<p><strong>Returns</strong>: <code>Number</code> - The converted value<br><a name=\"Unit#toBTC\"></a></p>\n<h2 id=\"unit-toBTC()\">unit.toBTC()</h2>\n<p>Returns the value represented in BTC</p>\n<p><strong>Returns</strong>: <code>Number</code> - The value converted to BTC<br><a name=\"Unit#toMilis\"></a></p>\n<h2 id=\"unit-toMilis()\">unit.toMilis()</h2>\n<p>Returns the value represented in mBTC</p>\n<p><strong>Returns</strong>: <code>Number</code> - The value converted to mBTC<br><a name=\"Unit#toSatoshis\"></a></p>\n<h2 id=\"unit-toSatoshis()\">unit.toSatoshis()</h2>\n<p>Returns the value represented in satoshis</p>\n<p><strong>Returns</strong>: <code>Number</code> - The value converted to satoshis<br><a name=\"Unit#toString\"></a></p>\n<h2 id=\"unit-toString()\">unit.toString()</h2>\n<p>Returns a the string representation of the value in satoshis</p>\n<p><strong>Returns</strong>: <code>String</code> - the value in satoshis<br><a name=\"Unit#toObject\"></a></p>\n<h2 id=\"unit-toObject()\">unit.toObject()</h2>\n<p>Returns a plain object representation of the Unit</p>\n<p><strong>Returns</strong>: <code>Object</code> - An object with the keys: amount and code<br><a name=\"Unit#inspect\"></a></p>\n<h2 id=\"unit-inspect()\">unit.inspect()</h2>\n<p>Returns a string formatted for the console</p>\n<p><strong>Returns</strong>: <code>String</code> - the value in satoshis  </p>\n","source":"api/unit.md","raw":"<a name=\"Unit\"></a>\n#class: Unit\n**Members**\n\n* [class: Unit](#Unit)\n  * [new Unit(amount, code)](#new_Unit)\n  * [Unit.fromMicros](#Unit.fromMicros)\n  * [unit.toMicros](#Unit#toMicros)\n  * [Unit.fromJSON(json)](#Unit.fromJSON)\n  * [Unit.fromBTC(amount)](#Unit.fromBTC)\n  * [Unit.fromMilis(amount)](#Unit.fromMilis)\n  * [Unit.fromSatoshis(amount)](#Unit.fromSatoshis)\n  * [unit.to(code)](#Unit#to)\n  * [unit.toBTC()](#Unit#toBTC)\n  * [unit.toMilis()](#Unit#toMilis)\n  * [unit.toSatoshis()](#Unit#toSatoshis)\n  * [unit.toString()](#Unit#toString)\n  * [unit.toObject()](#Unit#toObject)\n  * [unit.inspect()](#Unit#inspect)\n\n<a name=\"new_Unit\"></a>\n##new Unit(amount, code)\nUtility for handling and converting bitcoins units. The supported units are\nBTC, mBTC, bits (also named uBTC) and satoshis. A unit instance can be created with an\namount and a unit code, or alternatively using static methods like {fromBTC}.\nYou can consult for different representation of a unit instance using it's\n{to} method, the fixed unit methods like {toSatoshis} or alternatively using\nthe unit accessors.\n\n**Params**\n\n- amount `Number` - The amount to be represented  \n- code `String` - The unit of the amount  \n\n**Returns**: [Unit](#Unit) - A new instance of an Unit  \n**Example**  \n```javascript\nvar sats = Unit.fromBTC(1.3).toSatoshis();\nvar mili = Unit.fromBits(1.3).to(Unit.mBTC);\nvar btc = new Unit(1.3, Unit.bits).BTC;\n```\n\n<a name=\"Unit.fromMicros\"></a>\n##Unit.fromMicros\nReturns a Unit instance created from an amount in bits\n\n**Params**\n\n- amount `Number` - The amount in bits  \n\n**Returns**: [Unit](#Unit) - A Unit instance  \n<a name=\"Unit#toMicros\"></a>\n##unit.toMicros\nReturns the value represented in bits\n\n**Returns**: `Number` - The value converted to bits  \n<a name=\"Unit.fromJSON\"></a>\n##Unit.fromJSON(json)\nReturns a Unit instance created from JSON string or object\n\n**Params**\n\n- json `String` | `Object` - JSON with keys: amount and code  \n\n**Returns**: [Unit](#Unit) - A Unit instance  \n<a name=\"Unit.fromBTC\"></a>\n##Unit.fromBTC(amount)\nReturns a Unit instance created from an amount in BTC\n\n**Params**\n\n- amount `Number` - The amount in BTC  \n\n**Returns**: [Unit](#Unit) - A Unit instance  \n<a name=\"Unit.fromMilis\"></a>\n##Unit.fromMilis(amount)\nReturns a Unit instance created from an amount in mBTC\n\n**Params**\n\n- amount `Number` - The amount in mBTC  \n\n**Returns**: [Unit](#Unit) - A Unit instance  \n<a name=\"Unit.fromSatoshis\"></a>\n##Unit.fromSatoshis(amount)\nReturns a Unit instance created from an amount in satoshis\n\n**Params**\n\n- amount `Number` - The amount in satoshis  \n\n**Returns**: [Unit](#Unit) - A Unit instance  \n<a name=\"Unit#to\"></a>\n##unit.to(code)\nReturns the value represented in the specified unit\n\n**Params**\n\n- code `string` - The unit code  \n\n**Returns**: `Number` - The converted value  \n<a name=\"Unit#toBTC\"></a>\n##unit.toBTC()\nReturns the value represented in BTC\n\n**Returns**: `Number` - The value converted to BTC  \n<a name=\"Unit#toMilis\"></a>\n##unit.toMilis()\nReturns the value represented in mBTC\n\n**Returns**: `Number` - The value converted to mBTC  \n<a name=\"Unit#toSatoshis\"></a>\n##unit.toSatoshis()\nReturns the value represented in satoshis\n\n**Returns**: `Number` - The value converted to satoshis  \n<a name=\"Unit#toString\"></a>\n##unit.toString()\nReturns a the string representation of the value in satoshis\n\n**Returns**: `String` - the value in satoshis  \n<a name=\"Unit#toObject\"></a>\n##unit.toObject()\nReturns a plain object representation of the Unit\n\n**Returns**: `Object` - An object with the keys: amount and code  \n<a name=\"Unit#inspect\"></a>\n##unit.inspect()\nReturns a string formatted for the console\n\n**Returns**: `String` - the value in satoshis  \n","date":1419285022000,"updated":1419285022000,"path":"api/unit.html","excerpt":"","_id":"hahfujvgnpxkmwzs","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"URI\"></a></p>\n<h1 id=\"class:_URI\">class: URI</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#URI\">class: URI</a><ul>\n<li><a href=\"#new_URI\">new URI(data, [knownParams])</a></li>\n<li><a href=\"#URI.fromString\">URI.fromString(str)</a></li>\n<li><a href=\"#URI.fromJSON\">URI.fromJSON(json)</a></li>\n<li><a href=\"#URI.isValid\">URI.isValid(data, [knownParams])</a></li>\n<li><a href=\"#URI.parse\">URI.parse(uri)</a></li>\n<li><a href=\"#URI#_fromObject\">uRI._fromObject(obj)</a></li>\n<li><a href=\"#URI#_parseAmount\">uRI._parseAmount(amount)</a></li>\n<li><a href=\"#URI#toString\">uRI.toString()</a></li>\n<li><a href=\"#URI#inspect\">uRI.inspect()</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"new_URI\"></a></p>\n<h2 id=\"new_URI(data,_[knownParams])\">new URI(data, [knownParams])</h2>\n<p>Bitcore URI</p>\n<p>Instantiate an URI from a bitcoin URI String or an Object. An URI instance<br>can be created with a bitcoin uri string or an object. All instances of<br>URI are valid, the static method isValid allows checking before instanciation.</p>\n<p>All standard parameters can be found as members of the class, the address<br>is represented using an {Address} instance and the amount is represented in<br>satoshis. Any other non-standard parameters can be found under the extra member.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>string</code> | <code>Object</code> - A bitcoin URI string or an Object  </li>\n<li>[knownParams] <code>Array.&lt;string&gt;</code> - Required non-standard params  </li>\n</ul>\n<p><strong>Type</strong>: <code>TypeError</code><br><strong>Returns</strong>: <a href=\"#URI\">URI</a> - A new valid and frozen instance of URI<br><strong>Example</strong>  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> uri = <span class=\"keyword\">new</span> URI(<span class=\"string\">'bitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu?amount=1.2'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(uri.address, uri.amount);</div></pre></td></tr></table></figure>\n\n<p><a name=\"URI.fromString\"></a></p>\n<h2 id=\"URI-fromString(str)\">URI.fromString(str)</h2>\n<p>Instantiate a URI from a String</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>str <code>String</code> - JSON string or object of the URI  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#URI\">URI</a> - A new instance of a URI<br><a name=\"URI.fromJSON\"></a></p>\n<h2 id=\"URI-fromJSON(json)\">URI.fromJSON(json)</h2>\n<p>Instantiate a URI from JSON</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>json <code>String</code> | <code>Object</code> - JSON string or object of the URI  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#URI\">URI</a> - A new instance of a URI<br><a name=\"URI.isValid\"></a></p>\n<h2 id=\"URI-isValid(data,_[knownParams])\">URI.isValid(data, [knownParams])</h2>\n<p>Check if an bitcoin URI string is valid</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>data <code>string</code> | <code>Object</code> - A bitcoin URI string or an Object  </li>\n<li>[knownParams] <code>Array.&lt;string&gt;</code> - Required non-standard params  </li>\n</ul>\n<p><strong>Returns</strong>: <code>boolean</code> - Result of uri validation<br><strong>Example</strong>  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> valid = URI.isValid(<span class=\"string\">'bitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu'</span>);</div><div class=\"line\"><span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n\n<p><a name=\"URI.parse\"></a></p>\n<h2 id=\"URI-parse(uri)\">URI.parse(uri)</h2>\n<p>Convert a bitcoin URI string into a simple object.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>uri <code>string</code> - A bitcoin URI string  </li>\n</ul>\n<p><strong>Type</strong>: <code>TypeError</code><br><strong>Returns</strong>: <code>Object</code> - An object with the parsed params<br><a name=\"URI#_fromObject\"></a></p>\n<h2 id=\"uRI-_fromObject(obj)\">uRI._fromObject(obj)</h2>\n<p>Internal function to load the URI instance with an object.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>obj <code>Object</code> - Object with the information  </li>\n</ul>\n<p><strong>Type</strong>: <code>TypeError</code><br><a name=\"URI#_parseAmount\"></a></p>\n<h2 id=\"uRI-_parseAmount(amount)\">uRI._parseAmount(amount)</h2>\n<p>Internal function to transform a BTC string amount into satoshis</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>amount <code>String</code> - Amount BTC string  </li>\n</ul>\n<p><strong>Type</strong>: <code>TypeError</code><br><strong>Returns</strong>: <code>Object</code> - Amount represented in satoshis<br><a name=\"URI#toString\"></a></p>\n<h2 id=\"uRI-toString()\">uRI.toString()</h2>\n<p>Will return a the string representation of the URI</p>\n<p><strong>Returns</strong>: <code>String</code> - Bitcoin URI string<br><a name=\"URI#inspect\"></a></p>\n<h2 id=\"uRI-inspect()\">uRI.inspect()</h2>\n<p>Will return a string formatted for the console</p>\n<p><strong>Returns</strong>: <code>String</code> - Bitcoin URI  </p>\n","source":"api/uri.md","raw":"<a name=\"URI\"></a>\n#class: URI\n**Members**\n\n* [class: URI](#URI)\n  * [new URI(data, [knownParams])](#new_URI)\n  * [URI.fromString(str)](#URI.fromString)\n  * [URI.fromJSON(json)](#URI.fromJSON)\n  * [URI.isValid(data, [knownParams])](#URI.isValid)\n  * [URI.parse(uri)](#URI.parse)\n  * [uRI._fromObject(obj)](#URI#_fromObject)\n  * [uRI._parseAmount(amount)](#URI#_parseAmount)\n  * [uRI.toString()](#URI#toString)\n  * [uRI.inspect()](#URI#inspect)\n\n<a name=\"new_URI\"></a>\n##new URI(data, [knownParams])\nBitcore URI\n\nInstantiate an URI from a bitcoin URI String or an Object. An URI instance\ncan be created with a bitcoin uri string or an object. All instances of\nURI are valid, the static method isValid allows checking before instanciation.\n\nAll standard parameters can be found as members of the class, the address\nis represented using an {Address} instance and the amount is represented in\nsatoshis. Any other non-standard parameters can be found under the extra member.\n\n**Params**\n\n- data `string` | `Object` - A bitcoin URI string or an Object  \n- \\[knownParams\\] `Array.<string>` - Required non-standard params  \n\n**Type**: `TypeError`  \n**Returns**: [URI](#URI) - A new valid and frozen instance of URI  \n**Example**  \n```javascript\n\nvar uri = new URI('bitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu?amount=1.2');\nconsole.log(uri.address, uri.amount);\n```\n\n<a name=\"URI.fromString\"></a>\n##URI.fromString(str)\nInstantiate a URI from a String\n\n**Params**\n\n- str `String` - JSON string or object of the URI  \n\n**Returns**: [URI](#URI) - A new instance of a URI  \n<a name=\"URI.fromJSON\"></a>\n##URI.fromJSON(json)\nInstantiate a URI from JSON\n\n**Params**\n\n- json `String` | `Object` - JSON string or object of the URI  \n\n**Returns**: [URI](#URI) - A new instance of a URI  \n<a name=\"URI.isValid\"></a>\n##URI.isValid(data, [knownParams])\nCheck if an bitcoin URI string is valid\n\n**Params**\n\n- data `string` | `Object` - A bitcoin URI string or an Object  \n- \\[knownParams\\] `Array.<string>` - Required non-standard params  \n\n**Returns**: `boolean` - Result of uri validation  \n**Example**  \n```javascript\n\nvar valid = URI.isValid('bitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu');\n// true\n```\n\n<a name=\"URI.parse\"></a>\n##URI.parse(uri)\nConvert a bitcoin URI string into a simple object.\n\n**Params**\n\n- uri `string` - A bitcoin URI string  \n\n**Type**: `TypeError`  \n**Returns**: `Object` - An object with the parsed params  \n<a name=\"URI#_fromObject\"></a>\n##uRI._fromObject(obj)\nInternal function to load the URI instance with an object.\n\n**Params**\n\n- obj `Object` - Object with the information  \n\n**Type**: `TypeError`  \n<a name=\"URI#_parseAmount\"></a>\n##uRI._parseAmount(amount)\nInternal function to transform a BTC string amount into satoshis\n\n**Params**\n\n- amount `String` - Amount BTC string  \n\n**Type**: `TypeError`  \n**Returns**: `Object` - Amount represented in satoshis  \n<a name=\"URI#toString\"></a>\n##uRI.toString()\nWill return a the string representation of the URI\n\n**Returns**: `String` - Bitcoin URI string  \n<a name=\"URI#inspect\"></a>\n##uRI.inspect()\nWill return a string formatted for the console\n\n**Returns**: `String` - Bitcoin URI  \n","date":1419285022000,"updated":1419285022000,"path":"api/uri.html","excerpt":"","_id":"cjfsvr4xcra071jy","title":"","comments":true,"layout":"page"},{"content":"","source":"api/crypto/bn.md","raw":"","date":1419285018000,"updated":1419285018000,"path":"api/crypto/bn.html","excerpt":"","_id":"zughq78ftky1nti7","title":"","comments":true,"layout":"page"},{"content":"","source":"api/crypto/ecdsa.md","raw":"","date":1419285018000,"updated":1419285018000,"path":"api/crypto/ecdsa.html","excerpt":"","_id":"ilyltj61nct3owkb","title":"","comments":true,"layout":"page"},{"content":"","source":"api/crypto/hash.md","raw":"","date":1419285019000,"updated":1419285019000,"path":"api/crypto/hash.html","excerpt":"","_id":"yrai0d3bcdnyzoji","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"Point\"></a></p>\n<h1 id=\"class:_Point\">class: Point</h1>\n<p><strong>Extends</strong>: <code>elliptic.curve.point</code><br><strong>Members</strong></p>\n<ul>\n<li><a href=\"#Point\">class: Point</a><ul>\n<li><a href=\"#new_Point\">new Point(x, y)</a></li>\n<li><a href=\"#Point.fromX\">Point.fromX(odd, x)</a></li>\n<li><a href=\"#Point.getG\">Point.getG()</a></li>\n<li><a href=\"#Point.getN\">Point.getN()</a></li>\n<li><a href=\"#Point#getX\">point.getX()</a></li>\n<li><a href=\"#Point#getY\">point.getY()</a></li>\n<li><a href=\"#Point#validate\">point.validate(An)</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"new_Point\"></a></p>\n<h2 id=\"new_Point(x,_y)\">new Point(x, y)</h2>\n<p>Instantiate a valid secp256k1 Point from the X and Y coordinates.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>x <code>BN</code> | <code>String</code> - The X coordinate  </li>\n<li>y <code>BN</code> | <code>String</code> - The Y coordinate  </li>\n</ul>\n<p><strong>Extends</strong>: <code>elliptic.curve.point</code><br><strong>Type</strong>: <code>Error</code><br><strong>Returns</strong>: <a href=\"#Point\">Point</a> - An instance of Point<br><a name=\"Point.fromX\"></a></p>\n<h2 id=\"Point-fromX(odd,_x)\">Point.fromX(odd, x)</h2>\n<p>Instantiate a valid secp256k1 Point from only the X coordinate</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>odd <code>boolean</code> - If the Y coordinate is odd  </li>\n<li>x <code>BN</code> | <code>String</code> - The X coordinate  </li>\n</ul>\n<p><strong>Type</strong>: <code>Error</code><br><strong>Returns</strong>: <a href=\"#Point\">Point</a> - An instance of Point<br><a name=\"Point.getG\"></a></p>\n<h2 id=\"Point-getG()\">Point.getG()</h2>\n<p>Will return a secp256k1 ECDSA base point.</p>\n<p><strong>Returns</strong>: <a href=\"#Point\">Point</a> - An instance of the base point.<br><a name=\"Point.getN\"></a></p>\n<h2 id=\"Point-getN()\">Point.getN()</h2>\n<p>Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.</p>\n<p><strong>Returns</strong>: <code>BN</code> - A BN instance of the number of points on the curve<br><a name=\"Point#getX\"></a></p>\n<h2 id=\"point-getX()\">point.getX()</h2>\n<p>Will return the X coordinate of the Point</p>\n<p><strong>Returns</strong>: <code>BN</code> - A BN instance of the X coordinate<br><a name=\"Point#getY\"></a></p>\n<h2 id=\"point-getY()\">point.getY()</h2>\n<p>Will return the Y coordinate of the Point</p>\n<p><strong>Returns</strong>: <code>BN</code> - A BN instance of the Y coordinate<br><a name=\"Point#validate\"></a></p>\n<h2 id=\"point-validate(An)\">point.validate(An)</h2>\n<p>Will determine if the point is valid</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>An <code><a href=\"#Point\">Point</a></code> - instance of Point  </li>\n</ul>\n<p><strong>Type</strong>: <code>Error</code><br><strong>Returns</strong>: <a href=\"#Point\">Point</a> - An instance of the same Point  </p>\n","source":"api/crypto/point.md","raw":"<a name=\"Point\"></a>\n#class: Point\n**Extends**: `elliptic.curve.point`  \n**Members**\n\n* [class: Point](#Point)\n  * [new Point(x, y)](#new_Point)\n  * [Point.fromX(odd, x)](#Point.fromX)\n  * [Point.getG()](#Point.getG)\n  * [Point.getN()](#Point.getN)\n  * [point.getX()](#Point#getX)\n  * [point.getY()](#Point#getY)\n  * [point.validate(An)](#Point#validate)\n\n<a name=\"new_Point\"></a>\n##new Point(x, y)\nInstantiate a valid secp256k1 Point from the X and Y coordinates.\n\n**Params**\n\n- x `BN` | `String` - The X coordinate  \n- y `BN` | `String` - The Y coordinate  \n\n**Extends**: `elliptic.curve.point`  \n**Type**: `Error`  \n**Returns**: [Point](#Point) - An instance of Point  \n<a name=\"Point.fromX\"></a>\n##Point.fromX(odd, x)\nInstantiate a valid secp256k1 Point from only the X coordinate\n\n**Params**\n\n- odd `boolean` - If the Y coordinate is odd  \n- x `BN` | `String` - The X coordinate  \n\n**Type**: `Error`  \n**Returns**: [Point](#Point) - An instance of Point  \n<a name=\"Point.getG\"></a>\n##Point.getG()\nWill return a secp256k1 ECDSA base point.\n\n**Returns**: [Point](#Point) - An instance of the base point.  \n<a name=\"Point.getN\"></a>\n##Point.getN()\nWill return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.\n\n**Returns**: `BN` - A BN instance of the number of points on the curve  \n<a name=\"Point#getX\"></a>\n##point.getX()\nWill return the X coordinate of the Point\n\n**Returns**: `BN` - A BN instance of the X coordinate  \n<a name=\"Point#getY\"></a>\n##point.getY()\nWill return the Y coordinate of the Point\n\n**Returns**: `BN` - A BN instance of the Y coordinate  \n<a name=\"Point#validate\"></a>\n##point.validate(An)\nWill determine if the point is valid\n\n**Params**\n\n- An <code>[Point](#Point)</code> - instance of Point  \n\n**Type**: `Error`  \n**Returns**: [Point](#Point) - An instance of the same Point  \n","date":1419285022000,"updated":1419285022000,"path":"api/crypto/point.html","excerpt":"","_id":"mjizs8e53vf8fh70","title":"","comments":true,"layout":"page"},{"content":"","source":"api/crypto/random.md","raw":"","date":1419285019000,"updated":1419285019000,"path":"api/crypto/random.html","excerpt":"","_id":"jntwsgcgxik90pd1","title":"","comments":true,"layout":"page"},{"content":"","source":"api/crypto/signature.md","raw":"","date":1419285019000,"updated":1419285019000,"path":"api/crypto/signature.html","excerpt":"","_id":"3smrjdidck8gtk6j","title":"","comments":true,"layout":"page"},{"content":"","source":"api/encoding/base58.md","raw":"","date":1419285019000,"updated":1419285019000,"path":"api/encoding/base58.html","excerpt":"","_id":"9fxbb9pm2bvianll","title":"","comments":true,"layout":"page"},{"content":"","source":"api/encoding/base58check.md","raw":"","date":1419285020000,"updated":1419285020000,"path":"api/encoding/base58check.html","excerpt":"","_id":"usfymht0oyj09suo","title":"","comments":true,"layout":"page"},{"content":"","source":"api/encoding/bufferreader.md","raw":"","date":1419285020000,"updated":1419285020000,"path":"api/encoding/bufferreader.html","excerpt":"","_id":"l5qr0bbf6almvxcn","title":"","comments":true,"layout":"page"},{"content":"","source":"api/encoding/bufferwriter.md","raw":"","date":1419285020000,"updated":1419285020000,"path":"api/encoding/bufferwriter.html","excerpt":"","_id":"64xlv2zym7m32ql6","title":"","comments":true,"layout":"page"},{"content":"","source":"api/encoding/varint.md","raw":"","date":1419285020000,"updated":1419285020000,"path":"api/encoding/varint.html","excerpt":"","_id":"7vujsh9agjjdjii7","title":"","comments":true,"layout":"page"},{"content":"","source":"api/errors/build.md","raw":"","date":1419285019000,"updated":1419285019000,"path":"api/errors/build.html","excerpt":"","_id":"18fqq8ojo31boudf","title":"","comments":true,"layout":"page"},{"content":"","source":"api/errors/index.md","raw":"","date":1419285019000,"updated":1419285019000,"path":"api/errors/index.html","excerpt":"","_id":"0qa1rg769jwkw2ck","title":"","comments":true,"layout":"page"},{"content":"","source":"api/errors/spec.md","raw":"","date":1419285019000,"updated":1419285019000,"path":"api/errors/spec.html","excerpt":"","_id":"xb4ar67cxtwflyk0","title":"","comments":true,"layout":"page"},{"content":"","source":"api/paymentprotocol/browser.md","raw":"","date":1419285020000,"updated":1419285020000,"path":"api/paymentprotocol/browser.html","excerpt":"","_id":"kdp03epmg4mquct9","title":"","comments":true,"layout":"page"},{"content":"","source":"api/paymentprotocol/common.md","raw":"","date":1419285021000,"updated":1419285021000,"path":"api/paymentprotocol/common.html","excerpt":"","_id":"e7wrpg0h9y41rbgr","title":"","comments":true,"layout":"page"},{"content":"","source":"api/paymentprotocol/index.md","raw":"","date":1419285021000,"updated":1419285021000,"path":"api/paymentprotocol/index.html","excerpt":"","_id":"a4x991o6v9vqq2sq","title":"","comments":true,"layout":"page"},{"content":"","source":"api/paymentprotocol/node.md","raw":"","date":1419285021000,"updated":1419285021000,"path":"api/paymentprotocol/node.html","excerpt":"","_id":"ivddxcdgjykk1nk0","title":"","comments":true,"layout":"page"},{"content":"","source":"api/paymentprotocol/rootcerts.md","raw":"","date":1419285021000,"updated":1419285021000,"path":"api/paymentprotocol/rootcerts.html","excerpt":"","_id":"w3fgf0tbdbkfqng4","title":"","comments":true,"layout":"page"},{"content":"","source":"api/script/index.md","raw":"","date":1419285022000,"updated":1419285022000,"path":"api/script/index.html","excerpt":"","_id":"r3w3ug1hg04sy6d4","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"Interpreter\"></a></p>\n<h1 id=\"Interpreter()\">Interpreter()</h1>\n<p>Bitcoin transactions contain scripts. Each input has a script called the<br>scriptSig, and each output has a script called the scriptPubkey. To validate<br>an input, the input’s script is concatenated with the referenced output script,<br>and the result is executed. If at the end of execution the stack contains a<br>“true” value, then the transaction is valid.</p>\n<p>The primary way to use this class is via the verify function.<br>e.g., Interpreter().verify( … );</p>\n","source":"api/script/interpreter.md","raw":"<a name=\"Interpreter\"></a>\n#Interpreter()\nBitcoin transactions contain scripts. Each input has a script called the\nscriptSig, and each output has a script called the scriptPubkey. To validate\nan input, the input's script is concatenated with the referenced output script,\nand the result is executed. If at the end of execution the stack contains a\n\"true\" value, then the transaction is valid.\n\nThe primary way to use this class is via the verify function.\ne.g., Interpreter().verify( ... );\n\n","date":1419285026000,"updated":1419285026000,"path":"api/script/interpreter.html","excerpt":"","_id":"jqqi33cdneq3mdkg","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"Script\"></a></p>\n<h1 id=\"class:_Script\">class: Script</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#Script\">class: Script</a><ul>\n<li><a href=\"#new_Script\">new Script([from])</a></li>\n<li><a href=\"#Script#isPublicKeyHashOut\">script.isPublicKeyHashOut()</a></li>\n<li><a href=\"#Script#isPublicKeyHashIn\">script.isPublicKeyHashIn()</a></li>\n<li><a href=\"#Script#isPublicKeyOut\">script.isPublicKeyOut()</a></li>\n<li><a href=\"#Script#isPublicKeyIn\">script.isPublicKeyIn()</a></li>\n<li><a href=\"#Script#isScriptHashOut\">script.isScriptHashOut()</a></li>\n<li><a href=\"#Script#isScriptHashIn\">script.isScriptHashIn()</a></li>\n<li><a href=\"#Script#isMultisigOut\">script.isMultisigOut()</a></li>\n<li><a href=\"#Script#isMultisigIn\">script.isMultisigIn()</a></li>\n<li><a href=\"#Script#isDataOut\">script.isDataOut()</a></li>\n<li><a href=\"#Script#isPushOnly\">script.isPushOnly()</a></li>\n<li><a href=\"#Script#classify\">script.classify()</a></li>\n<li><a href=\"#Script#isStandard\">script.isStandard()</a></li>\n<li><a href=\"#Script#prepend\">script.prepend(obj)</a></li>\n<li><a href=\"#Script#equals\">script.equals()</a></li>\n<li><a href=\"#Script#add\">script.add(obj)</a></li>\n<li><a href=\"#Script.buildMultisigOut\">Script.buildMultisigOut(publicKeys, threshold, [opts])</a></li>\n<li><a href=\"#Script.buildP2SHMultisigIn\">Script.buildP2SHMultisigIn(pubkeys, threshold, signatures, [opts])</a></li>\n<li><a href=\"#Script.buildPublicKeyHashOut\">Script.buildPublicKeyHashOut(to)</a></li>\n<li><a href=\"#Script.buildPublicKeyOut\">Script.buildPublicKeyOut()</a></li>\n<li><a href=\"#Script.buildDataOut\">Script.buildDataOut(to)</a></li>\n<li><a href=\"#Script.buildScriptHashOut\">Script.buildScriptHashOut(script)</a></li>\n<li><a href=\"#Script.buildPublicKeyHashIn\">Script.buildPublicKeyHashIn(publicKey, signature, [sigtype])</a></li>\n<li><a href=\"#Script.empty\">Script.empty()</a></li>\n<li><a href=\"#Script#toScriptHashOut\">script.toScriptHashOut()</a></li>\n<li><a href=\"#Script.fromAddress\">Script.fromAddress()</a></li>\n<li><a href=\"#Script#findAndDelete\">script.findAndDelete()</a></li>\n<li><a href=\"#Script#checkMinimalPush\">script.checkMinimalPush()</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"new_Script\"></a></p>\n<h2 id=\"new_Script([from])\">new Script([from])</h2>\n<p>A bitcoin transaction script. Each transaction’s inputs and outputs<br>has a script that is evaluated to validate it’s spending.</p>\n<p>See <a href=\"https://en.bitcoin.it/wiki/Script\" target=\"_blank\" rel=\"external\">https://en.bitcoin.it/wiki/Script</a></p>\n<p><strong>Params</strong></p>\n<ul>\n<li>[from] <code>Object</code> | <code>string</code> | <code>Buffer</code> - optional data to populate script  </li>\n</ul>\n<p><a name=\"Script#isPublicKeyHashOut\"></a></p>\n<h2 id=\"script-isPublicKeyHashOut()\">script.isPublicKeyHashOut()</h2>\n<p><strong>Returns</strong>:  - true if this is a pay to pubkey hash output script<br><a name=\"Script#isPublicKeyHashIn\"></a></p>\n<h2 id=\"script-isPublicKeyHashIn()\">script.isPublicKeyHashIn()</h2>\n<p><strong>Returns</strong>:  - true if this is a pay to public key hash input script<br><a name=\"Script#isPublicKeyOut\"></a></p>\n<h2 id=\"script-isPublicKeyOut()\">script.isPublicKeyOut()</h2>\n<p><strong>Returns</strong>:  - true if this is a public key output script<br><a name=\"Script#isPublicKeyIn\"></a></p>\n<h2 id=\"script-isPublicKeyIn()\">script.isPublicKeyIn()</h2>\n<p><strong>Returns</strong>:  - true if this is a pay to public key input script<br><a name=\"Script#isScriptHashOut\"></a></p>\n<h2 id=\"script-isScriptHashOut()\">script.isScriptHashOut()</h2>\n<p><strong>Returns</strong>:  - true if this is a p2sh output script<br><a name=\"Script#isScriptHashIn\"></a></p>\n<h2 id=\"script-isScriptHashIn()\">script.isScriptHashIn()</h2>\n<p><strong>Returns</strong>:  - true if this is a p2sh input script<br>Note that these are frequently indistinguishable from pubkeyhashin<br><a name=\"Script#isMultisigOut\"></a></p>\n<h2 id=\"script-isMultisigOut()\">script.isMultisigOut()</h2>\n<p><strong>Returns</strong>:  - true if this is a mutlsig output script<br><a name=\"Script#isMultisigIn\"></a></p>\n<h2 id=\"script-isMultisigIn()\">script.isMultisigIn()</h2>\n<p><strong>Returns</strong>:  - true if this is a multisig input script<br><a name=\"Script#isDataOut\"></a></p>\n<h2 id=\"script-isDataOut()\">script.isDataOut()</h2>\n<p><strong>Returns</strong>:  - true if this is an OP_RETURN data script<br><a name=\"Script#isPushOnly\"></a></p>\n<h2 id=\"script-isPushOnly()\">script.isPushOnly()</h2>\n<p><strong>Returns</strong>:  - true if the script is only composed of data pushing<br>opcodes or small int opcodes (OP_0, OP_1, …, OP_16)<br><a name=\"Script#classify\"></a></p>\n<h2 id=\"script-classify()\">script.classify()</h2>\n<p><strong>Returns</strong>: <code>object</code> - The Script type if it is a known form,<br>or Script.UNKNOWN if it isn’t<br><a name=\"Script#isStandard\"></a></p>\n<h2 id=\"script-isStandard()\">script.isStandard()</h2>\n<p><strong>Returns</strong>:  - true if script is one of the known types<br><a name=\"Script#prepend\"></a></p>\n<h2 id=\"script-prepend(obj)\">script.prepend(obj)</h2>\n<p>Adds a script element at the start of the script.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>obj <code>*</code> - a string, number, Opcode, Bufer, or object to add  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Script\">Script</a> - this script instance<br><a name=\"Script#equals\"></a></p>\n<h2 id=\"script-equals()\">script.equals()</h2>\n<p>Compares a script with another script</p>\n<p><a name=\"Script#add\"></a></p>\n<h2 id=\"script-add(obj)\">script.add(obj)</h2>\n<p>Adds a script element to the end of the script.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>obj <code>*</code> - a string, number, Opcode, Bufer, or object to add  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Script\">Script</a> - this script instance<br><a name=\"Script.buildMultisigOut\"></a></p>\n<h2 id=\"Script-buildMultisigOut(publicKeys,_threshold,_[opts])\">Script.buildMultisigOut(publicKeys, threshold, [opts])</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>publicKeys <code>Array.&lt;PublicKey&gt;</code> - list of all public keys controlling the output  </li>\n<li>threshold <code>number</code> - amount of required signatures to spend the output  </li>\n<li>[opts] <code>Object</code> - Several options:<pre><code> - noSorting: defaults <span class=\"keyword\">to</span> <span class=\"constant\">false</span>, <span class=\"keyword\">if</span> <span class=\"constant\">true</span>, don't sort <span class=\"keyword\">the</span> <span class=\"keyword\">given</span>\n               public keys <span class=\"keyword\">before</span> creating <span class=\"keyword\">the</span> <span class=\"keyword\">script</span>  \n</code></pre></li>\n</ul>\n<p><strong>Returns</strong>:  - a new Multisig output script for given public keys,<br>requiring m of those public keys to spend<br><a name=\"Script.buildP2SHMultisigIn\"></a></p>\n<h2 id=\"Script-buildP2SHMultisigIn(pubkeys,_threshold,_signatures,_[opts])\">Script.buildP2SHMultisigIn(pubkeys, threshold, signatures, [opts])</h2>\n<p>A new P2SH Multisig input script for the given public keys, requiring m of those public keys to spend</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>pubkeys <code>Array.&lt;PublicKey&gt;</code> - list of all public keys controlling the output  </li>\n<li>threshold <code>number</code> - amount of required signatures to spend the output  </li>\n<li>signatures <code>Array</code> - signatures to append to the script  </li>\n<li>[opts] <code>Object</code>  <ul>\n<li>[noSorting] <code>boolean</code> - don’t sort the given public keys before creating the script (false by default)  </li>\n<li>[cachedMultisig] <code><a href=\"#Script\">Script</a></code> - don’t recalculate the redeemScript  </li>\n</ul>\n</li>\n</ul>\n<p><strong>Returns</strong>:  - Script<br><a name=\"Script.buildPublicKeyHashOut\"></a></p>\n<h2 id=\"Script-buildPublicKeyHashOut(to)\">Script.buildPublicKeyHashOut(to)</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>to <code>Address</code> | <code>PublicKey</code> - destination address or public key  </li>\n</ul>\n<p><strong>Returns</strong>:  - a new pay to public key hash output for the given<br>address or public key<br><a name=\"Script.buildPublicKeyOut\"></a></p>\n<h2 id=\"Script-buildPublicKeyOut()\">Script.buildPublicKeyOut()</h2>\n<p><strong>Returns</strong>:  - a new pay to public key output for the given<br> public key<br><a name=\"Script.buildDataOut\"></a></p>\n<h2 id=\"Script-buildDataOut(to)\">Script.buildDataOut(to)</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>to <code>string</code> | <code>Buffer</code> - the data to embed in the output  </li>\n</ul>\n<p><strong>Returns</strong>:  - a new OP_RETURN script with data<br><a name=\"Script.buildScriptHashOut\"></a></p>\n<h2 id=\"Script-buildScriptHashOut(script)\">Script.buildScriptHashOut(script)</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>script <code><a href=\"#Script\">Script</a></code> | <code>Address</code> - the redeemScript for the new p2sh output.<br> It can also be a p2sh address  </li>\n</ul>\n<p><strong>Returns</strong>:  - Script new pay to script hash script for given script<br><a name=\"Script.buildPublicKeyHashIn\"></a></p>\n<h2 id=\"Script-buildPublicKeyHashIn(publicKey,_signature,_[sigtype])\">Script.buildPublicKeyHashIn(publicKey, signature, [sigtype])</h2>\n<p>Builds a scriptSig (a script for an input) that signs a public key hash<br>output script.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>publicKey <code>Buffer</code> | <code>string</code> | <code>PublicKey</code>  </li>\n<li>signature <code>Signature</code> | <code>Buffer</code> - a Signature object, or the signature in DER cannonical encoding  </li>\n<li>[sigtype] <code>number</code> - the type of the signature (defaults to SIGHASH_ALL)  </li>\n</ul>\n<p><a name=\"Script.empty\"></a></p>\n<h2 id=\"Script-empty()\">Script.empty()</h2>\n<p><strong>Returns</strong>:  - Script an empty script<br><a name=\"Script#toScriptHashOut\"></a></p>\n<h2 id=\"script-toScriptHashOut()\">script.toScriptHashOut()</h2>\n<p><strong>Returns</strong>:  - Script a new pay to script hash script that pays to this script<br><a name=\"Script.fromAddress\"></a></p>\n<h2 id=\"Script-fromAddress()\">Script.fromAddress()</h2>\n<p><strong>Returns</strong>:  - Script a script built from the address<br><a name=\"Script#findAndDelete\"></a></p>\n<h2 id=\"script-findAndDelete()\">script.findAndDelete()</h2>\n<p>Analagous to bitcoind’s FindAndDelete. Find and delete equivalent chunks,<br>typically used with push data chunks.  Note that this will find and delete<br>not just the same data, but the same data with the same push data op as<br>produced by default. i.e., if a pushdata in a tx does not use the minimal<br>pushdata op, then when you try to remove the data it is pushing, it will not<br>be removed, because they do not use the same pushdata op.</p>\n<p><a name=\"Script#checkMinimalPush\"></a></p>\n<h2 id=\"script-checkMinimalPush()\">script.checkMinimalPush()</h2>\n<p><strong>Returns</strong>: <code>i</code> - true if the chunk  is the smallest way to push that particular data.<br>Comes from bitcoind’s script interpreter CheckMinimalPush function  </p>\n","source":"api/script/script.md","raw":"<a name=\"Script\"></a>\n#class: Script\n**Members**\n\n* [class: Script](#Script)\n  * [new Script([from])](#new_Script)\n  * [script.isPublicKeyHashOut()](#Script#isPublicKeyHashOut)\n  * [script.isPublicKeyHashIn()](#Script#isPublicKeyHashIn)\n  * [script.isPublicKeyOut()](#Script#isPublicKeyOut)\n  * [script.isPublicKeyIn()](#Script#isPublicKeyIn)\n  * [script.isScriptHashOut()](#Script#isScriptHashOut)\n  * [script.isScriptHashIn()](#Script#isScriptHashIn)\n  * [script.isMultisigOut()](#Script#isMultisigOut)\n  * [script.isMultisigIn()](#Script#isMultisigIn)\n  * [script.isDataOut()](#Script#isDataOut)\n  * [script.isPushOnly()](#Script#isPushOnly)\n  * [script.classify()](#Script#classify)\n  * [script.isStandard()](#Script#isStandard)\n  * [script.prepend(obj)](#Script#prepend)\n  * [script.equals()](#Script#equals)\n  * [script.add(obj)](#Script#add)\n  * [Script.buildMultisigOut(publicKeys, threshold, [opts])](#Script.buildMultisigOut)\n  * [Script.buildP2SHMultisigIn(pubkeys, threshold, signatures, [opts])](#Script.buildP2SHMultisigIn)\n  * [Script.buildPublicKeyHashOut(to)](#Script.buildPublicKeyHashOut)\n  * [Script.buildPublicKeyOut()](#Script.buildPublicKeyOut)\n  * [Script.buildDataOut(to)](#Script.buildDataOut)\n  * [Script.buildScriptHashOut(script)](#Script.buildScriptHashOut)\n  * [Script.buildPublicKeyHashIn(publicKey, signature, [sigtype])](#Script.buildPublicKeyHashIn)\n  * [Script.empty()](#Script.empty)\n  * [script.toScriptHashOut()](#Script#toScriptHashOut)\n  * [Script.fromAddress()](#Script.fromAddress)\n  * [script.findAndDelete()](#Script#findAndDelete)\n  * [script.checkMinimalPush()](#Script#checkMinimalPush)\n\n<a name=\"new_Script\"></a>\n##new Script([from])\nA bitcoin transaction script. Each transaction's inputs and outputs\nhas a script that is evaluated to validate it's spending.\n\nSee https://en.bitcoin.it/wiki/Script\n\n**Params**\n\n- \\[from\\] `Object` | `string` | `Buffer` - optional data to populate script  \n\n<a name=\"Script#isPublicKeyHashOut\"></a>\n##script.isPublicKeyHashOut()\n**Returns**:  - true if this is a pay to pubkey hash output script  \n<a name=\"Script#isPublicKeyHashIn\"></a>\n##script.isPublicKeyHashIn()\n**Returns**:  - true if this is a pay to public key hash input script  \n<a name=\"Script#isPublicKeyOut\"></a>\n##script.isPublicKeyOut()\n**Returns**:  - true if this is a public key output script  \n<a name=\"Script#isPublicKeyIn\"></a>\n##script.isPublicKeyIn()\n**Returns**:  - true if this is a pay to public key input script  \n<a name=\"Script#isScriptHashOut\"></a>\n##script.isScriptHashOut()\n**Returns**:  - true if this is a p2sh output script  \n<a name=\"Script#isScriptHashIn\"></a>\n##script.isScriptHashIn()\n**Returns**:  - true if this is a p2sh input script\nNote that these are frequently indistinguishable from pubkeyhashin  \n<a name=\"Script#isMultisigOut\"></a>\n##script.isMultisigOut()\n**Returns**:  - true if this is a mutlsig output script  \n<a name=\"Script#isMultisigIn\"></a>\n##script.isMultisigIn()\n**Returns**:  - true if this is a multisig input script  \n<a name=\"Script#isDataOut\"></a>\n##script.isDataOut()\n**Returns**:  - true if this is an OP_RETURN data script  \n<a name=\"Script#isPushOnly\"></a>\n##script.isPushOnly()\n**Returns**:  - true if the script is only composed of data pushing\nopcodes or small int opcodes (OP_0, OP_1, ..., OP_16)  \n<a name=\"Script#classify\"></a>\n##script.classify()\n**Returns**: `object` - The Script type if it is a known form,\nor Script.UNKNOWN if it isn't  \n<a name=\"Script#isStandard\"></a>\n##script.isStandard()\n**Returns**:  - true if script is one of the known types  \n<a name=\"Script#prepend\"></a>\n##script.prepend(obj)\nAdds a script element at the start of the script.\n\n**Params**\n\n- obj `*` - a string, number, Opcode, Bufer, or object to add  \n\n**Returns**: [Script](#Script) - this script instance  \n<a name=\"Script#equals\"></a>\n##script.equals()\nCompares a script with another script\n\n<a name=\"Script#add\"></a>\n##script.add(obj)\nAdds a script element to the end of the script.\n\n**Params**\n\n- obj `*` - a string, number, Opcode, Bufer, or object to add  \n\n**Returns**: [Script](#Script) - this script instance  \n<a name=\"Script.buildMultisigOut\"></a>\n##Script.buildMultisigOut(publicKeys, threshold, [opts])\n**Params**\n\n- publicKeys `Array.<PublicKey>` - list of all public keys controlling the output  \n- threshold `number` - amount of required signatures to spend the output  \n- \\[opts\\] `Object` - Several options:\n       - noSorting: defaults to false, if true, don't sort the given\n                     public keys before creating the script  \n\n**Returns**:  - a new Multisig output script for given public keys,\nrequiring m of those public keys to spend  \n<a name=\"Script.buildP2SHMultisigIn\"></a>\n##Script.buildP2SHMultisigIn(pubkeys, threshold, signatures, [opts])\nA new P2SH Multisig input script for the given public keys, requiring m of those public keys to spend\n\n**Params**\n\n- pubkeys `Array.<PublicKey>` - list of all public keys controlling the output  \n- threshold `number` - amount of required signatures to spend the output  \n- signatures `Array` - signatures to append to the script  \n- \\[opts\\] `Object`  \n  - \\[noSorting\\] `boolean` - don't sort the given public keys before creating the script (false by default)  \n  - \\[cachedMultisig\\] <code>[Script](#Script)</code> - don't recalculate the redeemScript  \n\n**Returns**:  - Script  \n<a name=\"Script.buildPublicKeyHashOut\"></a>\n##Script.buildPublicKeyHashOut(to)\n**Params**\n\n- to `Address` | `PublicKey` - destination address or public key  \n\n**Returns**:  - a new pay to public key hash output for the given\naddress or public key  \n<a name=\"Script.buildPublicKeyOut\"></a>\n##Script.buildPublicKeyOut()\n**Returns**:  - a new pay to public key output for the given\n public key  \n<a name=\"Script.buildDataOut\"></a>\n##Script.buildDataOut(to)\n**Params**\n\n- to `string` | `Buffer` - the data to embed in the output  \n\n**Returns**:  - a new OP_RETURN script with data  \n<a name=\"Script.buildScriptHashOut\"></a>\n##Script.buildScriptHashOut(script)\n**Params**\n\n- script <code>[Script](#Script)</code> | `Address` - the redeemScript for the new p2sh output.\n   It can also be a p2sh address  \n\n**Returns**:  - Script new pay to script hash script for given script  \n<a name=\"Script.buildPublicKeyHashIn\"></a>\n##Script.buildPublicKeyHashIn(publicKey, signature, [sigtype])\nBuilds a scriptSig (a script for an input) that signs a public key hash\noutput script.\n\n**Params**\n\n- publicKey `Buffer` | `string` | `PublicKey`  \n- signature `Signature` | `Buffer` - a Signature object, or the signature in DER cannonical encoding  \n- \\[sigtype\\] `number` - the type of the signature (defaults to SIGHASH_ALL)  \n\n<a name=\"Script.empty\"></a>\n##Script.empty()\n**Returns**:  - Script an empty script  \n<a name=\"Script#toScriptHashOut\"></a>\n##script.toScriptHashOut()\n**Returns**:  - Script a new pay to script hash script that pays to this script  \n<a name=\"Script.fromAddress\"></a>\n##Script.fromAddress()\n**Returns**:  - Script a script built from the address  \n<a name=\"Script#findAndDelete\"></a>\n##script.findAndDelete()\nAnalagous to bitcoind's FindAndDelete. Find and delete equivalent chunks,\ntypically used with push data chunks.  Note that this will find and delete\nnot just the same data, but the same data with the same push data op as\nproduced by default. i.e., if a pushdata in a tx does not use the minimal\npushdata op, then when you try to remove the data it is pushing, it will not\nbe removed, because they do not use the same pushdata op.\n\n<a name=\"Script#checkMinimalPush\"></a>\n##script.checkMinimalPush()\n**Returns**: `i` - true if the chunk  is the smallest way to push that particular data.\nComes from bitcoind's script interpreter CheckMinimalPush function  \n","date":1419285026000,"updated":1419285026000,"path":"api/script/script.html","excerpt":"","_id":"jp8d69f52bvr5bfv","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"Transport\"></a></p>\n<h1 id=\"Transport\">Transport</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#Transport\">Transport</a></li>\n</ul>\n","source":"api/transport/index.md","raw":"<a name=\"Transport\"></a>\n#Transport\n**Members**\n\n* [Transport](#Transport)\n\n","date":1419285026000,"updated":1419285026000,"path":"api/transport/index.html","excerpt":"","_id":"enyum8ac96al7c7t","title":"","comments":true,"layout":"page"},{"content":"","source":"api/transport/messages.md","raw":"","date":1419285022000,"updated":1419285022000,"path":"api/transport/messages.html","excerpt":"","_id":"gebwqndngjj4u2u0","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"Peer\"></a></p>\n<h1 id=\"class:_Peer\">class: Peer</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#Peer\">class: Peer</a><ul>\n<li><a href=\"#new_Peer\">new Peer(host, [port], [network])</a></li>\n<li><a href=\"#Peer#setProxy\">peer.setProxy(host, port)</a></li>\n<li><a href=\"#Peer#connect\">peer.connect()</a></li>\n<li><a href=\"#Peer#disconnect\">peer.disconnect()</a></li>\n<li><a href=\"#Peer#sendMessage\">peer.sendMessage(message)</a></li>\n<li><a href=\"#Peer#_sendVersion\">peer._sendVersion()</a></li>\n<li><a href=\"#Peer#_sendPong\">peer._sendPong()</a></li>\n<li><a href=\"#Peer#_readMessage\">peer._readMessage()</a></li>\n<li><a href=\"#Peer#_getSocket\">peer._getSocket()</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"new_Peer\"></a></p>\n<h2 id=\"new_Peer(host,_[port],_[network])\">new Peer(host, [port], [network])</h2>\n<p>A Peer instance represents a remote bitcoin node and allows to communicate<br>with it using the standar messages of the bitcoin p2p protocol.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>host <code>String</code> - IP address of the remote host  </li>\n<li>[port] <code>Number</code> - Port number of the remote host  </li>\n<li>[network] <code>Network</code> - The context for this communication  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Peer\">Peer</a> - A new instance of Peer.<br><strong>Example</strong>  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> peer = <span class=\"keyword\">new</span> Peer(<span class=\"string\">'127.0.0.1'</span>).setProxy(<span class=\"string\">'127.0.0.1'</span>, <span class=\"number\">9050</span>);</div><div class=\"line\">peer.on(<span class=\"string\">'tx'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(tx)</span> </span>{</div><div class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'New transaction: '</span>, tx.id);</div><div class=\"line\">});</div><div class=\"line\">peer.connect();</div></pre></td></tr></table></figure>\n\n<p><a name=\"Peer#setProxy\"></a></p>\n<h2 id=\"peer-setProxy(host,_port)\">peer.setProxy(host, port)</h2>\n<p>Set a socks5 proxy for the connection. Enables the use of the TOR network.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>host <code>String</code> - IP address of the proxy  </li>\n<li>port <code>Number</code> - Port number of the proxy  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Peer\">Peer</a> - The same Peer instance.<br><a name=\"Peer#connect\"></a></p>\n<h2 id=\"peer-connect()\">peer.connect()</h2>\n<p>Init the connection with the remote peer.</p>\n<p><strong>Returns</strong>: <code>Socket</code> - The same peer instance.<br><a name=\"Peer#disconnect\"></a></p>\n<h2 id=\"peer-disconnect()\">peer.disconnect()</h2>\n<p>Disconnects the remote connection.</p>\n<p><strong>Returns</strong>: <code>Socket</code> - The same peer instance.<br><a name=\"Peer#sendMessage\"></a></p>\n<h2 id=\"peer-sendMessage(message)\">peer.sendMessage(message)</h2>\n<p>Send a Message to the remote peer.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>message <code>Message</code> - A message instance  </li>\n</ul>\n<p><a name=\"Peer#_sendVersion\"></a></p>\n<h2 id=\"peer-_sendVersion()\">peer._sendVersion()</h2>\n<p>Internal function that sends VERSION message to the remote peer.</p>\n<p><a name=\"Peer#_sendPong\"></a></p>\n<h2 id=\"peer-_sendPong()\">peer._sendPong()</h2>\n<p>Send a PONG message to the remote peer.</p>\n<p><a name=\"Peer#_readMessage\"></a></p>\n<h2 id=\"peer-_readMessage()\">peer._readMessage()</h2>\n<p>Internal function that tries to read a message from the data buffer</p>\n<p><a name=\"Peer#_getSocket\"></a></p>\n<h2 id=\"peer-_getSocket()\">peer._getSocket()</h2>\n<p>Internal function that creates a socket using a proxy if neccesary.</p>\n<p><strong>Returns</strong>: <code>Socket</code> - A Socket instance not yet connected.  </p>\n","source":"api/transport/peer.md","raw":"<a name=\"Peer\"></a>\n#class: Peer\n**Members**\n\n* [class: Peer](#Peer)\n  * [new Peer(host, [port], [network])](#new_Peer)\n  * [peer.setProxy(host, port)](#Peer#setProxy)\n  * [peer.connect()](#Peer#connect)\n  * [peer.disconnect()](#Peer#disconnect)\n  * [peer.sendMessage(message)](#Peer#sendMessage)\n  * [peer._sendVersion()](#Peer#_sendVersion)\n  * [peer._sendPong()](#Peer#_sendPong)\n  * [peer._readMessage()](#Peer#_readMessage)\n  * [peer._getSocket()](#Peer#_getSocket)\n\n<a name=\"new_Peer\"></a>\n##new Peer(host, [port], [network])\nA Peer instance represents a remote bitcoin node and allows to communicate\nwith it using the standar messages of the bitcoin p2p protocol.\n\n**Params**\n\n- host `String` - IP address of the remote host  \n- \\[port\\] `Number` - Port number of the remote host  \n- \\[network\\] `Network` - The context for this communication  \n\n**Returns**: [Peer](#Peer) - A new instance of Peer.  \n**Example**  \n```javascript\n\nvar peer = new Peer('127.0.0.1').setProxy('127.0.0.1', 9050);\npeer.on('tx', function(tx) {\n console.log('New transaction: ', tx.id);\n});\npeer.connect();\n```\n\n<a name=\"Peer#setProxy\"></a>\n##peer.setProxy(host, port)\nSet a socks5 proxy for the connection. Enables the use of the TOR network.\n\n**Params**\n\n- host `String` - IP address of the proxy  \n- port `Number` - Port number of the proxy  \n\n**Returns**: [Peer](#Peer) - The same Peer instance.  \n<a name=\"Peer#connect\"></a>\n##peer.connect()\nInit the connection with the remote peer.\n\n**Returns**: `Socket` - The same peer instance.  \n<a name=\"Peer#disconnect\"></a>\n##peer.disconnect()\nDisconnects the remote connection.\n\n**Returns**: `Socket` - The same peer instance.  \n<a name=\"Peer#sendMessage\"></a>\n##peer.sendMessage(message)\nSend a Message to the remote peer.\n\n**Params**\n\n- message `Message` - A message instance  \n\n<a name=\"Peer#_sendVersion\"></a>\n##peer._sendVersion()\nInternal function that sends VERSION message to the remote peer.\n\n<a name=\"Peer#_sendPong\"></a>\n##peer._sendPong()\nSend a PONG message to the remote peer.\n\n<a name=\"Peer#_readMessage\"></a>\n##peer._readMessage()\nInternal function that tries to read a message from the data buffer\n\n<a name=\"Peer#_getSocket\"></a>\n##peer._getSocket()\nInternal function that creates a socket using a proxy if neccesary.\n\n**Returns**: `Socket` - A Socket instance not yet connected.  \n","date":1419285026000,"updated":1419285026000,"path":"api/transport/peer.html","excerpt":"","_id":"lfrnbxlgmrq7ag5w","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"Pool\"></a></p>\n<h1 id=\"class:_Pool\">class: Pool</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#Pool\">class: Pool</a><ul>\n<li><a href=\"#new_Pool\">new Pool(network)</a></li>\n<li><a href=\"#Pool#connect\">pool.connect()</a></li>\n<li><a href=\"#Pool#disconnect\">pool.disconnect()</a></li>\n<li><a href=\"#Pool#numberConnected\">pool.numberConnected()</a></li>\n<li><a href=\"#Pool#_fillConnections\">pool._fillConnections()</a></li>\n<li><a href=\"#Pool#_removeConnectedPeer\">pool._removeConnectedPeer(addr)</a></li>\n<li><a href=\"#Pool#_connectPeer\">pool._connectPeer(addr)</a></li>\n<li><a href=\"#Pool#_deprioritizeAddr\">pool._deprioritizeAddr(addr)</a></li>\n<li><a href=\"#Pool#_addAddr\">pool._addAddr(addr)</a></li>\n<li><a href=\"#Pool#_addAddrsFromSeed\">pool._addAddrsFromSeed(seed, done)</a></li>\n<li><a href=\"#Pool#_addAddrsFromSeeds\">pool._addAddrsFromSeeds(done)</a></li>\n<li><a href=\"#Pool#inspect\">pool.inspect()</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"new_Pool\"></a></p>\n<h2 id=\"new_Pool(network)\">new Pool(network)</h2>\n<p>A pool is a collection of Peers. A pool will discover peers from DNS seeds, and<br>collect information about new peers in the network. When a peer disconnects the pool<br>will connect to others that are available to maintain a max number of<br>ongoing peer connections. Peer events are relayed to the pool.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>network <code>Network</code> | <code>String</code> - The network to connect  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Pool\">Pool</a><br><strong>Example</strong>  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> pool = <span class=\"keyword\">new</span> Pool(Networks.livenet);</div><div class=\"line\">pool.on(<span class=\"string\">'peerinv'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(peer, message)</span> </span>{</div><div class=\"line\">  <span class=\"comment\">// do something with the inventory announcement</span></div><div class=\"line\">});</div><div class=\"line\">pool.connect();</div></pre></td></tr></table></figure>\n\n<p><a name=\"Pool#connect\"></a></p>\n<h2 id=\"pool-connect()\">pool.connect()</h2>\n<p>Will initiatiate connection to peers, if available peers have been added to<br>the pool, it will connect to those, otherwise will use DNS seeds to find<br>peers to connect. When a peer disconnects it will add another.</p>\n<p><a name=\"Pool#disconnect\"></a></p>\n<h2 id=\"pool-disconnect()\">pool.disconnect()</h2>\n<p>Will disconnect all peers that are connected.</p>\n<p><a name=\"Pool#numberConnected\"></a></p>\n<h2 id=\"pool-numberConnected()\">pool.numberConnected()</h2>\n<p><strong>Returns</strong>: <code>Number</code> - The number of peers currently connected.<br><a name=\"Pool#_fillConnections\"></a></p>\n<h2 id=\"pool-_fillConnections()\">pool._fillConnections()</h2>\n<p>Will fill the conneted peers to the maximum amount.</p>\n<p><a name=\"Pool#_removeConnectedPeer\"></a></p>\n<h2 id=\"pool-_removeConnectedPeer(addr)\">pool._removeConnectedPeer(addr)</h2>\n<p>Will remove a peer from the list of connected peers.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>addr <code>Object</code> - An addr from the list of addrs  </li>\n</ul>\n<p><a name=\"Pool#_connectPeer\"></a></p>\n<h2 id=\"pool-_connectPeer(addr)\">pool._connectPeer(addr)</h2>\n<p>Will connect a peer and add to the list of connected peers.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>addr <code>Object</code> - An addr from the list of addrs  </li>\n</ul>\n<p><a name=\"Pool#_deprioritizeAddr\"></a></p>\n<h2 id=\"pool-_deprioritizeAddr(addr)\">pool._deprioritizeAddr(addr)</h2>\n<p>Will deprioritize an addr in the list of addrs by moving it to the end<br>of the array, and setting a retryTime</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>addr <code>Object</code> - An addr from the list of addrs  </li>\n</ul>\n<p><a name=\"Pool#_addAddr\"></a></p>\n<h2 id=\"pool-_addAddr(addr)\">pool._addAddr(addr)</h2>\n<p>Will add an addr to the beginning of the addrs array</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>addr <code>Object</code>  </li>\n</ul>\n<p><a name=\"Pool#_addAddrsFromSeed\"></a></p>\n<h2 id=\"pool-_addAddrsFromSeed(seed,_done)\">pool._addAddrsFromSeed(seed, done)</h2>\n<p>Will add addrs to the list of addrs from a DNS seed</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>seed <code>String</code> - A domain name to resolve known peers  </li>\n<li>done <code>function</code>  </li>\n</ul>\n<p><a name=\"Pool#_addAddrsFromSeeds\"></a></p>\n<h2 id=\"pool-_addAddrsFromSeeds(done)\">pool._addAddrsFromSeeds(done)</h2>\n<p>Will add addrs to the list of addrs from network DNS seeds</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>done <code>function</code>  </li>\n</ul>\n<p><a name=\"Pool#inspect\"></a></p>\n<h2 id=\"pool-inspect()\">pool.inspect()</h2>\n<p><strong>Returns</strong>: <code>String</code> - A string formatted for the console  </p>\n","source":"api/transport/pool.md","raw":"<a name=\"Pool\"></a>\n#class: Pool\n**Members**\n\n* [class: Pool](#Pool)\n  * [new Pool(network)](#new_Pool)\n  * [pool.connect()](#Pool#connect)\n  * [pool.disconnect()](#Pool#disconnect)\n  * [pool.numberConnected()](#Pool#numberConnected)\n  * [pool._fillConnections()](#Pool#_fillConnections)\n  * [pool._removeConnectedPeer(addr)](#Pool#_removeConnectedPeer)\n  * [pool._connectPeer(addr)](#Pool#_connectPeer)\n  * [pool._deprioritizeAddr(addr)](#Pool#_deprioritizeAddr)\n  * [pool._addAddr(addr)](#Pool#_addAddr)\n  * [pool._addAddrsFromSeed(seed, done)](#Pool#_addAddrsFromSeed)\n  * [pool._addAddrsFromSeeds(done)](#Pool#_addAddrsFromSeeds)\n  * [pool.inspect()](#Pool#inspect)\n\n<a name=\"new_Pool\"></a>\n##new Pool(network)\nA pool is a collection of Peers. A pool will discover peers from DNS seeds, and\ncollect information about new peers in the network. When a peer disconnects the pool\nwill connect to others that are available to maintain a max number of\nongoing peer connections. Peer events are relayed to the pool.\n\n**Params**\n\n- network `Network` | `String` - The network to connect  \n\n**Returns**: [Pool](#Pool)  \n**Example**  \n```javascript\n\nvar pool = new Pool(Networks.livenet);\npool.on('peerinv', function(peer, message) {\n  // do something with the inventory announcement\n});\npool.connect();\n```\n\n<a name=\"Pool#connect\"></a>\n##pool.connect()\nWill initiatiate connection to peers, if available peers have been added to\nthe pool, it will connect to those, otherwise will use DNS seeds to find\npeers to connect. When a peer disconnects it will add another.\n\n<a name=\"Pool#disconnect\"></a>\n##pool.disconnect()\nWill disconnect all peers that are connected.\n\n<a name=\"Pool#numberConnected\"></a>\n##pool.numberConnected()\n**Returns**: `Number` - The number of peers currently connected.  \n<a name=\"Pool#_fillConnections\"></a>\n##pool._fillConnections()\nWill fill the conneted peers to the maximum amount.\n\n<a name=\"Pool#_removeConnectedPeer\"></a>\n##pool._removeConnectedPeer(addr)\nWill remove a peer from the list of connected peers.\n\n**Params**\n\n- addr `Object` - An addr from the list of addrs  \n\n<a name=\"Pool#_connectPeer\"></a>\n##pool._connectPeer(addr)\nWill connect a peer and add to the list of connected peers.\n\n**Params**\n\n- addr `Object` - An addr from the list of addrs  \n\n<a name=\"Pool#_deprioritizeAddr\"></a>\n##pool._deprioritizeAddr(addr)\nWill deprioritize an addr in the list of addrs by moving it to the end\nof the array, and setting a retryTime\n\n**Params**\n\n- addr `Object` - An addr from the list of addrs  \n\n<a name=\"Pool#_addAddr\"></a>\n##pool._addAddr(addr)\nWill add an addr to the beginning of the addrs array\n\n**Params**\n\n- addr `Object`  \n\n<a name=\"Pool#_addAddrsFromSeed\"></a>\n##pool._addAddrsFromSeed(seed, done)\nWill add addrs to the list of addrs from a DNS seed\n\n**Params**\n\n- seed `String` - A domain name to resolve known peers  \n- done `function`  \n\n<a name=\"Pool#_addAddrsFromSeeds\"></a>\n##pool._addAddrsFromSeeds(done)\nWill add addrs to the list of addrs from network DNS seeds\n\n**Params**\n\n- done `function`  \n\n<a name=\"Pool#inspect\"></a>\n##pool.inspect()\n**Returns**: `String` - A string formatted for the console  \n","date":1419285026000,"updated":1419285026000,"path":"api/transport/pool.html","excerpt":"","_id":"3ymkum3je49w6j5l","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"RPC\"></a></p>\n<h1 id=\"class:_RPC\">class: RPC</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#RPC\">class: RPC</a><ul>\n<li><a href=\"#new_RPC\">new RPC(user, password, opts)</a></li>\n<li><a href=\"#RPC#batch\">rPC.batch(batchCallback, resultCallbak)</a></li>\n<li><a href=\"#RPC#_request\">rPC._request(request, callbak)</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"new_RPC\"></a></p>\n<h2 id=\"new_RPC(user,_password,_opts)\">new RPC(user, password, opts)</h2>\n<p>A JSON RPC client for bitcoind. An instances of RPC connects to a bitcoind<br>server and enables simple and batch RPC calls.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>user <code>String</code> - username used to connect bitcoind  </li>\n<li>password <code>String</code> - password used to connect bitcoind  </li>\n<li>opts <code>Object</code> - Connection options: host, port, secure, disableAgent, rejectUnauthorized  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#RPC\">RPC</a><br><strong>Example</strong>  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> client = <span class=\"keyword\">new</span> RPC(<span class=\"string\">'user'</span>, <span class=\"string\">'pass'</span>);</div><div class=\"line\">client.getInfo(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(err, info)</span> </span>{</div><div class=\"line\">  <span class=\"comment\">// do something with the info</span></div><div class=\"line\">});</div></pre></td></tr></table></figure>\n\n<p><a name=\"RPC#batch\"></a></p>\n<h2 id=\"rPC-batch(batchCallback,_resultCallbak)\">rPC.batch(batchCallback, resultCallbak)</h2>\n<p>Allows to excecute RPC calls in batch.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>batchCallback <code>function</code> - Function that makes all calls to be excecuted in bach  </li>\n<li>resultCallbak <code>function</code> - Function to be called on result  </li>\n</ul>\n<p><a name=\"RPC#_request\"></a></p>\n<h2 id=\"rPC-_request(request,_callbak)\">rPC._request(request, callbak)</h2>\n<p>Internal function to make an RPC call</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>request <code>Object</code> - Object to be serialized and sent to bitcoind  </li>\n<li>callbak <code>function</code> - Function to be called on result  </li>\n</ul>\n","source":"api/transport/rpc.md","raw":"<a name=\"RPC\"></a>\n#class: RPC\n**Members**\n\n* [class: RPC](#RPC)\n  * [new RPC(user, password, opts)](#new_RPC)\n  * [rPC.batch(batchCallback, resultCallbak)](#RPC#batch)\n  * [rPC._request(request, callbak)](#RPC#_request)\n\n<a name=\"new_RPC\"></a>\n##new RPC(user, password, opts)\nA JSON RPC client for bitcoind. An instances of RPC connects to a bitcoind\nserver and enables simple and batch RPC calls.\n\n**Params**\n\n- user `String` - username used to connect bitcoind  \n- password `String` - password used to connect bitcoind  \n- opts `Object` - Connection options: host, port, secure, disableAgent, rejectUnauthorized  \n\n**Returns**: [RPC](#RPC)  \n**Example**  \n```javascript\n\nvar client = new RPC('user', 'pass');\nclient.getInfo(function(err, info) {\n  // do something with the info\n});\n```\n\n<a name=\"RPC#batch\"></a>\n##rPC.batch(batchCallback, resultCallbak)\nAllows to excecute RPC calls in batch.\n\n**Params**\n\n- batchCallback `function` - Function that makes all calls to be excecuted in bach  \n- resultCallbak `function` - Function to be called on result  \n\n<a name=\"RPC#_request\"></a>\n##rPC._request(request, callbak)\nInternal function to make an RPC call\n\n**Params**\n\n- request `Object` - Object to be serialized and sent to bitcoind  \n- callbak `function` - Function to be called on result  \n\n","date":1419285026000,"updated":1419285026000,"path":"api/transport/rpc.html","excerpt":"","_id":"1fqzt56854eg4ozk","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"JSUtil\"></a></p>\n<h1 id=\"JSUtil\">JSUtil</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#JSUtil\">JSUtil</a><ul>\n<li><a href=\"#JSUtil.isHexa\">JSUtil.isHexa</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"JSUtil.isHexa\"></a></p>\n<h2 id=\"JSUtil-isHexa\">JSUtil.isHexa</h2>\n<p>Determines whether a string contains only hexadecimal values</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>value <code>string</code>  </li>\n</ul>\n<p><strong>Returns</strong>: <code>boolean</code> - true if the string is the hexa representation of a number  </p>\n","source":"api/util/js.md","raw":"<a name=\"JSUtil\"></a>\n#JSUtil\n**Members**\n\n* [JSUtil](#JSUtil)\n  * [JSUtil.isHexa](#JSUtil.isHexa)\n\n<a name=\"JSUtil.isHexa\"></a>\n##JSUtil.isHexa\nDetermines whether a string contains only hexadecimal values\n\n**Params**\n\n- value `string`  \n\n**Returns**: `boolean` - true if the string is the hexa representation of a number  \n","date":1419285026000,"updated":1419285026000,"path":"api/util/js.html","excerpt":"","_id":"sacaq4jygf9ez5sk","title":"","comments":true,"layout":"page"},{"content":"","source":"api/util/preconditions.md","raw":"","date":1419285023000,"updated":1419285023000,"path":"api/util/preconditions.html","excerpt":"","_id":"wjv6bh74solqq8tf","title":"","comments":true,"layout":"page"},{"content":"","source":"api/util/buffer.md","raw":"","date":1419285023000,"updated":1419285023000,"path":"api/util/buffer.html","excerpt":"","_id":"y043k78agw33ars9","title":"","comments":true,"layout":"page"},{"content":"","source":"api/transaction/index.md","raw":"","date":1419285022000,"updated":1419285022000,"path":"api/transaction/index.html","excerpt":"","_id":"rs39d5qvtc1rkt2o","title":"","comments":true,"layout":"page"},{"content":"","source":"api/transaction/output.md","raw":"","date":1419285022000,"updated":1419285022000,"path":"api/transaction/output.html","excerpt":"","_id":"1t7n0pbhzzymxzoe","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"Signing\"></a></p>\n<h1 id=\"Signing\">Signing</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#Signing\">Signing</a><ul>\n<li><a href=\"#Signing.sighash\">Signing.sighash</a></li>\n<li><a href=\"#Signing.sign\">Signing.sign</a></li>\n<li><a href=\"#Signing.verify\">Signing.verify</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"Signing.sighash\"></a></p>\n<h2 id=\"Signing-sighash\">Signing.sighash</h2>\n<p>Returns a buffer of length 32 bytes with the hash that needs to be signed<br>for OP_CHECKSIG.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>transaction <code>Transaction</code> - the transaction to sign  </li>\n<li>sighashType <code>number</code> - the type of the hash  </li>\n<li>inputNumber <code>number</code> - the input index for the signature  </li>\n<li>subscript <code>Script</code> - the script that will be signed  </li>\n</ul>\n<p><a name=\"Signing.sign\"></a></p>\n<h2 id=\"Signing-sign\">Signing.sign</h2>\n<p>Create a signature</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>transaction <code>Transaction</code>  </li>\n<li>privateKey <code>PrivateKey</code>  </li>\n<li>sighash <code>number</code>  </li>\n<li>inputIndex <code>number</code>  </li>\n<li>subscript <code>Script</code>  </li>\n</ul>\n<p><strong>Returns</strong>: <code>Signature</code><br><a name=\"Signing.verify\"></a></p>\n<h2 id=\"Signing-verify\">Signing.verify</h2>\n<p>Verify a signature</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>transaction <code>Transaction</code>  </li>\n<li>signature <code>Signature</code>  </li>\n<li>publicKey <code>PublicKey</code>  </li>\n<li>inputIndex <code>number</code>  </li>\n<li>subscript <code>Script</code>  </li>\n</ul>\n<p><strong>Returns</strong>: <code>boolean</code>  </p>\n","source":"api/transaction/sighash.md","raw":"<a name=\"Signing\"></a>\n#Signing\n**Members**\n\n* [Signing](#Signing)\n  * [Signing.sighash](#Signing.sighash)\n  * [Signing.sign](#Signing.sign)\n  * [Signing.verify](#Signing.verify)\n\n<a name=\"Signing.sighash\"></a>\n##Signing.sighash\nReturns a buffer of length 32 bytes with the hash that needs to be signed\nfor OP_CHECKSIG.\n\n**Params**\n\n- transaction `Transaction` - the transaction to sign  \n- sighashType `number` - the type of the hash  \n- inputNumber `number` - the input index for the signature  \n- subscript `Script` - the script that will be signed  \n\n<a name=\"Signing.sign\"></a>\n##Signing.sign\nCreate a signature\n\n**Params**\n\n- transaction `Transaction`  \n- privateKey `PrivateKey`  \n- sighash `number`  \n- inputIndex `number`  \n- subscript `Script`  \n\n**Returns**: `Signature`  \n<a name=\"Signing.verify\"></a>\n##Signing.verify\nVerify a signature\n\n**Params**\n\n- transaction `Transaction`  \n- signature `Signature`  \n- publicKey `PublicKey`  \n- inputIndex `number`  \n- subscript `Script`  \n\n**Returns**: `boolean`  \n","date":1419285026000,"updated":1419285026000,"path":"api/transaction/sighash.html","excerpt":"","_id":"rcems3sat7rus3i0","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"Transaction\"></a></p>\n<h1 id=\"class:_Transaction\">class: Transaction</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#Transaction\">class: Transaction</a><ul>\n<li><a href=\"#new_Transaction\">new Transaction(serialized)</a></li>\n<li><a href=\"#Transaction.shallowCopy\">Transaction.shallowCopy(transaction)</a></li>\n<li><a href=\"#Transaction#_getHash\">transaction._getHash()</a></li>\n<li><a href=\"#Transaction#serialize\">transaction.serialize([unsafe])</a></li>\n<li><a href=\"#Transaction#from\">transaction.from(utxo, [pubkeys], [threshold])</a></li>\n<li><a href=\"#Transaction#addInput\">transaction.addInput(input, outputScript, satoshis)</a></li>\n<li><a href=\"#Transaction#uncheckedAddInput\">transaction.uncheckedAddInput(input)</a></li>\n<li><a href=\"#Transaction#hasAllUtxoInfo\">transaction.hasAllUtxoInfo()</a></li>\n<li><a href=\"#Transaction#fee\">transaction.fee(amount)</a></li>\n<li><a href=\"#Transaction#change\">transaction.change(amount)</a></li>\n<li><a href=\"#Transaction#to\">transaction.to(address, amount)</a></li>\n<li><a href=\"#Transaction#addData\">transaction.addData(value)</a></li>\n<li><a href=\"#Transaction#sign\">transaction.sign(privateKey, sigtype)</a></li>\n<li><a href=\"#Transaction#applySignature\">transaction.applySignature(signature)</a></li>\n<li><a href=\"#Transaction#verifySignature\">transaction.verifySignature()</a></li>\n<li><a href=\"#Transaction#verify\">transaction.verify()</a></li>\n<li><a href=\"#Transaction#isCoinbase\">transaction.isCoinbase()</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"new_Transaction\"></a></p>\n<h2 id=\"new_Transaction(serialized)\">new Transaction(serialized)</h2>\n<p>Represents a transaction, a set of inputs and outputs to change ownership of tokens</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>serialized <code>*</code>  </li>\n</ul>\n<p><a name=\"Transaction.shallowCopy\"></a></p>\n<h2 id=\"Transaction-shallowCopy(transaction)\">Transaction.shallowCopy(transaction)</h2>\n<p>Create a ‘shallow’ copy of the transaction, by serializing and deserializing<br>it dropping any additional information that inputs and outputs may have hold</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>transaction <code><a href=\"#Transaction\">Transaction</a></code>  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Transaction\">Transaction</a><br><a name=\"Transaction#_getHash\"></a></p>\n<h2 id=\"transaction-_getHash()\">transaction._getHash()</h2>\n<p>Retrieve the little endian hash of the transaction (used for serialization)</p>\n<p><strong>Returns</strong>: <code>Buffer</code><br><a name=\"Transaction#serialize\"></a></p>\n<h2 id=\"transaction-serialize([unsafe])\">transaction.serialize([unsafe])</h2>\n<p>Retrieve a hexa string that can be used with bitcoind’s CLI interface<br>(decoderawtransaction, sendrawtransaction)</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>[unsafe] <code>boolean</code> - if true, skip testing for fees that are too high  </li>\n</ul>\n<p><strong>Returns</strong>: <code>string</code><br><a name=\"Transaction#from\"></a></p>\n<h2 id=\"transaction-from(utxo,_[pubkeys],_[threshold])\">transaction.from(utxo, [pubkeys], [threshold])</h2>\n<p>Add an input to this transaction. This is a high level interface<br>to add an input, for more control, use @{link Transaction#addInput}.</p>\n<p>Can receive, as output information, the output of bitcoind’s <code>listunspent</code> command,<br>and a slightly fancier format recognized by bitcore:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"rules\">{</span></div><div class=\"line\"> <span class=\"rule\"><span class=\"attribute\">address</span>:<span class=\"value\"> <span class=\"string\">'mszYqVnqKoQx4jcTdJXxwKAissE3Jbrrc1'</span>,</span></span></div><div class=\"line\"> txId: <span class=\"string\">'a477af6b2667c29670467e4e0728b685ee07b240235771862318e29ddbe58458'</span>,</div><div class=\"line\"> outputIndex: <span class=\"number\">0</span>,</div><div class=\"line\"> script: Script.<span class=\"function\">empty</span>(),</div><div class=\"line\"> satoshis: <span class=\"number\">1020000</span></div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>Where <code>address</code> can be either a string or a bitcore Address object. The<br>same is true for <code>script</code>, which can be a string or a bitcore Script.</p>\n<p>Beware that this resets all the signatures for inputs (in further versions,<br>SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>utxo <code>Object</code>  </li>\n<li>[pubkeys] <code>Array</code>  </li>\n<li>[threshold] <code>number</code>  </li>\n</ul>\n<p><strong>Example</strong>  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> transaction = <span class=\"keyword\">new</span> Transaction();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// From a pay to public key hash output from bitcoind's listunspent</span></div><div class=\"line\">transaction.from({<span class=\"string\">'txid'</span>: <span class=\"string\">'0000...'</span>, vout: <span class=\"number\">0</span>, amount: <span class=\"number\">0.1</span>, scriptPubKey: <span class=\"string\">'OP_DUP ...'</span>});</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// From a pay to public key hash output</span></div><div class=\"line\">transaction.from({<span class=\"string\">'txId'</span>: <span class=\"string\">'0000...'</span>, outputIndex: <span class=\"number\">0</span>, satoshis: <span class=\"number\">1000</span>, script: <span class=\"string\">'OP_DUP ...'</span>});</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// From a multisig P2SH output</span></div><div class=\"line\">transaction.from({<span class=\"string\">'txId'</span>: <span class=\"string\">'0000...'</span>, inputIndex: <span class=\"number\">0</span>, satoshis: <span class=\"number\">1000</span>, script: <span class=\"string\">'... OP_HASH'</span>},</div><div class=\"line\">                 [<span class=\"string\">'03000...'</span>, <span class=\"string\">'02000...'</span>], <span class=\"number\">2</span>);</div></pre></td></tr></table></figure>\n\n<p><a name=\"Transaction#addInput\"></a></p>\n<h2 id=\"transaction-addInput(input,_outputScript,_satoshis)\">transaction.addInput(input, outputScript, satoshis)</h2>\n<p>Add an input to this transaction. The input must be an instance of the <code>Input</code> class.<br>It should have information about the Output that it’s spending, but if it’s not already<br>set, two additional parameters, <code>outputScript</code> and <code>satoshis</code> can be provided.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>input <code>Input</code>  </li>\n<li>outputScript <code>String</code> | <code>Script</code>  </li>\n<li>satoshis <code>number</code>  </li>\n</ul>\n<p><strong>Returns</strong>:  - Transaction this, for chaining<br><a name=\"Transaction#uncheckedAddInput\"></a></p>\n<h2 id=\"transaction-uncheckedAddInput(input)\">transaction.uncheckedAddInput(input)</h2>\n<p>Add an input to this transaction, without checking that the input has information about<br>the output that it’s spending.</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>input <code>Input</code>  </li>\n</ul>\n<p><strong>Returns</strong>:  - Transaction this, for chaining<br><a name=\"Transaction#hasAllUtxoInfo\"></a></p>\n<h2 id=\"transaction-hasAllUtxoInfo()\">transaction.hasAllUtxoInfo()</h2>\n<p>Returns true if the transaction has enough info on all inputs to be correctly validated</p>\n<p><strong>Returns</strong>: <code>boolean</code><br><a name=\"Transaction#fee\"></a></p>\n<h2 id=\"transaction-fee(amount)\">transaction.fee(amount)</h2>\n<p>Manually set the fee for this transaction. Beware that this resets all the signatures<br>for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not<br>be reset).</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>amount <code>number</code> - satoshis to be sent  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Transaction\">Transaction</a> - this, for chaining<br><a name=\"Transaction#change\"></a></p>\n<h2 id=\"transaction-change(amount)\">transaction.change(amount)</h2>\n<p>Set the change address for this transaction</p>\n<p>Beware that this resets all the signatures for inputs (in further versions,<br>SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>amount <code>number</code> - satoshis to be sent  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Transaction\">Transaction</a> - this, for chaining<br><a name=\"Transaction#to\"></a></p>\n<h2 id=\"transaction-to(address,_amount)\">transaction.to(address, amount)</h2>\n<p>Add an output to the transaction.</p>\n<p>Beware that this resets all the signatures for inputs (in further versions,<br>SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>address <code>string</code> | <code>Address</code>  </li>\n<li>amount <code>number</code> - in satoshis  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Transaction\">Transaction</a> - this, for chaining<br><a name=\"Transaction#addData\"></a></p>\n<h2 id=\"transaction-addData(value)\">transaction.addData(value)</h2>\n<p>Add an OP_RETURN output to the transaction.</p>\n<p>Beware that this resets all the signatures for inputs (in further versions,<br>SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>value <code>Buffer</code> | <code>string</code> - the data to be stored in the OP_RETURN output.<br> In case of a string, the UTF-8 representation will be stored  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Transaction\">Transaction</a> - this, for chaining<br><a name=\"Transaction#sign\"></a></p>\n<h2 id=\"transaction-sign(privateKey,_sigtype)\">transaction.sign(privateKey, sigtype)</h2>\n<p>Sign the transaction using one or more private keys.</p>\n<p>It tries to sign each input, verifying that the signature will be valid<br>(matches a public key).</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>privateKey <code>Array</code> | <code>String</code> | <code>PrivateKey</code>  </li>\n<li>sigtype <code>number</code>  </li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Transaction\">Transaction</a> - this, for chaining<br><a name=\"Transaction#applySignature\"></a></p>\n<h2 id=\"transaction-applySignature(signature)\">transaction.applySignature(signature)</h2>\n<p>Add a signature to the transaction</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>signature <code>Object</code>  <ul>\n<li>inputIndex <code>number</code>  </li>\n<li>sighash <code>number</code>  </li>\n<li>publicKey <code>PublicKey</code>  </li>\n<li>signature <code>Signature</code>  </li>\n</ul>\n</li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#Transaction\">Transaction</a> - this, for chaining<br><a name=\"Transaction#verifySignature\"></a></p>\n<h2 id=\"transaction-verifySignature()\">transaction.verifySignature()</h2>\n<p><strong>Returns</strong>: <code>bool</code> - whether the signature is valid for this transaction input<br><a name=\"Transaction#verify\"></a></p>\n<h2 id=\"transaction-verify()\">transaction.verify()</h2>\n<p>Check that a transaction passes basic sanity tests. If not, return a string<br>describing the error. This function contains the same logic as<br>CheckTransaction in bitcoin core.</p>\n<p><a name=\"Transaction#isCoinbase\"></a></p>\n<h2 id=\"transaction-isCoinbase()\">transaction.isCoinbase()</h2>\n<p>Analagous to bitcoind’s IsCoinBase function in transaction.h</p>\n","source":"api/transaction/transaction.md","raw":"<a name=\"Transaction\"></a>\n#class: Transaction\n**Members**\n\n* [class: Transaction](#Transaction)\n  * [new Transaction(serialized)](#new_Transaction)\n  * [Transaction.shallowCopy(transaction)](#Transaction.shallowCopy)\n  * [transaction._getHash()](#Transaction#_getHash)\n  * [transaction.serialize([unsafe])](#Transaction#serialize)\n  * [transaction.from(utxo, [pubkeys], [threshold])](#Transaction#from)\n  * [transaction.addInput(input, outputScript, satoshis)](#Transaction#addInput)\n  * [transaction.uncheckedAddInput(input)](#Transaction#uncheckedAddInput)\n  * [transaction.hasAllUtxoInfo()](#Transaction#hasAllUtxoInfo)\n  * [transaction.fee(amount)](#Transaction#fee)\n  * [transaction.change(amount)](#Transaction#change)\n  * [transaction.to(address, amount)](#Transaction#to)\n  * [transaction.addData(value)](#Transaction#addData)\n  * [transaction.sign(privateKey, sigtype)](#Transaction#sign)\n  * [transaction.applySignature(signature)](#Transaction#applySignature)\n  * [transaction.verifySignature()](#Transaction#verifySignature)\n  * [transaction.verify()](#Transaction#verify)\n  * [transaction.isCoinbase()](#Transaction#isCoinbase)\n\n<a name=\"new_Transaction\"></a>\n##new Transaction(serialized)\nRepresents a transaction, a set of inputs and outputs to change ownership of tokens\n\n**Params**\n\n- serialized `*`  \n\n<a name=\"Transaction.shallowCopy\"></a>\n##Transaction.shallowCopy(transaction)\nCreate a 'shallow' copy of the transaction, by serializing and deserializing\nit dropping any additional information that inputs and outputs may have hold\n\n**Params**\n\n- transaction <code>[Transaction](#Transaction)</code>  \n\n**Returns**: [Transaction](#Transaction)  \n<a name=\"Transaction#_getHash\"></a>\n##transaction._getHash()\nRetrieve the little endian hash of the transaction (used for serialization)\n\n**Returns**: `Buffer`  \n<a name=\"Transaction#serialize\"></a>\n##transaction.serialize([unsafe])\nRetrieve a hexa string that can be used with bitcoind's CLI interface\n(decoderawtransaction, sendrawtransaction)\n\n**Params**\n\n- \\[unsafe\\] `boolean` - if true, skip testing for fees that are too high  \n\n**Returns**: `string`  \n<a name=\"Transaction#from\"></a>\n##transaction.from(utxo, [pubkeys], [threshold])\nAdd an input to this transaction. This is a high level interface\nto add an input, for more control, use @{link Transaction#addInput}.\n\nCan receive, as output information, the output of bitcoind's `listunspent` command,\nand a slightly fancier format recognized by bitcore:\n\n```\n{\n address: 'mszYqVnqKoQx4jcTdJXxwKAissE3Jbrrc1',\n txId: 'a477af6b2667c29670467e4e0728b685ee07b240235771862318e29ddbe58458',\n outputIndex: 0,\n script: Script.empty(),\n satoshis: 1020000\n}\n```\nWhere `address` can be either a string or a bitcore Address object. The\nsame is true for `script`, which can be a string or a bitcore Script.\n\nBeware that this resets all the signatures for inputs (in further versions,\nSIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n\n**Params**\n\n- utxo `Object`  \n- \\[pubkeys\\] `Array`  \n- \\[threshold\\] `number`  \n\n**Example**  \n```javascript\nvar transaction = new Transaction();\n\n// From a pay to public key hash output from bitcoind's listunspent\ntransaction.from({'txid': '0000...', vout: 0, amount: 0.1, scriptPubKey: 'OP_DUP ...'});\n\n// From a pay to public key hash output\ntransaction.from({'txId': '0000...', outputIndex: 0, satoshis: 1000, script: 'OP_DUP ...'});\n\n// From a multisig P2SH output\ntransaction.from({'txId': '0000...', inputIndex: 0, satoshis: 1000, script: '... OP_HASH'},\n                 ['03000...', '02000...'], 2);\n```\n\n<a name=\"Transaction#addInput\"></a>\n##transaction.addInput(input, outputScript, satoshis)\nAdd an input to this transaction. The input must be an instance of the `Input` class.\nIt should have information about the Output that it's spending, but if it's not already\nset, two additional parameters, `outputScript` and `satoshis` can be provided.\n\n**Params**\n\n- input `Input`  \n- outputScript `String` | `Script`  \n- satoshis `number`  \n\n**Returns**:  - Transaction this, for chaining  \n<a name=\"Transaction#uncheckedAddInput\"></a>\n##transaction.uncheckedAddInput(input)\nAdd an input to this transaction, without checking that the input has information about\nthe output that it's spending.\n\n**Params**\n\n- input `Input`  \n\n**Returns**:  - Transaction this, for chaining  \n<a name=\"Transaction#hasAllUtxoInfo\"></a>\n##transaction.hasAllUtxoInfo()\nReturns true if the transaction has enough info on all inputs to be correctly validated\n\n**Returns**: `boolean`  \n<a name=\"Transaction#fee\"></a>\n##transaction.fee(amount)\nManually set the fee for this transaction. Beware that this resets all the signatures\nfor inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not\nbe reset).\n\n**Params**\n\n- amount `number` - satoshis to be sent  \n\n**Returns**: [Transaction](#Transaction) - this, for chaining  \n<a name=\"Transaction#change\"></a>\n##transaction.change(amount)\nSet the change address for this transaction\n\nBeware that this resets all the signatures for inputs (in further versions,\nSIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n\n**Params**\n\n- amount `number` - satoshis to be sent  \n\n**Returns**: [Transaction](#Transaction) - this, for chaining  \n<a name=\"Transaction#to\"></a>\n##transaction.to(address, amount)\nAdd an output to the transaction.\n\nBeware that this resets all the signatures for inputs (in further versions,\nSIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n\n**Params**\n\n- address `string` | `Address`  \n- amount `number` - in satoshis  \n\n**Returns**: [Transaction](#Transaction) - this, for chaining  \n<a name=\"Transaction#addData\"></a>\n##transaction.addData(value)\nAdd an OP_RETURN output to the transaction.\n\nBeware that this resets all the signatures for inputs (in further versions,\nSIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n\n**Params**\n\n- value `Buffer` | `string` - the data to be stored in the OP_RETURN output.\n   In case of a string, the UTF-8 representation will be stored  \n\n**Returns**: [Transaction](#Transaction) - this, for chaining  \n<a name=\"Transaction#sign\"></a>\n##transaction.sign(privateKey, sigtype)\nSign the transaction using one or more private keys.\n\nIt tries to sign each input, verifying that the signature will be valid\n(matches a public key).\n\n**Params**\n\n- privateKey `Array` | `String` | `PrivateKey`  \n- sigtype `number`  \n\n**Returns**: [Transaction](#Transaction) - this, for chaining  \n<a name=\"Transaction#applySignature\"></a>\n##transaction.applySignature(signature)\nAdd a signature to the transaction\n\n**Params**\n\n- signature `Object`  \n  - inputIndex `number`  \n  - sighash `number`  \n  - publicKey `PublicKey`  \n  - signature `Signature`  \n\n**Returns**: [Transaction](#Transaction) - this, for chaining  \n<a name=\"Transaction#verifySignature\"></a>\n##transaction.verifySignature()\n**Returns**: `bool` - whether the signature is valid for this transaction input  \n<a name=\"Transaction#verify\"></a>\n##transaction.verify()\nCheck that a transaction passes basic sanity tests. If not, return a string\ndescribing the error. This function contains the same logic as\nCheckTransaction in bitcoin core.\n\n<a name=\"Transaction#isCoinbase\"></a>\n##transaction.isCoinbase()\nAnalagous to bitcoind's IsCoinBase function in transaction.h\n\n","date":1419285026000,"updated":1419285026000,"path":"api/transaction/transaction.html","excerpt":"","_id":"o5ga7qrwribpmstf","title":"","comments":true,"layout":"page"},{"content":"","source":"api/transaction/input/index.md","raw":"","date":1419285023000,"updated":1419285023000,"path":"api/transaction/input/index.html","excerpt":"","_id":"jl91ltohaxndy1y9","title":"","comments":true,"layout":"page"},{"content":"","source":"api/transaction/input/input.md","raw":"","date":1419285023000,"updated":1419285023000,"path":"api/transaction/input/input.html","excerpt":"","_id":"u3w1cwgz4fydz7p6","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"MultiSigScriptHashInput\"></a></p>\n<h1 id=\"class:_MultiSigScriptHashInput\">class: MultiSigScriptHashInput</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#MultiSigScriptHashInput\">class: MultiSigScriptHashInput</a></li>\n</ul>\n","source":"api/transaction/input/multisigscripthash.md","raw":"<a name=\"MultiSigScriptHashInput\"></a>\n#class: MultiSigScriptHashInput\n**Members**\n\n* [class: MultiSigScriptHashInput](#MultiSigScriptHashInput)\n\n","date":1419285026000,"updated":1419285026000,"path":"api/transaction/input/multisigscripthash.html","excerpt":"","_id":"7epn639br0qqg28b","title":"","comments":true,"layout":"page"},{"content":"<p><a name=\"PublicKeyHashInput\"></a></p>\n<h1 id=\"class:_PublicKeyHashInput\">class: PublicKeyHashInput</h1>\n<p><strong>Members</strong></p>\n<ul>\n<li><a href=\"#PublicKeyHashInput\">class: PublicKeyHashInput</a><ul>\n<li><a href=\"#new_PublicKeyHashInput\">new PublicKeyHashInput()</a></li>\n<li><a href=\"#PublicKeyHashInput#getSignatures\">publicKeyHashInput.getSignatures(transaction, privateKey, index, [sigtype], [hashData])</a></li>\n<li><a href=\"#PublicKeyHashInput#addSignature\">publicKeyHashInput.addSignature(signature)</a></li>\n<li><a href=\"#PublicKeyHashInput#clearSignatures\">publicKeyHashInput.clearSignatures()</a></li>\n<li><a href=\"#PublicKeyHashInput#isFullySigned\">publicKeyHashInput.isFullySigned()</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"new_PublicKeyHashInput\"></a></p>\n<h2 id=\"new_PublicKeyHashInput()\">new PublicKeyHashInput()</h2>\n<p>Represents a special kind of input of PayToPublicKeyHash kind.</p>\n<p><a name=\"PublicKeyHashInput#getSignatures\"></a></p>\n<h2 id=\"publicKeyHashInput-getSignatures(transaction,_privateKey,_index,_[sigtype],_[hashData])\">publicKeyHashInput.getSignatures(transaction, privateKey, index, [sigtype], [hashData])</h2>\n<p><strong>Params</strong></p>\n<ul>\n<li>transaction <code>Transaction</code> - the transaction to be signed  </li>\n<li>privateKey <code>PrivateKey</code> - the private key with which to sign the transaction  </li>\n<li>index <code>number</code> - the index of the input in the transaction input vector  </li>\n<li>[sigtype] <code>number</code> - the type of signature, defaults to Signature.SIGHASH_ALL  </li>\n<li>[hashData] <code>Buffer</code> - the precalculated hash of the public key associated with the privateKey provided  </li>\n</ul>\n<p><strong>Returns</strong>: <code>Array</code> - of objects that can be<br><a name=\"PublicKeyHashInput#addSignature\"></a></p>\n<h2 id=\"publicKeyHashInput-addSignature(signature)\">publicKeyHashInput.addSignature(signature)</h2>\n<p>Add the provided signature</p>\n<p><strong>Params</strong></p>\n<ul>\n<li>signature <code>Object</code>  <ul>\n<li>publicKey <code>PublicKey</code>  </li>\n<li>signature <code>Signature</code>  </li>\n<li>[sigtype] <code>number</code>  </li>\n</ul>\n</li>\n</ul>\n<p><strong>Returns</strong>: <a href=\"#PublicKeyHashInput\">PublicKeyHashInput</a> - this, for chaining<br><a name=\"PublicKeyHashInput#clearSignatures\"></a></p>\n<h2 id=\"publicKeyHashInput-clearSignatures()\">publicKeyHashInput.clearSignatures()</h2>\n<p>Clear the input’s signature</p>\n<p><strong>Returns</strong>: <a href=\"#PublicKeyHashInput\">PublicKeyHashInput</a> - this, for chaining<br><a name=\"PublicKeyHashInput#isFullySigned\"></a></p>\n<h2 id=\"publicKeyHashInput-isFullySigned()\">publicKeyHashInput.isFullySigned()</h2>\n<p>Query whether the input is signed</p>\n<p><strong>Returns</strong>: <code>boolean</code>  </p>\n","source":"api/transaction/input/publickeyhash.md","raw":"<a name=\"PublicKeyHashInput\"></a>\n#class: PublicKeyHashInput\n**Members**\n\n* [class: PublicKeyHashInput](#PublicKeyHashInput)\n  * [new PublicKeyHashInput()](#new_PublicKeyHashInput)\n  * [publicKeyHashInput.getSignatures(transaction, privateKey, index, [sigtype], [hashData])](#PublicKeyHashInput#getSignatures)\n  * [publicKeyHashInput.addSignature(signature)](#PublicKeyHashInput#addSignature)\n  * [publicKeyHashInput.clearSignatures()](#PublicKeyHashInput#clearSignatures)\n  * [publicKeyHashInput.isFullySigned()](#PublicKeyHashInput#isFullySigned)\n\n<a name=\"new_PublicKeyHashInput\"></a>\n##new PublicKeyHashInput()\nRepresents a special kind of input of PayToPublicKeyHash kind.\n\n<a name=\"PublicKeyHashInput#getSignatures\"></a>\n##publicKeyHashInput.getSignatures(transaction, privateKey, index, [sigtype], [hashData])\n**Params**\n\n- transaction `Transaction` - the transaction to be signed  \n- privateKey `PrivateKey` - the private key with which to sign the transaction  \n- index `number` - the index of the input in the transaction input vector  \n- \\[sigtype\\] `number` - the type of signature, defaults to Signature.SIGHASH_ALL  \n- \\[hashData\\] `Buffer` - the precalculated hash of the public key associated with the privateKey provided  \n\n**Returns**: `Array` - of objects that can be  \n<a name=\"PublicKeyHashInput#addSignature\"></a>\n##publicKeyHashInput.addSignature(signature)\nAdd the provided signature\n\n**Params**\n\n- signature `Object`  \n  - publicKey `PublicKey`  \n  - signature `Signature`  \n  - \\[sigtype\\] `number`  \n\n**Returns**: [PublicKeyHashInput](#PublicKeyHashInput) - this, for chaining  \n<a name=\"PublicKeyHashInput#clearSignatures\"></a>\n##publicKeyHashInput.clearSignatures()\nClear the input's signature\n\n**Returns**: [PublicKeyHashInput](#PublicKeyHashInput) - this, for chaining  \n<a name=\"PublicKeyHashInput#isFullySigned\"></a>\n##publicKeyHashInput.isFullySigned()\nQuery whether the input is signed\n\n**Returns**: `boolean`  \n","date":1419285026000,"updated":1419285026000,"path":"api/transaction/input/publickeyhash.html","excerpt":"","_id":"9e7967ob7bt13yiw","title":"","comments":true,"layout":"page"}],"Post":[],"Tag":[]}